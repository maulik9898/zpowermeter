###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             15/Oct/2015  21:15:43 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c                      #
#    Command line       =  -f C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\..\Tools\f8wRouter.cfg (-DCPU32MHZ  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wConfig.cfg (-DZIGBEEPRO    #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wZCL.cfg                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c -D SECURE=0 -D       #
#                          OSC32K_CRYSTAL_INSTALLED=FALSE -D HAL_KEY=FALSE    #
#                          -D HAL_BOARD_CC2530EB_REV17 -D TC_LINKKEY_JOIN -D  #
#                          NV_INIT -D xNV_RESTORE -D MULTICAST_ENABLED=FALSE  #
#                          -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D          #
#                          FEATURE_SYSTEM_STATS -lC                           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ -lA                     #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ --diag_suppress         #
#                          Pe001,Pa010 -o C:\Users\paolo\Documents\GitHub\zpo #
#                          wermeter\firmware\CC2530DB\RouterEB\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\ -I C:\Users\paolo\Documents\GitHub #
#                          \zpowermeter\firmware\CC2530DB\..\Source\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\ha\ -I                       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\zmain\ -I                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\target\CC2530EB\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\high_level\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\sing #
#                          le_chip\ -I C:\Users\paolo\Documents\GitHub\zpower #
#                          meter\firmware\CC2530DB\..\Components\mt\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\osal\include\ -I         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\saddr\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\sdata\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\af\ -I             #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\nwk\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sapi\ -I           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sec\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sys\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zcl\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zdo\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\ -I                 #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\f8w\ -Ohz           #
#                          --require_prototypes                               #
#    List file          =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\zcl.lst                  #
#    Object file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\Obj\zcl.r51                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\paolo\Documents\GitHub\zpowermeter\firmware\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2014-06-25 18:07:01 -0700 (Wed, 25 Jun 2014) $
      4            Revision:       $Revision: 39221 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Command record list
    104          typedef struct zclCmdRecsList
    105          {
    106            struct zclCmdRecsList *pNext;
    107            uint8                 endpoint;
    108            uint8                 numCommands;
    109            CONST zclCommandRec_t *pCmdRecs;
    110          } zclCmdRecsList_t;
    111          
    112          // Attribute record list item
    113          typedef struct zclAttrRecsList
    114          {
    115            struct zclAttrRecsList *next;
    116            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    117            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    118            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    119            CONST zclAttrRec_t     *attrs;        // attribute records
    120          } zclAttrRecsList;
    121          
    122          // Cluster option list item
    123          typedef struct zclClusterOptionList
    124          {
    125            struct zclClusterOptionList *next;
    126            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    127            uint8                       numOptions; // Number of the following records
    128            zclOptionRec_t              *options;   // option records
    129          } zclClusterOptionList;
    130          
    131          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    132          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    133          
    134          typedef struct
    135          {
    136            zclParseInProfileCmd_t   pfnParseInProfile;
    137            zclProcessInProfileCmd_t pfnProcessInProfile;
    138          } zclCmdItems_t;
    139          
    140          
    141          /*********************************************************************
    142           * GLOBAL VARIABLES
    143           */
    144          
    145          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    146            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    147          
    148            // The task Id of the Application where the unprocessed Foundation
    149            // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    150            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    151          #endif
    152          
    153          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    154          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    155          
    156          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    158          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    159          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    160          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    162          
    163          /*********************************************************************
    164           * EXTERNAL VARIABLES
    165           */
    166          
    167          /*********************************************************************
    168           * EXTERNAL FUNCTIONS
    169           */
    170          
    171          /*********************************************************************
    172           * LOCAL VARIABLES
    173           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    174          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    175          
    176          #if defined ( ZCL_DISCOVER )
    177            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    178          #endif
    179          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          
    185          /*********************************************************************
    186           * LOCAL FUNCTIONS
    187           */
    188          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    189          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    190          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    191          
    192          #if defined ( ZCL_DISCOVER )
    193            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    194          #endif
    195          
    196          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    197          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    198          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    199          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    200          
    201          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    202          
    203          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    204          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    205          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    206          #endif // ZCL_READ || ZCL_WRITE
    207          
    208          #ifdef ZCL_READ
    209          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    210          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    211          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    212                                                   uint8 *pAttrData, uint16 *pDataLen );
    213          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    214          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    215          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    216          #endif // ZCL_READ
    217          
    218          #ifdef ZCL_WRITE
    219          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    220                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    221          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    222                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    223          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    224          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    225          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    226          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    227          #endif // ZCL_WRITE
    228          
    229          #ifdef ZCL_REPORT
    230          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    231          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    232          #endif // ZCL_REPORT
    233          
    234          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    235          
    236          #ifdef ZCL_DISCOVER
    237          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    238          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    239          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    240          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    241          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    242          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    243          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    244          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    245          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    246          #endif // ZCL_DISCOVER
    247          
    248          /*********************************************************************
    249           * Parse Profile Command Function Table
    250           */
    251          

   \                                 In  segment CODE_C, align 1
    252          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zcl_HandleExternal?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zcl_HandleExternal?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   ....         DW ??zclParseInConfigReportCmd?relay
   \   00001A   ....         DW ??zcl_HandleExternal?relay
   \   00001C   ....         DW ??zclParseInConfigReportRspCmd?relay
   \   00001E   ....         DW ??zcl_HandleExternal?relay
   \   000020   ....         DW ??zclParseInReadReportCfgCmd?relay
   \   000022   ....         DW ??zcl_HandleExternal?relay
   \   000024   ....         DW ??zclParseInReadReportCfgRspCmd?relay
   \   000026   ....         DW ??zcl_HandleExternal?relay
   \   000028   ....         DW ??zclParseInReportCmd?relay
   \   00002A   ....         DW ??zcl_HandleExternal?relay
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zcl_HandleExternal?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    253          {
    254          #ifdef ZCL_READ
    255            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    256            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    257          #else
    258            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    259            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    260          #endif // ZCL_READ
    261          
    262          #ifdef ZCL_WRITE
    263            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    264            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    265            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    266            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    267          #else
    268            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    269            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    270            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    271            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    272          #endif // ZCL_WRITE
    273          
    274          #ifdef ZCL_REPORT
    275            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    276            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    277            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    278            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    279            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    280          #else
    281            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    282            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    283            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286          #endif // ZCL_REPORT
    287          
    288            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    289          
    290          #ifdef ZCL_DISCOVER
    291            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    292            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    293            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    294            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    295            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    296            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    297            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    298            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    299            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    300            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    301            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    302          #else
    303            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    304            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    305            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    306            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    307            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    308            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    309            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    310            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    313            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    314          #endif // ZCL_DISCOVER
    315          };
    316          
    317          /*********************************************************************
    318           * PUBLIC FUNCTIONS
    319           *********************************************************************/
    320          
    321          #if !defined ( ZCL_STANDALONE )
    322          /*********************************************************************
    323           * @fn          zcl_Init
    324           *
    325           * @brief       Initialization function for the zcl layer.
    326           *
    327           * @param       task_id - ZCL task id
    328           *
    329           * @return      none
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    332          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    333            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    334          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    335          #endif
    336          
    337          #if !defined ( ZCL_STANDALONE )
    338          /*********************************************************************
    339           * @fn          zcl_event_loop
    340           *
    341           * @brief       Event Loop Processor for zcl.
    342           *
    343           * @param       task_id - task id
    344           * @param       events - event bitmap
    345           *
    346           * @return      unprocessed events
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    349          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    350            uint8 *msgPtr;
    351          
    352            (void)task_id;  // Intentionally unreferenced parameter
    353          
    354            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    355            {
    356              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    357              while ( msgPtr != NULL )
    358              {
    359                uint8 dealloc = TRUE;
    360          
    361                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    362                {
    363                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??zcl_ProcessMessageMSG?relay; Banked call to: zcl_ProcessMessageMSG
    364                }
    365                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    366                {
    367                  // send it to another task to process.
    368                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    369                  dealloc = FALSE;
    370                }
    371          
    372                // Release the memory
    373                if ( dealloc )
    374                {
    375                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    376                }
    377          
    378                // Next
    379                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_msg_receive?relay; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    380              }
    381          
    382              // return unprocessed events
    383              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0
   \   00004F   E5..         MOV     A,?V1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    384            }
    385          
    386            // Discard unknown events
    387            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    388          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    389          #endif
    390          
    391          #if !defined ( ZCL_STANDALONE )
    392          /*********************************************************************
    393           * @fn      zcl_registerForMsg
    394           *
    395           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    396           *          messages that aren't processed to one task (if a task is
    397           *          registered).
    398           *
    399           * @param   taskId - task Id of the Application where commands will be sent to
    400           *
    401           * @return  TRUE if task registeration successful, FALSE otherwise
    402           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    403          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    404          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    405            // Allow only the first task
    406            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    407            {
    408              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    409          
    410              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    411            }
    412          
    413            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    414          }
    415          #endif
    416          
    417          #if !defined ( ZCL_STANDALONE )
    418          /*********************************************************************
    419           * @fn      zcl_HandleExternal
    420           *
    421           * @brief
    422           *
    423           * @param   pInMsg - incoming message to process
    424           *
    425           * @return  TRUE
    426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    427          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    428          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    429            zclIncomingMsg_t *pCmd;
    430          
    431            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    432            {
    433              return ( TRUE );
    434            }
    435          
    436            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_msg_allocate?relay; Banked call to: osal_msg_allocate
    437            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    438            {
    439              // fill in the message
    440              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   7434         MOV     A,#0x34
   \   000027   12....       LCALL   ??Subroutine178_0 & 0xFFFF
    441              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_311:
   \   00002A   A3           INC     DPTR
   \   00002B   EA           MOV     A,R2
   \   00002C   2402         ADD     A,#0x2
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   3B           ADDC    A,R3
   \   000031   FD           MOV     R5,A
   \   000032   7406         MOV     A,#0x6
   \   000034   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    442              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00003E   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_500:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   EC           MOV     A,R4
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   ED           MOV     A,R5
   \   000051   12....       LCALL   ?Subroutine31 & 0xFFFF
    443              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_26:
   \   000054   EA           MOV     A,R2
   \   000055   240A         ADD     A,#0xa
   \   000057   FC           MOV     R4,A
   \   000058   E4           CLR     A
   \   000059   3B           ADDC    A,R3
   \   00005A   FD           MOV     R5,A
   \   00005B   740C         MOV     A,#0xc
   \   00005D   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    444              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   000067   C8           XCH     A,R0
   \   000068   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00006B   38           ADDC    A,R0
   \   00006C   F583         MOV     DPH,A
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   C0E0         PUSH    A
   \   000071   EA           MOV     A,R2
   \   000072   2416         ADD     A,#0x16
   \   000074   F582         MOV     DPL,A
   \   000076   E4           CLR     A
   \   000077   3B           ADDC    A,R3
   \   000078   F583         MOV     DPH,A
   \   00007A   D0E0         POP     A
   \   00007C   F0           MOVX    @DPTR,A
    445              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00007D   EE           MOV     A,R6
   \   00007E   240C         ADD     A,#0xc
   \   000080   F8           MOV     R0,A
   \   000081   E4           CLR     A
   \   000082   3F           ADDC    A,R7
   \   000083   F9           MOV     R1,A
   \   000084   8882         MOV     DPL,R0
   \   000086   8983         MOV     DPH,R1
   \   000088   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   00008B   EA           MOV     A,R2
   \   00008C   2417         ADD     A,#0x17
   \   00008E   F582         MOV     DPL,A
   \   000090   E4           CLR     A
   \   000091   3B           ADDC    A,R3
   \   000092   F583         MOV     DPH,A
   \   000094   EC           MOV     A,R4
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   ED           MOV     A,R5
   \   000098   F0           MOVX    @DPTR,A
    446          
    447              // Application will free the attrCmd buffer
    448              pInMsg->attrCmd = NULL;
   \   000099   8882         MOV     DPL,R0
   \   00009B   8983         MOV     DPH,R1
   \   00009D   E4           CLR     A
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   F0           MOVX    @DPTR,A
    449          
    450              /* send message through task message */
    451              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   0000A1                ; Setup parameters for call to function osal_msg_send
   \   0000A1   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F9           MOV     R1,A
   \   0000A6   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
    452            }
    453          
    454            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000A9   7901         MOV     R1,#0x1
   \   0000AB   02....       LJMP    ?Subroutine2 & 0xFFFF
    455          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_422:
   \   000003   F9           MOV     R1,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine163:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine165:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine155:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine212_0
   \   000001                ; // Fall through to label ??Subroutine212_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine212_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine213_0
   \   000001                ; // Fall through to label ??Subroutine213_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine213_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine214_0
   \   000002                ; // Fall through to label ??Subroutine214_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine214_0:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_513:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine217_0:
   \   000000   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_519:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET
    456          #endif
    457          
    458          
    459          /*********************************************************************
    460           * @fn          zcl_getRawAFMsg
    461           *
    462           * @brief       Call to get original unprocessed AF message
    463           *              (not parsed by ZCL).
    464           *
    465           *   NOTE:  This function can only be called during a ZCL callback function
    466           *          and the calling function must NOT change any data in the message.
    467           *
    468           * @param       none
    469           *
    470           * @return      pointer to original AF message, NULL if not processing
    471           *              AF message.
    472           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    473          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    474          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    475            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   00000A   80..         SJMP    ?Subroutine0
    476          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    477          
    478          /*********************************************************************
    479           * @fn          zcl_getParsedTransSeqNum
    480           *
    481           * @brief       Call to the get the transaction sequence number from 
    482           *              the incoming message.
    483           *
    484           *   NOTE:  This function can only be called during a ZCL callback function
    485           *          and the calling function must NOT change any data in the message.
    486           *
    487           * @param       none
    488           *
    489           * @return      transaction sequence number.
    490           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    491          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    492          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    493            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    494          }
    495          
    496          /*********************************************************************
    497           * @fn          zcl_registerPlugin
    498           *
    499           * @brief       Add a Cluster Library handler
    500           *
    501           * @param       startClusterID - starting cluster ID
    502           * @param       endClusterID - ending cluster ID
    503           * @param       pfnHdlr - function pointer to incoming message handler
    504           *
    505           * @return      ZSuccess if OK
    506           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    507          ZStatus_t zcl_registerPlugin( uint16 startClusterID, uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr ){
   \                     zcl_registerPlugin:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    508            zclLibPlugin_t *pNewItem;
    509            zclLibPlugin_t *pLoop;
    510          
    511            // Fill in the new profile list
    512            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    513            if ( pNewItem == NULL ){
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    514              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8042         SJMP    ??CrossCallReturnLabel_40
    515            }
    516          
    517            // Fill in the plugin record.
    518            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine42 & 0xFFFF
    519            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_45:
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine26 & 0xFFFF
    520            pNewItem->endClusterID = endClusterID;
    521            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_20:
   \   000036   740C         MOV     A,#0xc
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   EA           MOV     A,R2
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   EB           MOV     A,R3
   \   000046   F0           MOVX    @DPTR,A
    522          
    523            // Find spot in list
    524            if (  plugins == NULL )
   \   000047   90....       MOV     DPTR,#plugins
   \   00004A   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00004D   90....       MOV     DPTR,#plugins
   \   000050   6011         JZ      ??zcl_registerPlugin_1
    525            {
    526              plugins = pNewItem;
    527            }
    528            else
    529            {
    530              // Look for end of list
    531              pLoop = plugins;
   \   000052   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_514:
   \   000055   8003         SJMP    ??zcl_registerPlugin_2
    532              while ( pLoop->next != NULL )
    533              {
    534                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000057   EA           MOV     A,R2
   \   000058   FC           MOV     R4,A
   \   000059   EB           MOV     A,R3
    535              }
   \                     ??zcl_registerPlugin_2:
   \   00005A   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   00005D   70F8         JNZ     ??zcl_registerPlugin_3
    536          
    537              // Put new item at end of list
    538              pLoop->next = pNewItem;
   \   00005F   8C82         MOV     DPL,R4
   \   000061   8D83         MOV     DPH,R5
    539            }
   \                     ??zcl_registerPlugin_1:
   \   000063   12....       LCALL   ?Subroutine39 & 0xFFFF
    540          
    541            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_40:
   \   000066   02....       LJMP    ?Subroutine1 & 0xFFFF
    542          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000005   EE           MOV     A,R6
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   EF           MOV     A,R7
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine167_0
   \   000005                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
    543          
    544          #ifdef ZCL_DISCOVER
    545          /*********************************************************************
    546           * @fn          zcl_registerCmdList
    547           *
    548           * @brief       Register a Command List with ZCL Foundation
    549           *
    550           * @param       endpoint - endpoint the attribute list belongs to
    551           * @param       newCmdList - array of command records
    552           *
    553           * @return      ZSuccess if OK
    554           */
    555          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    556          {
    557            zclCmdRecsList_t *pNewItem;
    558            zclCmdRecsList_t *pLoop;
    559          
    560            // Fill in the new profile list
    561            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    562            if ( pNewItem == NULL )
    563            {
    564              return (ZMemError);
    565            }
    566          
    567            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    568            pNewItem->endpoint = endpoint;
    569            pNewItem->numCommands = cmdListSize;
    570            pNewItem->pCmdRecs = newCmdList;
    571          
    572            // Find spot in list
    573            if ( gpCmdList == NULL )
    574            {
    575              gpCmdList = pNewItem;
    576            }
    577            else
    578            {
    579              // Look for end of list
    580              pLoop = gpCmdList;
    581              while ( pLoop->pNext != NULL )
    582              {
    583                pLoop = pLoop->pNext;
    584              }
    585          
    586              // Put new item at end of list
    587              pLoop->pNext = pNewItem;
    588            }
    589          
    590            return ( ZSuccess );
    591          }
    592          #endif  // ZCL_DISCOVER
    593          
    594          /*********************************************************************
    595           * @fn          zcl_registerAttrList
    596           *
    597           * @brief       Register an Attribute List with ZCL Foundation
    598           *
    599           * @param       endpoint - endpoint the attribute list belongs to
    600           * @param       numAttr - number of attributes in list
    601           * @param       newAttrList - array of Attribute records.
    602           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    603           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    604           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    605           *
    606           * @return      ZSuccess if OK
    607           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    608          ZStatus_t zcl_registerAttrList( uint8 endpoint, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    609          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    610            zclAttrRecsList *pNewItem;
    611            zclAttrRecsList *pLoop;
    612          
    613            // Fill in the new profile list
    614            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A09         MOV     R2,#0x9
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   A8..         MOV     R0,?V2
   \   000018   A9..         MOV     R1,?V3
    615            if ( pNewItem == NULL )  {
   \   00001A   E8           MOV     A,R0
   \   00001B   49           ORL     A,R1
   \   00001C   7004         JNZ     ??zcl_registerAttrList_0
    616              return (ZMemError);
   \   00001E   7910         MOV     R1,#0x10
   \   000020   802E         SJMP    ??CrossCallReturnLabel_41
    617            }
    618          
    619            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000022   12....       LCALL   ?Subroutine22 & 0xFFFF
    620            pNewItem->endpoint = endpoint;
    621            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_12:
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   12....       LCALL   ?Subroutine31 & 0xFFFF
    622            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_27:
   \   00002B   A3           INC     DPTR
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
    623          
    624            // Find spot in list
    625          	if ( attrList == NULL ){
   \   000031   90....       MOV     DPTR,#attrList
   \   000034   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000037   90....       MOV     DPTR,#attrList
   \   00003A   6011         JZ      ??zcl_registerAttrList_1
    626          		attrList = pNewItem;
    627           	}  else  {
    628              	// Look for end of list
    629              	pLoop = attrList;
   \   00003C   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_515:
   \   00003F   8003         SJMP    ??zcl_registerAttrList_2
    630              	while ( pLoop->next != NULL ){
    631          			pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000041   EA           MOV     A,R2
   \   000042   FC           MOV     R4,A
   \   000043   EB           MOV     A,R3
    632              	}
   \                     ??zcl_registerAttrList_2:
   \   000044   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000047   70F8         JNZ     ??zcl_registerAttrList_3
    633          
    634              	// Put new item at end of list
    635              	pLoop->next = pNewItem;
   \   000049   8C82         MOV     DPL,R4
   \   00004B   8D83         MOV     DPH,R5
    636          	}
   \                     ??zcl_registerAttrList_1:
   \   00004D   12....       LCALL   ?Subroutine39 & 0xFFFF
    637          
    638          	return ( ZSuccess );
   \                     ??CrossCallReturnLabel_41:
   \   000050   02....       LJMP    ?Subroutine1 & 0xFFFF
    639          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0
   \   00000D   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   22           RET
    640          
    641          /*********************************************************************
    642           * @fn          zcl_registerClusterOptionList
    643           *
    644           * @brief       Register a Cluster Option List with ZCL Foundation
    645           *
    646           * @param       endpoint - endpoint the option list belongs to
    647           * @param       numOption - number of options in list
    648           * @param       optionList - array of cluster option records.
    649           *
    650           *              NOTE: This API should be called to enable 'Application
    651           *                    Link Key' security and/or 'APS ACK' for a specific
    652           *                    Cluster. The 'Application Link Key' is discarded
    653           *                    if security isn't enabled on the device.
    654           *                    The default behavior is 'Network Key' when security
    655           *                    is enabled and no 'APS ACK' for the ZCL messages.
    656           *
    657           * @return      ZSuccess if OK
    658           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    659          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    660          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    661            zclClusterOptionList *pNewItem;
    662            zclClusterOptionList *pLoop;
    663          
    664            // Fill in the new profile list
    665            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    666            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    667            {
    668              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8025         SJMP    ??CrossCallReturnLabel_42
    669            }
    670          
    671            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine22 & 0xFFFF
    672            pNewItem->endpoint = endpoint;
    673            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_13:
   \   000027   12....       LCALL   ?Subroutine26 & 0xFFFF
    674            pNewItem->options = optionList;
    675          
    676            // Find spot in list
    677            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_21:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   6011         JZ      ??zcl_registerClusterOptionList_1
    678            {
    679              clusterOptionList = pNewItem;
    680            }
    681            else
    682            {
    683              // Look for end of list
    684              pLoop = clusterOptionList;
   \   000035   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_516:
   \   000038   8003         SJMP    ??zcl_registerClusterOptionList_2
    685              while ( pLoop->next != NULL )
    686              {
    687                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003A   EA           MOV     A,R2
   \   00003B   FC           MOV     R4,A
   \   00003C   EB           MOV     A,R3
    688              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003D   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000040   70F8         JNZ     ??zcl_registerClusterOptionList_3
    689          
    690              // Put new item at end of list
    691              pLoop->next = pNewItem;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
    692            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
    693          
    694            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_42:
   \   000049   02....       LJMP    ?Subroutine1 & 0xFFFF
    695          }
    696          
    697          /*********************************************************************
    698           * @fn          zcl_registerValidateAttrData
    699           *
    700           * @brief       Add a validation function for attribute data
    701           *
    702           * @param       pfnValidateAttrData - function pointer to validate routine
    703           *
    704           * @return      ZSuccess if OK
    705           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    706          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    707          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    708            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    709          
    710            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   02....       LJMP    ?Subroutine0 & 0xFFFF
    711          }
    712          
    713          /*********************************************************************
    714           * @fn          zcl_registerReadWriteCB
    715           *
    716           * @brief       Register the application's callback function to read/write
    717           *              attribute data, and authorize read/write operation.
    718           *
    719           *              Note: The pfnReadWriteCB callback function is only required
    720           *                    when the attribute data format is unknown to ZCL. The
    721           *                    callback function gets called when the pointer 'dataPtr'
    722           *                    to the attribute value is NULL in the attribute database
    723           *                    registered with the ZCL.
    724           *
    725           *              Note: The pfnAuthorizeCB callback function is only required
    726           *                    when the Read/Write operation on an attribute requires
    727           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    728           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    729           *
    730           * @param       endpoint - application's endpoint
    731           * @param       pfnReadWriteCB - function pointer to read/write routine
    732           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    733           *
    734           * @return      ZSuccess if successful. ZFailure, otherwise.
    735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    736          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    737                                             zclAuthorizeCB_t pfnAuthorizeCB )
    738          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    739            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    740          
    741            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   601D         JZ      ??zcl_registerReadWriteCB_0
    742            {
    743              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine42 & 0xFFFF
    744              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_46:
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E5..         MOV     A,?V1
   \   000034   F0           MOVX    @DPTR,A
    745          
    746              return ( ZSuccess );
   \   000035   7900         MOV     R1,#0x0
   \   000037   8002         SJMP    ??zcl_registerReadWriteCB_1
    747            }
    748          
    749            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000039   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   00003B   02....       LJMP    ?Subroutine3 & 0xFFFF
    750          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    751          
    752          /*********************************************************************
    753           * @fn      zcl_DeviceOperational
    754           *
    755           * @brief   Used to see whether or not the device can send or respond
    756           *          to application level commands.
    757           *
    758           * @param   srcEP - source endpoint
    759           * @param   clusterID - cluster ID
    760           * @param   frameType - command type
    761           * @param   cmd - command ID
    762           *
    763           * @return  TRUE if device is operational, FALSE otherwise
    764           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    765          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    766                                              uint8 frameType, uint8 cmd, uint16 profileID )
    767          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    768            zclAttrRec_t attrRec;
    769            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    770          
    771            (void)profileID;  // Intentionally unreferenced parameter
    772          
    773            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    774            // cannot send or respond to application level commands, other than commands
    775            // to read or write attributes. Note that the Identify cluster cannot be
    776            // disabled, and remains functional regardless of this setting.
    777            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_0
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_1
    778            {
    779              return ( TRUE );
    780            }
    781          
    782            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_1
    783            {
    784              return ( TRUE );
    785            }
    786          
    787            // Is device enabled?
    788            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    789                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_2
    790            {
    791          #ifdef ZCL_READ
    792              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    793          #endif
    794            }
    795          
    796            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   740B         MOV     A,#0xb
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B                REQUIRE ?Subroutine1
   \   00007B                ; // Fall through to label ?Subroutine1
    797          }
    798          
    799          /*********************************************************************
    800           * @fn      zcl_SendCommand
    801           *
    802           * @brief   Used to send Profile and Cluster Specific Command messages.
    803           *
    804           *          NOTE: The calling application is responsible for incrementing
    805           *                the Sequence Number.
    806           *
    807           * @param   srcEp - source endpoint
    808           * @param   destAddr - destination address
    809           * @param   clusterID - cluster ID
    810           * @param   cmd - command ID
    811           * @param   specific - whether the command is Cluster Specific
    812           * @param   direction - client/server direction of the command
    813           * @param   disableDefaultRsp - disable Default Response command
    814           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    815           * @param   seqNumber - identification number for the transaction
    816           * @param   cmdFormatLen - length of the command to be sent
    817           * @param   cmdFormat - command to be sent
    818           *
    819           * @return  ZSuccess if OK
    820           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    821          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    822                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    823                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    824                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    825          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V2,R4
   \   000012   8D..         MOV     ?V3,R5
    826            endPointDesc_t *epDesc;
    827            zclFrameHdr_t hdr;
    828            uint8 *msgBuf;
    829            uint16 msgLen;
    830            uint8 *pBuf;
    831            uint8 options;
    832            ZStatus_t status;
    833          
    834            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    835            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    836            {
    837              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    838            }
    839          
    840          #if defined ( INTER_PAN )
    841            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    842            {
    843              options = AF_TX_OPTIONS_NONE;
    844            }
    845            else
    846          #endif
    847            {
    848              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V2
   \   000027   AB..         MOV     R3,?V3
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    849          
    850              // The cluster might not have been defined to use security but if this message
    851              // is in response to another message that was using APS security this message
    852              // will be sent with APS security
    853              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
    854              {
    855                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine180_0 & 0xFFFF
    856          
    857                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_322:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
    858                {
    859                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
    860                }
    861              }
    862            }
    863          
    864            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    865          
    866            // Not Profile wide command (like READ, WRITE)
    867            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000066   6015         JZ      ??zcl_SendCommand_3
    868            {
    869              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   4401         ORL     A,#0x1
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   8003         SJMP    ??zcl_SendCommand_4
    870            }
    871            else
    872            {
    873              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   54FC         ANL     A,#0xfc
    874            }
   \                     ??zcl_SendCommand_4:
   \   000080   12....       LCALL   ?Subroutine38 & 0xFFFF
    875          
    876            if ( ( epDesc->simpleDesc == NULL ) ||
    877                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    878                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_38:
   \   000083   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000086   602B         JZ      ??zcl_SendCommand_5
   \   000088   741E         MOV     A,#0x1e
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FE           MOV     R6,A
   \   00008F                ; Setup parameters for call to function zcl_DeviceOperational
   \   00008F   8882         MOV     DPL,R0
   \   000091   8983         MOV     DPH,R1
   \   000093   A3           INC     DPTR
   \   000094   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000097   EE           MOV     A,R6
   \   000098   FD           MOV     R5,A
   \   000099   7402         MOV     A,#0x2
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   5403         ANL     A,#0x3
   \   0000A1   FC           MOV     R4,A
   \   0000A2   AA..         MOV     R2,?V2
   \   0000A4   AB..         MOV     R3,?V3
   \   0000A6   A9..         MOV     R1,?V10
   \   0000A8   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   7005         JNZ     ??zcl_SendCommand_6
    879            {
    880              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000B3   7901         MOV     R1,#0x1
   \   0000B5   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    881            }
   \                     ??zcl_SendCommand_6:
   \   0000B8   7422         MOV     A,#0x22
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ??Subroutine180_0 & 0xFFFF
    882          
    883            // Fill in the Maufacturer Code
    884            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_323:
   \   0000C0   6012         JZ      ??CrossCallReturnLabel_462
    885            {
    886              hdr.fc.manuSpecific = 1;
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   4404         ORL     A,#0x4
   \   0000CB   F0           MOVX    @DPTR,A
    887              hdr.manuCode = manuCode;
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   12....       LCALL   ??Subroutine206_0 & 0xFFFF
    888            }
    889          
    890            // Set the Command Direction
    891            if ( direction )
   \                     ??CrossCallReturnLabel_462:
   \   0000D4   7420         MOV     A,#0x20
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   0000DC   6005         JZ      ??zcl_SendCommand_7
    892            {
    893              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   4408         ORL     A,#0x8
   \   0000E1   8003         SJMP    ??zcl_SendCommand_8
    894            }
    895            else
    896            {
    897              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000E6   F0           MOVX    @DPTR,A
    898            }
    899          
    900            // Set the Disable Default Response field
    901            if ( disableDefaultRsp )
   \   0000E7   7421         MOV     A,#0x21
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   0000EF   6005         JZ      ??zcl_SendCommand_9
    902            {
    903              hdr.fc.disableDefaultRsp = 1;
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   4410         ORL     A,#0x10
   \   0000F4   8003         SJMP    ??zcl_SendCommand_10
    904            }
    905            else
    906            {
    907              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000F9   F0           MOVX    @DPTR,A
    908            }
    909          
    910            // Fill in the Transaction Sequence Number
    911            hdr.transSeqNum = seqNum;
   \   0000FA   7424         MOV     A,#0x24
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   C0E0         PUSH    A
   \   000102   7404         MOV     A,#0x4
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   D0E0         POP     A
   \   000109   F0           MOVX    @DPTR,A
    912          
    913            // Fill in the command
    914            hdr.commandID = cmd;
   \   00010A   7405         MOV     A,#0x5
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   EE           MOV     A,R6
   \   000110   F0           MOVX    @DPTR,A
    915          
    916            // calculate the needed buffer size
    917            msgLen = zclCalcHdrSize( &hdr );
   \   000111   75..03       MOV     ?V0,#0x3
   \   000114   85..82       MOV     DPL,?XSP + 0
   \   000117   85..83       MOV     DPH,?XSP + 1
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   5404         ANL     A,#0x4
   \   00011D   6003         JZ      ??zcl_SendCommand_11
   \   00011F   75..05       MOV     ?V0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000122   7425         MOV     A,#0x25
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   12....       LCALL   ?Subroutine108 & 0xFFFF
    918            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_178:
   \   00012A   E5..         MOV     A,?V0
   \   00012C   2E           ADD     A,R6
   \   00012D   F5..         MOV     ?V0,A
   \   00012F   E4           CLR     A
   \   000130   3F           ADDC    A,R7
   \   000131   F5..         MOV     ?V1,A
    919          
    920            // Allocate the buffer needed
    921            msgBuf = zcl_mem_alloc( msgLen );
   \   000133                ; Setup parameters for call to function osal_mem_alloc
   \   000133   AA..         MOV     R2,?V0
   \   000135   FB           MOV     R3,A
   \   000136   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000139   8A..         MOV     ?V8,R2
   \   00013B   8B..         MOV     ?V9,R3
    922            if ( msgBuf != NULL )
   \   00013D   EA           MOV     A,R2
   \   00013E   45..         ORL     A,?V9
   \   000140   6062         JZ      ??zcl_SendCommand_12
    923            {
    924              // Fill in the ZCL Header
    925              pBuf = zclBuildHdr( &hdr, msgBuf );
    926          
    927              // Fill in the command frame
    928              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000142                ; Setup parameters for call to function osal_memcpy
   \   000142   7427         MOV     A,#0x27
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014D                ; Setup parameters for call to function zclBuildHdr
   \   00014D   AC..         MOV     R4,?V8
   \   00014F   AD..         MOV     R5,?V9
   \   000151   7403         MOV     A,#0x3
   \   000153   12....       LCALL   ?XSTACK_DISP101_8
   \   000156   12....       LCALL   ??zclBuildHdr?relay  ; Banked call to: zclBuildHdr
   \   000159   EE           MOV     A,R6
   \   00015A   FC           MOV     R4,A
   \   00015B   EF           MOV     A,R7
   \   00015C   FD           MOV     R5,A
   \   00015D   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000160   7403         MOV     A,#0x3
   \   000162   12....       LCALL   ?DEALLOC_XSTACK8
    929          
    930              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    931                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000165                ; Setup parameters for call to function AF_DataRequest
   \   000165   75..1E       MOV     ?V4,#0x1e
   \   000168   78..         MOV     R0,#?V4
   \   00016A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016D   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000170   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000173   78..         MOV     R0,#?V4
   \   000175   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000178   78..         MOV     R0,#?V8
   \   00017A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017D   78..         MOV     R0,#?V0
   \   00017F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000182   78..         MOV     R0,#?V2
   \   000184   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000187   A9..         MOV     R1,?V7
   \   000189   AC..         MOV     R4,?V12
   \   00018B   AD..         MOV     R5,?V13
   \   00018D   AA..         MOV     R2,?V14
   \   00018F   AB..         MOV     R3,?V15
   \   000191   12....       LCALL   ??AF_DataRequest?relay; Banked call to: AF_DataRequest
   \   000194   7409         MOV     A,#0x9
   \   000196   12....       LCALL   ?DEALLOC_XSTACK8
   \   000199   E9           MOV     A,R1
   \   00019A   FE           MOV     R6,A
    932              zcl_mem_free ( msgBuf );
   \   00019B                ; Setup parameters for call to function osal_mem_free
   \   00019B   AA..         MOV     R2,?V8
   \   00019D   AB..         MOV     R3,?V9
   \   00019F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0001A2   8002         SJMP    ??zcl_SendCommand_13
    933            }
    934            else
    935            {
    936              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   0001A4   7E10         MOV     R6,#0x10
    937            }
    938          
    939            return ( status );
   \                     ??zcl_SendCommand_13:
   \   0001A6   EE           MOV     A,R6
   \   0001A7   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   0001A8   7406         MOV     A,#0x6
   \   0001AA   02....       LJMP    ?Subroutine4 & 0xFFFF
    940          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine158:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine206_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine210_0
   \   000003                ; // Fall through to label ??Subroutine210_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine210_0:
   \   000000   7F10         MOV     R7,#0x10
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_417:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET
    941          
    942          #ifdef ZCL_READ
    943          /*********************************************************************
    944           * @fn      zcl_SendRead
    945           *
    946           * @brief   Send a Read command
    947           *
    948           * @param   srcEP - Application's endpoint
    949           * @param   dstAddr - destination address
    950           * @param   clusterID - cluster ID
    951           * @param   readCmd - read command to be sent
    952           * @param   direction - direction of the command
    953           * @param   seqNum - transaction sequence number
    954           *
    955           * @return  ZSuccess if OK
    956           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    957          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    958                                  uint16 clusterID, zclReadCmd_t *readCmd,
    959                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    960          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine82 & 0xFFFF
    961            uint16 dataLen;
    962            uint8 *buf;
    963            uint8 *pBuf;
    964            ZStatus_t status;
    965          
    966            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_131:
   \   000017   E0           MOVX    A,@DPTR
   \   000018   25E0         ADD     A,0xE0 /* A   */
   \   00001A   F5..         MOV     ?V6,A
   \   00001C   E4           CLR     A
   \   00001D   33           RLC     A
   \   00001E   F5..         MOV     ?V7,A
    967          
    968            buf = zcl_mem_alloc( dataLen );
   \   000020                ; Setup parameters for call to function osal_mem_alloc
   \   000020   AA..         MOV     R2,?V6
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000026   8A..         MOV     ?V0,R2
   \   000028   8B..         MOV     ?V1,R3
    969            if ( buf != NULL )
   \   00002A   EA           MOV     A,R2
   \   00002B   45..         ORL     A,?V1
   \   00002D   7003         JNZ     $+5
   \   00002F   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
    970            {
    971              uint8 i;
    972          
    973              // Load the buffer - serially
    974              pBuf = buf;
   \   000032   A8..         MOV     R0,?V0
   \   000034   A9..         MOV     R1,?V1
    975              for (i = 0; i < readCmd->numAttr; i++)
   \   000036   75..00       MOV     ?V3,#0x0
   \   000039   801F         SJMP    ??zcl_SendRead_1
    976              {
    977                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   00003B   AA..         MOV     R2,?V3
   \   00003D   EA           MOV     A,R2
   \   00003E   2A           ADD     A,R2
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   33           RLC     A
   \   000042   FB           MOV     R3,A
   \   000043   E5..         MOV     A,?V4
   \   000045   2A           ADD     A,R2
   \   000046   F582         MOV     DPL,A
   \   000048   E5..         MOV     A,?V5
   \   00004A   3B           ADDC    A,R3
   \   00004B   F583         MOV     DPH,A
   \   00004D   A3           INC     DPTR
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ?Subroutine141 & 0xFFFF
    978                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_237:
   \   000055   12....       LCALL   ?Subroutine134 & 0xFFFF
    979              }
   \                     ??CrossCallReturnLabel_269:
   \   000058   05..         INC     ?V3
   \                     ??zcl_SendRead_1:
   \   00005A   85..82       MOV     DPL,?V4
   \   00005D   85..83       MOV     DPH,?V5
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   E5..         MOV     A,?V3
   \   000064   C3           CLR     C
   \   000065   9A           SUBB    A,R2
   \   000066   40D3         JC      ??zcl_SendRead_2
    980          
    981              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    982                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000068                ; Setup parameters for call to function zcl_SendCommand
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   78..         MOV     R0,#?V6
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741C         MOV     A,#0x1c
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   E4           CLR     A
   \   00007E   F5..         MOV     ?V4,A
   \   000080   F5..         MOV     ?V5,A
   \   000082   78..         MOV     R0,#?V4
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   741E         MOV     A,#0x1e
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000092   741E         MOV     A,#0x1e
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009D   75..00       MOV     ?V3,#0x0
   \   0000A0   78..         MOV     R0,#?V3
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A5   78..         MOV     R0,#?V3
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FC           MOV     R4,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FD           MOV     R5,A
   \   0000AE   AA..         MOV     R2,?V8
   \   0000B0   AB..         MOV     R3,?V9
   \   0000B2   A9..         MOV     R1,?V2
   \   0000B4   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B7   740B         MOV     A,#0xb
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FE           MOV     R6,A
    983              zcl_mem_free( buf );
   \   0000BE                ; Setup parameters for call to function osal_mem_free
   \   0000BE   AA..         MOV     R2,?V0
   \   0000C0   AB..         MOV     R3,?V1
   \   0000C2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C5   8002         SJMP    ??zcl_SendRead_3
    984            }
    985            else
    986            {
    987              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000C7   7E10         MOV     R6,#0x10
    988            }
    989          
    990            return ( status );
   \                     ??zcl_SendRead_3:
   \   0000C9   02....       LJMP    ?Subroutine10 & 0xFFFF
    991          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine166_0
   \   000005                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   08           INC     R0
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine168_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   A882         MOV     R0,DPL
   \   000007   A983         MOV     R1,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine161:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET
    992          
    993          /*********************************************************************
    994           * @fn      zcl_SendReadRsp
    995           *
    996           * @brief   Send a Read Response command.
    997           *
    998           * @param   srcEP - Application's endpoint
    999           * @param   dstAddr - destination address
   1000           * @param   clusterID - cluster ID
   1001           * @param   readRspCmd - read response command to be sent
   1002           * @param   direction - direction of the command
   1003           * @param   seqNum - transaction sequence number
   1004           *
   1005           * @return  ZSuccess if OK
   1006           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1007          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1008                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1009                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1010          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V12,R2
   \   00000E   8B..         MOV     ?V13,R3
   \   000010   8C..         MOV     ?V6,R4
   \   000012   8D..         MOV     ?V7,R5
   1011            uint8 *buf;
   1012            uint16 len = 0;
   \   000014   7E00         MOV     R6,#0x0
   \   000016   7F00         MOV     R7,#0x0
   1013            ZStatus_t status;
   1014            uint8 i;
   1015          
   1016            // calculate the size of the command
   1017            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   8E..         MOV     ?V2,R6
   \   00001A   7418         MOV     A,#0x18
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_474:
   \   000022   8011         SJMP    ??zcl_SendReadRsp_0
   1018            {
   1019              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1020          
   1021              len += 2 + 1; // Attribute ID + Status
   1022          
   1023              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1024              {
   1025                len++; // Attribute Data Type length
   1026          
   1027                // Attribute Data length
   1028                if ( statusRec->data != NULL )
   1029                {
   1030                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1031                }
   1032                else
   1033                {
   1034                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000024                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000024   12....       LCALL   ?Subroutine87 & 0xFFFF
   1035                }
   \                     ??CrossCallReturnLabel_141:
   \   000027   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002A   8B..         MOV     ?V1,R3
   \   00002C   EE           MOV     A,R6
   \   00002D   2A           ADD     A,R2
   \   00002E   FE           MOV     R6,A
   \   00002F   EF           MOV     A,R7
   \   000030   35..         ADDC    A,?V1
   \   000032   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000033   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000035   85..82       MOV     DPL,?V8
   \   000038   85..83       MOV     DPH,?V9
   \   00003B   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   00003E   5033         JNC     ??zcl_SendReadRsp_4
   \   000040   E5..         MOV     A,?V2
   \   000042   75F006       MOV     B,#0x6
   \   000045   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000048   2403         ADD     A,#0x3
   \   00004A   FE           MOV     R6,A
   \   00004B   E4           CLR     A
   \   00004C   3F           ADDC    A,R7
   \   00004D   FF           MOV     R7,A
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   70E0         JNZ     ??zcl_SendReadRsp_3
   \   000053   0E           INC     R6
   \   000054   EE           MOV     A,R6
   \   000055   7001         JNZ     ??zcl_SendReadRsp_5
   \   000057   0F           INC     R7
   \                     ??zcl_SendReadRsp_5:
   \   000058   8882         MOV     DPL,R0
   \   00005A   8983         MOV     DPH,R1
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000063   8882         MOV     DPL,R0
   \   000065   8983         MOV     DPH,R1
   \   000067   60BB         JZ      ??zcl_SendReadRsp_1
   \   000069                ; Setup parameters for call to function zclGetAttrDataLength
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F9           MOV     R1,A
   \   00006E   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000071   80B7         SJMP    ??zcl_SendReadRsp_2
   1036              }
   1037            }
   1038          
   1039            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   000073                ; Setup parameters for call to function osal_mem_alloc
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00007A   8A..         MOV     ?V0,R2
   \   00007C   8B..         MOV     ?V1,R3
   \   00007E   8A..         MOV     ?V4,R2
   \   000080   8B..         MOV     ?V5,R3
   1040            if ( buf != NULL )
   \   000082   EA           MOV     A,R2
   \   000083   45..         ORL     A,?V5
   \   000085   7003         JNZ     $+5
   \   000087   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
   1041            {
   1042              // Load the buffer - serially
   1043              uint8 *pBuf = buf;
   1044          
   1045              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   00008A   75..00       MOV     ?V2,#0x0
   \   00008D   8036         SJMP    ??zcl_SendReadRsp_7
   1046              {
   1047                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1048          
   1049                *pBuf++ = LO_UINT16( statusRec->attrID );
   1050                *pBuf++ = HI_UINT16( statusRec->attrID );
   1051                *pBuf++ = statusRec->status;
   1052          
   1053                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1054                {
   1055                  *pBuf++ = statusRec->dataType;
   1056          
   1057                  if ( statusRec->data != NULL )
   1058                  {
   1059                    // Copy attribute data to the buffer to be sent out
   1060                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1061                  }
   1062                  else
   1063                  {
   1064                    uint16 dataLen;
   1065          
   1066                    // Read attribute data directly into the buffer to be sent out
   1067                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00008F                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00008F   A8..         MOV     R0,?XSP + 0
   \   000091   A9..         MOV     R1,?XSP + 1
   \   000093   88..         MOV     ?V10,R0
   \   000095   89..         MOV     ?V11,R1
   \   000097   78..         MOV     R0,#?V10
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   8A82         MOV     DPL,R2
   \   0000A3   8B83         MOV     DPH,R3
   \   0000A5   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0000A8   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   1068                    pBuf += dataLen;
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   1069                  }
   \                     ??CrossCallReturnLabel_404:
   \   0000B9   E5..         MOV     A,?V0
   \   0000BB   28           ADD     A,R0
   \   0000BC   F5..         MOV     ?V0,A
   \   0000BE   E5..         MOV     A,?V1
   \   0000C0   39           ADDC    A,R1
   \   0000C1   F5..         MOV     ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000C3   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000C5   85..82       MOV     DPL,?V8
   \   0000C8   85..83       MOV     DPH,?V9
   \   0000CB   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_454:
   \   0000CE   505B         JNC     ??zcl_SendReadRsp_10
   \   0000D0   E5..         MOV     A,?V2
   \   0000D2   75F006       MOV     B,#0x6
   \   0000D5   A4           MUL     AB
   \   0000D6   F8           MOV     R0,A
   \   0000D7   A9F0         MOV     R1,B
   \   0000D9   E5..         MOV     A,?V8
   \   0000DB   28           ADD     A,R0
   \   0000DC   F582         MOV     DPL,A
   \   0000DE   E5..         MOV     A,?V9
   \   0000E0   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   0000E3   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000E6   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000E9   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   0000EC   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000EF   8882         MOV     DPL,R0
   \   0000F1   8983         MOV     DPH,R1
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   70CD         JNZ     ??zcl_SendReadRsp_9
   \   0000F6   EA           MOV     A,R2
   \   0000F7   2403         ADD     A,#0x3
   \   0000F9   08           INC     R0
   \   0000FA   E4           CLR     A
   \   0000FB   3B           ADDC    A,R3
   \   0000FC   F9           MOV     R1,A
   \   0000FD   8882         MOV     DPL,R0
   \   0000FF   8983         MOV     DPH,R1
   \   000101   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000104   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_499:
   \   000107   8C82         MOV     DPL,R4
   \   000109   8D83         MOV     DPH,R5
   \   00010B   E582         MOV     A,DPL
   \   00010D   4583         ORL     A,DPH
   \   00010F   7003         JNZ     $+5
   \   000111   02....       LJMP    ??zcl_SendReadRsp_8 & 0xFFFF
   \   000114                ; Setup parameters for call to function zclSerializeData
   \   000114   AC..         MOV     R4,?V0
   \   000116   AD..         MOV     R5,?V1
   \   000118   AA82         MOV     R2,DPL
   \   00011A   AB83         MOV     R3,DPH
   \   00011C   8882         MOV     DPL,R0
   \   00011E   8983         MOV     DPH,R1
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000125   8A..         MOV     ?V0,R2
   \   000127   8B..         MOV     ?V1,R3
   \   000129   8098         SJMP    ??zcl_SendReadRsp_9
   1070                }
   1071              } // for loop
   1072          
   1073              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1074                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   00012B                ; Setup parameters for call to function zcl_SendCommand
   \   00012B   78..         MOV     R0,#?V4
   \   00012D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000130   8E..         MOV     ?V0,R6
   \   000132   8F..         MOV     ?V1,R7
   \   000134   78..         MOV     R0,#?V0
   \   000136   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000139   7420         MOV     A,#0x20
   \   00013B   12....       LCALL   ?XSTACK_DISP0_8
   \   00013E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000141   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000144   E4           CLR     A
   \   000145   F5..         MOV     ?V0,A
   \   000147   F5..         MOV     ?V1,A
   \   000149   78..         MOV     R0,#?V0
   \   00014B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014E   7422         MOV     A,#0x22
   \   000150   12....       LCALL   ?XSTACK_DISP0_8
   \   000153   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000156   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000159   7422         MOV     A,#0x22
   \   00015B   12....       LCALL   ?XSTACK_DISP0_8
   \   00015E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000161   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000164   75..00       MOV     ?V0,#0x0
   \   000167   78..         MOV     R0,#?V0
   \   000169   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016C   75..01       MOV     ?V0,#0x1
   \   00016F   78..         MOV     R0,#?V0
   \   000171   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000174   AC..         MOV     R4,?V6
   \   000176   AD..         MOV     R5,?V7
   \   000178   AA..         MOV     R2,?V12
   \   00017A   AB..         MOV     R3,?V13
   \   00017C   A9..         MOV     R1,?V3
   \   00017E   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000181   740B         MOV     A,#0xb
   \   000183   12....       LCALL   ?DEALLOC_XSTACK8
   \   000186   E9           MOV     A,R1
   \   000187   FE           MOV     R6,A
   1075              zcl_mem_free( buf );
   \   000188                ; Setup parameters for call to function osal_mem_free
   \   000188   AA..         MOV     R2,?V4
   \   00018A   AB..         MOV     R3,?V5
   \   00018C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00018F   8002         SJMP    ??zcl_SendReadRsp_11
   1076            }
   1077            else
   1078            {
   1079              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   000191   7E10         MOV     R6,#0x10
   1080            }
   1081          
   1082            return ( status );
   \                     ??zcl_SendReadRsp_11:
   \   000193   EE           MOV     A,R6
   \   000194   F9           MOV     R1,A
   \   000195   7402         MOV     A,#0x2
   \   000197                REQUIRE ?Subroutine11
   \   000197                ; // Fall through to label ?Subroutine11
   1083          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine199_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_510:
   \   000003   AA..         MOV     R2,?V6
   \   000005   AB..         MOV     R3,?V7
   \   000007   A9..         MOV     R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   8582..       MOV     ?V0,DPL
   \   00000C   8583..       MOV     ?V1,DPH
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3B           ADDC    A,R3
   \   000006   F9           MOV     R1,A
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine205_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine207_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET
   1084          #endif // ZCL_READ
   1085          
   1086          #ifdef ZCL_WRITE
   1087          /*********************************************************************
   1088           * @fn      sendWriteRequest
   1089           *
   1090           * @brief   Send a Write command
   1091           *
   1092           * @param   dstAddr - destination address
   1093           * @param   clusterID - cluster ID
   1094           * @param   writeCmd - write command to be sent
   1095           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1096           * @param   direction - direction of the command
   1097           * @param   seqNum - transaction sequence number
   1098           *
   1099           * @return  ZSuccess if OK
   1100           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1101          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1102                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1103                                          uint8 disableDefaultRsp, uint8 seqNum )
   1104          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1105            uint8 *buf;
   1106            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1107            ZStatus_t status;
   1108            uint8 i;
   1109          
   1110            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   00001D   8009         SJMP    ??CrossCallReturnLabel_211
   1111            {
   1112              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   00001F   12....       LCALL   ?Subroutine78 & 0xFFFF
   1113          
   1114              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1115          
   1116              // Attribute Data
   1117              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1118            }
   \                     ??CrossCallReturnLabel_125:
   \   000022   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000025   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000028   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   00002B   40F2         JC      ??zcl_SendWriteRequest_0
   1119          
   1120            buf = zcl_mem_alloc( dataLen );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000034   8A..         MOV     ?V0,R2
   \   000036   8B..         MOV     ?V1,R3
   1121            if ( buf != NULL )
   \   000038   EA           MOV     A,R2
   \   000039   45..         ORL     A,?V1
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
   1122            {
   1123              // Load the buffer - serially
   1124              uint8 *pBuf = buf;
   \   000040   AC..         MOV     R4,?V0
   \   000042   AD..         MOV     R5,?V1
   1125              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   8010         SJMP    ??zcl_SendWriteRequest_2
   1126              {
   1127                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   000049   12....       LCALL   ?Subroutine13 & 0xFFFF
   1128          
   1129                *pBuf++ = LO_UINT16( statusRec->attrID );
   1130                *pBuf++ = HI_UINT16( statusRec->attrID );
   1131                *pBuf++ = statusRec->dataType;
   1132          
   1133                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1134              }
   \                     ??CrossCallReturnLabel_0:
   \   00004C   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   00004F   8A..         MOV     ?V10,R2
   \   000051   8B..         MOV     ?V11,R3
   \   000053   AC..         MOV     R4,?V10
   \   000055   AD..         MOV     R5,?V11
   \   000057   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000059   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   00005C   40EB         JC      ??zcl_SendWriteRequest_3
   1135          
   1136              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1137                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00005E                ; Setup parameters for call to function zcl_SendCommand
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   8E..         MOV     ?V4,R6
   \   000065   8F..         MOV     ?V5,R7
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   741D         MOV     A,#0x1d
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   E4           CLR     A
   \   000078   F5..         MOV     ?V4,A
   \   00007A   F5..         MOV     ?V5,A
   \   00007C   78..         MOV     R0,#?V4
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   741F         MOV     A,#0x1f
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   741F         MOV     A,#0x1f
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000097   75..00       MOV     ?V2,#0x0
   \   00009A   78..         MOV     R0,#?V2
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009F   7420         MOV     A,#0x20
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   AC..         MOV     R4,?V6
   \   0000AC   AD..         MOV     R5,?V7
   \   0000AE   AA..         MOV     R2,?V8
   \   0000B0   AB..         MOV     R3,?V9
   \   0000B2   A9..         MOV     R1,?V3
   \   0000B4   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B7   740B         MOV     A,#0xb
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FE           MOV     R6,A
   1138              zcl_mem_free( buf );
   \   0000BE                ; Setup parameters for call to function osal_mem_free
   \   0000BE   AA..         MOV     R2,?V0
   \   0000C0   AB..         MOV     R3,?V1
   \   0000C2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C5   8002         SJMP    ??zcl_SendWriteRequest_4
   1139            }
   1140            else
   1141            {
   1142              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000C7   7E10         MOV     R6,#0x10
   1143            }
   1144          
   1145            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000C9   02....       LJMP    ?Subroutine10 & 0xFFFF
   1146          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   F8           MOV     R0,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V1
   \   000009   F9           MOV     R1,A
   \   00000A   EE           MOV     A,R6
   \   00000B   28           ADD     A,R0
   \   00000C   FE           MOV     R6,A
   \   00000D   EF           MOV     A,R7
   \   00000E   39           ADDC    A,R1
   \   00000F   FF           MOV     R7,A
   \   000010   05..         INC     ?V2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   E5..         MOV     A,?V4
   \   00000B   28           ADD     A,R0
   \   00000C   F582         MOV     DPL,A
   \   00000E   E5..         MOV     A,?V5
   \   000010                REQUIRE ??Subroutine176_0
   \   000010                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000003   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   8882         MOV     DPL,R0
   \   00000C   8983         MOV     DPH,R1
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000012   E8           MOV     A,R0
   \   000013   2402         ADD     A,#0x2
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   39           ADDC    A,R1
   \   000018   FB           MOV     R3,A
   \   000019   8A..         MOV     ?V10,R2
   \   00001B   8B..         MOV     ?V11,R3
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000024                ; Setup parameters for call to function zclSerializeData
   \   000024                ; Setup parameters for call to function zclSerializeData
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00002E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V10
   \   000008   85..83       MOV     DPH,?V11
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine159:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003   0C           INC     R4
   \   000004   AD83         MOV     R5,DPH
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine203_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine205_0
   \   000006                ; // Fall through to label ??Subroutine205_0
   1147          
   1148          /*********************************************************************
   1149           * @fn      zcl_SendWriteRsp
   1150           *
   1151           * @brief   Send a Write Response command
   1152           *
   1153           * @param   dstAddr - destination address
   1154           * @param   clusterID - cluster ID
   1155           * @param   wrtieRspCmd - write response command to be sent
   1156           * @param   direction - direction of the command
   1157           * @param   seqNum - transaction sequence number
   1158           *
   1159           * @return  ZSuccess if OK
   1160           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1161          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1162                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1163                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1164          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine59 & 0xFFFF
   1165            uint16 dataLen;
   1166            uint8 *buf;
   1167            ZStatus_t status;
   1168          
   1169            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1170          
   1171            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_79:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1172            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1173            {
   1174              // Load the buffer - serially
   1175              uint8 i;
   1176              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1177              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_10
   1178              {
   1179                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_1:
   \   00002E   12....       LCALL   ?Subroutine36 & 0xFFFF
   1180                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1181                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1182              }
   \                     ??CrossCallReturnLabel_34:
   \   000031   5001         JNC     ??zcl_SendWriteRsp_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendWriteRsp_2:
   \   000034   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendWriteRsp_1
   1183          
   1184              // If there's only a single status record and its status field is set to
   1185              // SUCCESS then omit the attribute ID field.
   1186              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000044   7401         MOV     A,#0x1
   \   000046   6A           XRL     A,R2
   \   000047   700A         JNZ     ??zcl_SendWriteRsp_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   7006         JNZ     ??zcl_SendWriteRsp_3
   1187              {
   1188                dataLen = 1;
   \   00004D   75..01       MOV     ?V6,#0x1
   \   000050   75..00       MOV     ?V7,#0x0
   1189              }
   1190          
   1191              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1192                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   000053                ; Setup parameters for call to function zcl_SendCommand
   \   000053   78..         MOV     R0,#?V0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   78..         MOV     R0,#?V6
   \   00005A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005D   741C         MOV     A,#0x1c
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   E4           CLR     A
   \   000069   F5..         MOV     ?V4,A
   \   00006B   F5..         MOV     ?V5,A
   \   00006D   78..         MOV     R0,#?V4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741E         MOV     A,#0x1e
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   741E         MOV     A,#0x1e
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000088   75..00       MOV     ?V3,#0x0
   \   00008B   78..         MOV     R0,#?V3
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..04       MOV     ?V3,#0x4
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   EE           MOV     A,R6
   \   000099   FC           MOV     R4,A
   \   00009A   EF           MOV     A,R7
   \   00009B   FD           MOV     R5,A
   \   00009C   AA..         MOV     R2,?V8
   \   00009E   AB..         MOV     R3,?V9
   \   0000A0   A9..         MOV     R1,?V2
   \   0000A2   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000A5   740B         MOV     A,#0xb
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FE           MOV     R6,A
   1193              zcl_mem_free( buf );
   \   0000AC                ; Setup parameters for call to function osal_mem_free
   \   0000AC   AA..         MOV     R2,?V0
   \   0000AE   AB..         MOV     R3,?V1
   \   0000B0   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000B3   8002         SJMP    ??zcl_SendWriteRsp_4
   1194            }
   1195            else
   1196            {
   1197              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000B5   7E10         MOV     R6,#0x10
   1198            }
   1199          
   1200            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0000B7   02....       LJMP    ?Subroutine10 & 0xFFFF
   1201          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   75F003       MOV     B,#0x3
   \   000007   A4           MUL     AB
   \   000008   F5..         MOV     ?V6,A
   \   00000A   E5F0         MOV     A,B
   \   00000C   F5..         MOV     ?V7,A
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E   AA..         MOV     R2,?V6
   \   000010   FB           MOV     R3,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   EC           MOV     A,R4
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   FA           MOV     R2,A
   \   000006   ABF0         MOV     R3,B
   \   000008   E5..         MOV     A,?V4
   \   00000A   2A           ADD     A,R2
   \   00000B   FA           MOV     R2,A
   \   00000C   E5..         MOV     A,?V5
   \   00000E   3B           ADDC    A,R3
   \   00000F   FB           MOV     R3,A
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000018   EA           MOV     A,R2
   \   000019   2402         ADD     A,#0x2
   \   00001B   FA           MOV     R2,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000007   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   00000A   0C           INC     R4
   \   00000B   22           RET
   1202          #endif // ZCL_WRITE
   1203          
   1204          #ifdef ZCL_REPORT
   1205          /*********************************************************************
   1206           * @fn      zcl_SendConfigReportCmd
   1207           *
   1208           * @brief   Send a Configure Reporting command
   1209           *
   1210           * @param   dstAddr - destination address
   1211           * @param   clusterID - cluster ID
   1212           * @param   cfgReportCmd - configure reporting command to be sent
   1213           * @param   direction - direction of the command
   1214           * @param   seqNum - transaction sequence number
   1215           *
   1216           * @return  ZSuccess if OK
   1217           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1218          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1219                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1220                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1221          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1222            uint8 *buf;
   1223            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1224            ZStatus_t status;
   1225            uint8 i;
   1226          
   1227            // Find out the data length
   1228            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   00001D   8009         SJMP    ??zcl_SendConfigReportCmd_0
   1229            {
   1230              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1231          
   1232              dataLen += 1 + 2; // Direction + Attribute ID
   1233          
   1234              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1235              {
   1236                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1237          
   1238                // Find out the size of the Reportable Change field (for Analog data types)
   1239                if ( zclAnalogDataType( reportRec->dataType ) )
   1240                {
   1241                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1242                }
   1243              }
   1244              else
   1245              {
   1246                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1247              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   000028   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   00002B   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00C       MOV     B,#0xc
   \   000032   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   00003F   EE           MOV     A,R6
   \   000040   2405         ADD     A,#0x5
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E582         MOV     A,DPL
   \   000048   2403         ADD     A,#0x3
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   E4           CLR     A
   \   00004D   3583         ADDC    A,DPH
   \   00004F   F5..         MOV     ?V3,A
   \   000051                ; Setup parameters for call to function zclAnalogDataType
   \   000051   85..82       MOV     DPL,?V2
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005B   E9           MOV     A,R1
   \   00005C   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   00005E                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005E   85..82       MOV     DPL,?V2
   \   000061   85..83       MOV     DPH,?V3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000069   EE           MOV     A,R6
   \   00006A   29           ADD     A,R1
   \   00006B   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1248            }
   1249          
   1250            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   00006D                ; Setup parameters for call to function osal_mem_alloc
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000074   8A..         MOV     ?V2,R2
   \   000076   8B..         MOV     ?V3,R3
   1251            if ( buf != NULL )
   \   000078   EA           MOV     A,R2
   \   000079   45..         ORL     A,?V3
   \   00007B   7003         JNZ     $+5
   \   00007D   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1252            {
   1253              // Load the buffer - serially
   1254              uint8 *pBuf = buf;
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   1255          
   1256              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000084   75..00       MOV     ?V0,#0x0
   \   000087   8009         SJMP    ??zcl_SendConfigReportCmd_6
   1257              {
   1258                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1259          
   1260                *pBuf++ = reportRec->direction;
   1261                *pBuf++ = LO_UINT16( reportRec->attrID );
   1262                *pBuf++ = HI_UINT16( reportRec->attrID );
   1263          
   1264                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1265                {
   1266                  *pBuf++ = reportRec->dataType;
   1267                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1268                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1269                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1270                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1271          
   1272                  if ( zclAnalogDataType( reportRec->dataType ) )
   1273                  {
   1274                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1275                  }
   1276                }
   1277                else
   1278                {
   1279                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   000089   E5..         MOV     A,?V4
   \   00008B   2408         ADD     A,#0x8
   \   00008D   12....       LCALL   ?Subroutine23 & 0xFFFF
   1280                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1281                }
   \                     ??CrossCallReturnLabel_14:
   \   000090   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   000092   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000095   5054         JNC     ??zcl_SendConfigReportCmd_8
   \   000097   E5..         MOV     A,?V0
   \   000099   75F00C       MOV     B,#0xc
   \   00009C   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00009F   A882         MOV     R0,DPL
   \   0000A1   A983         MOV     R1,DPH
   \   0000A3   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000A6   A3           INC     DPTR
   \   0000A7   A882         MOV     R0,DPL
   \   0000A9   A983         MOV     R1,DPH
   \   0000AB   85..82       MOV     DPL,?V4
   \   0000AE   85..83       MOV     DPH,?V5
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   70D5         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000B4   E5..         MOV     A,?V4
   \   0000B6   2403         ADD     A,#0x3
   \   0000B8   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   0000BB   2404         ADD     A,#0x4
   \   0000BD   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000C0   2406         ADD     A,#0x6
   \   0000C2   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000C5   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000C8   E9           MOV     A,R1
   \   0000C9   60C5         JZ      ??CrossCallReturnLabel_14
   \   0000CB                ; Setup parameters for call to function zclSerializeData
   \   0000CB   AC..         MOV     R4,?V6
   \   0000CD   AD..         MOV     R5,?V7
   \   0000CF   85..82       MOV     DPL,?V4
   \   0000D2   85..83       MOV     DPH,?V5
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   12....       LCALL   ?Subroutine79 & 0xFFFF
   1282              } // for loop
   \                     ??CrossCallReturnLabel_127:
   \   0000E2   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000E5   8A..         MOV     ?V6,R2
   \   0000E7   8B..         MOV     ?V7,R3
   \   0000E9   80A5         SJMP    ??CrossCallReturnLabel_14
   1283          
   1284              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1285                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_8:
   \   0000EB                ; Setup parameters for call to function zcl_SendCommand
   \   0000EB   78..         MOV     R0,#?V2
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   8E..         MOV     ?V4,R6
   \   0000F2   8F..         MOV     ?V5,R7
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   7420         MOV     A,#0x20
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000104   E4           CLR     A
   \   000105   F5..         MOV     ?V4,A
   \   000107   F5..         MOV     ?V5,A
   \   000109   78..         MOV     R0,#?V4
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   7422         MOV     A,#0x22
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000119   7422         MOV     A,#0x22
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000121   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000124   75..00       MOV     ?V0,#0x0
   \   000127   78..         MOV     R0,#?V0
   \   000129   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012C   75..06       MOV     ?V0,#0x6
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000134   AC..         MOV     R4,?V12
   \   000136   AD..         MOV     R5,?V13
   \   000138   AA..         MOV     R2,?V14
   \   00013A   AB..         MOV     R3,?V15
   \   00013C   A9..         MOV     R1,?V1
   \   00013E   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000141   740B         MOV     A,#0xb
   \   000143   12....       LCALL   ?DEALLOC_XSTACK8
   \   000146   E9           MOV     A,R1
   \   000147   FE           MOV     R6,A
   1286              zcl_mem_free( buf );
   \   000148                ; Setup parameters for call to function osal_mem_free
   \   000148   AA..         MOV     R2,?V2
   \   00014A   AB..         MOV     R3,?V3
   \   00014C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00014F   8002         SJMP    ??zcl_SendConfigReportCmd_9
   1287            }
   1288            else
   1289            {
   1290              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   000151   7E10         MOV     R6,#0x10
   1291            }
   1292          
   1293            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   000153                REQUIRE ?Subroutine12
   \   000153                ; // Fall through to label ?Subroutine12
   1294          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine210_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine169_0
   \   000006                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000003                REQUIRE ??Subroutine173_0
   \   000003                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   F5..         MOV     ?V10,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V5
   \   000005   F5..         MOV     ?V11,A
   \   000007   85..82       MOV     DPL,?V10
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00000F   88..         MOV     ?V6,R0
   \   000011   89..         MOV     ?V7,R1
   \   000013   E5..         MOV     A,?V4
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   00000C   85..82       MOV     DPL,?V4
   \   00000F   85..83       MOV     DPH,?V5
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   FA           MOV     R2,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   FB           MOV     R3,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   000014   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine164:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   E5..         MOV     A,?V4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine174_0
   \   000009                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine157:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000003                REQUIRE ??Subroutine175_0
   \   000003                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   8582..       MOV     ?V6,DPL
   \   000005   8583..       MOV     ?V7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003   85..82       MOV     DPL,?V10
   \   000006   85..83       MOV     DPH,?V11
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B                REQUIRE ??Subroutine201_0
   \   00000B                ; // Fall through to label ??Subroutine201_0
   1295          
   1296          /*********************************************************************
   1297           * @fn      zcl_SendConfigReportRspCmd
   1298           *
   1299           * @brief   Send a Configure Reporting Response command
   1300           *
   1301           * @param   dstAddr - destination address
   1302           * @param   clusterID - cluster ID
   1303           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1304           * @param   direction - direction of the command
   1305           * @param   seqNum - transaction sequence number
   1306           *
   1307           * @return  ZSuccess if OK
   1308           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1309          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1310                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1311                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1312          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine82 & 0xFFFF
   1313            uint16 dataLen;
   1314            uint8 *buf;
   1315            ZStatus_t status;
   1316          
   1317            // Atrribute list (Status, Direction and Attribute ID)
   1318            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_132:
   \   000017   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   85....       MOV     ?V6,?V0
   \   000020   85....       MOV     ?V7,?V1
   1319          
   1320            buf = zcl_mem_alloc( dataLen );
   \   000023                ; Setup parameters for call to function osal_mem_alloc
   \   000023   AA..         MOV     R2,?V6
   \   000025   AB..         MOV     R3,?V7
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   1321            if ( buf != NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1322            {
   1323              // Load the buffer - serially
   1324              uint8 *pBuf = buf;
   1325              uint8 i;
   1326          
   1327              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000036   7C00         MOV     R4,#0x0
   \   000038   8041         SJMP    ??zcl_SendConfigReportRspCmd_1
   1328              {
   1329                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   00003A   8C..         MOV     ?V10,R4
   \   00003C   75..00       MOV     ?V11,#0x0
   \   00003F   7402         MOV     A,#0x2
   \   000041   78..         MOV     R0,#?V10
   \   000043   12....       LCALL   ?S_SHL
   \   000046   E5..         MOV     A,?V4
   \   000048   25..         ADD     A,?V10
   \   00004A   F8           MOV     R0,A
   \   00004B   E5..         MOV     A,?V5
   \   00004D   35..         ADDC    A,?V11
   \   00004F   F9           MOV     R1,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000058   A3           INC     DPTR
   \   000059   AA82         MOV     R2,DPL
   \   00005B   AB83         MOV     R3,DPH
   1330                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   00005D   8882         MOV     DPL,R0
   \   00005F   8983         MOV     DPH,R1
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine30 & 0xFFFF
   1331                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_289:
   \   000065   E8           MOV     A,R0
   \   000066   2403         ADD     A,#0x3
   \   000068   F8           MOV     R0,A
   \   000069   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   00006B   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00006C   8882         MOV     DPL,R0
   \   00006E   8983         MOV     DPH,R1
   \   000070   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   1332                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_288:
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   12....       LCALL   ?Subroutine30 & 0xFFFF
   1333              }
   \                     ??CrossCallReturnLabel_290:
   \   00007A   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007B   85..82       MOV     DPL,?V4
   \   00007E   85..83       MOV     DPH,?V5
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F8           MOV     R0,A
   \   000083   EC           MOV     A,R4
   \   000084   C3           CLR     C
   \   000085   98           SUBB    A,R0
   \   000086   40B2         JC      ??zcl_SendConfigReportRspCmd_2
   1334          
   1335              // If there's only a single status record and its status field is set to
   1336              // SUCCESS then omit the attribute ID field.
   1337              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000088   7401         MOV     A,#0x1
   \   00008A   68           XRL     A,R0
   \   00008B   700A         JNZ     ??zcl_SendConfigReportRspCmd_4
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   7006         JNZ     ??zcl_SendConfigReportRspCmd_4
   1338              {
   1339                dataLen = 1;
   \   000091   75..01       MOV     ?V6,#0x1
   \   000094   75..00       MOV     ?V7,#0x0
   1340              }
   1341          
   1342              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1343                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1344                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   78..         MOV     R0,#?V6
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   741C         MOV     A,#0x1c
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AC   E4           CLR     A
   \   0000AD   F5..         MOV     ?V4,A
   \   0000AF   F5..         MOV     ?V5,A
   \   0000B1   78..         MOV     R0,#?V4
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   741E         MOV     A,#0x1e
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   741E         MOV     A,#0x1e
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CC   75..00       MOV     ?V3,#0x0
   \   0000CF   78..         MOV     R0,#?V3
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   75..07       MOV     ?V3,#0x7
   \   0000D7   78..         MOV     R0,#?V3
   \   0000D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DC   EE           MOV     A,R6
   \   0000DD   FC           MOV     R4,A
   \   0000DE   EF           MOV     A,R7
   \   0000DF   FD           MOV     R5,A
   \   0000E0   AA..         MOV     R2,?V8
   \   0000E2   AB..         MOV     R3,?V9
   \   0000E4   A9..         MOV     R1,?V2
   \   0000E6   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000E9   740B         MOV     A,#0xb
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EE   E9           MOV     A,R1
   \   0000EF   FE           MOV     R6,A
   1345              zcl_mem_free( buf );
   \   0000F0                ; Setup parameters for call to function osal_mem_free
   \   0000F0   AA..         MOV     R2,?V0
   \   0000F2   AB..         MOV     R3,?V1
   \   0000F4   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000F7   8002         SJMP    ??zcl_SendConfigReportRspCmd_5
   1346            }
   1347            else
   1348            {
   1349              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F9   7E10         MOV     R6,#0x10
   1350            }
   1351          
   1352            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   0000FB                REQUIRE ?Subroutine10
   \   0000FB                ; // Fall through to label ?Subroutine10
   1353          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine170_0
   \   000001                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine171_0
   \   000001                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine172_0
   \   000004                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   0A           INC     R2
   \   000003   AB83         MOV     R3,DPH
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   75..00       MOV     ?V1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET
   1354          
   1355          /*********************************************************************
   1356           * @fn      zcl_SendReadReportCfgCmd
   1357           *
   1358           * @brief   Send a Read Reporting Configuration command
   1359           *
   1360           * @param   dstAddr - destination address
   1361           * @param   clusterID - cluster ID
   1362           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1363           * @param   direction - direction of the command
   1364           * @param   seqNum - transaction sequence number
   1365           *
   1366           * @return  ZSuccess if OK
   1367           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1368          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1369                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1370                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1371          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine59 & 0xFFFF
   1372            uint16 dataLen;
   1373            uint8 *buf;
   1374            ZStatus_t status;
   1375          
   1376            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1377          
   1378            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_80:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1379            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
   1380            {
   1381              // Load the buffer - serially
   1382              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1383              uint8 i;
   1384          
   1385              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_11
   1386              {
   1387                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   00002E   12....       LCALL   ?Subroutine36 & 0xFFFF
   1388                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1389                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1390              }
   \                     ??CrossCallReturnLabel_35:
   \   000031   5001         JNC     ??zcl_SendReadReportCfgCmd_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000034   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendReadReportCfgCmd_1
   1391          
   1392              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1393                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000044                ; Setup parameters for call to function zcl_SendCommand
   \   000044   78..         MOV     R0,#?V0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   78..         MOV     R0,#?V6
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741C         MOV     A,#0x1c
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   E4           CLR     A
   \   00005A   F5..         MOV     ?V4,A
   \   00005C   F5..         MOV     ?V5,A
   \   00005E   78..         MOV     R0,#?V4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   741E         MOV     A,#0x1e
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   741E         MOV     A,#0x1e
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000079   75..00       MOV     ?V3,#0x0
   \   00007C   78..         MOV     R0,#?V3
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000081   75..08       MOV     ?V3,#0x8
   \   000084   78..         MOV     R0,#?V3
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000089   EE           MOV     A,R6
   \   00008A   FC           MOV     R4,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FD           MOV     R5,A
   \   00008D   AA..         MOV     R2,?V8
   \   00008F   AB..         MOV     R3,?V9
   \   000091   A9..         MOV     R1,?V2
   \   000093   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000096   740B         MOV     A,#0xb
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009B   E9           MOV     A,R1
   \   00009C   FE           MOV     R6,A
   1394              zcl_mem_free( buf );
   \   00009D                ; Setup parameters for call to function osal_mem_free
   \   00009D   AA..         MOV     R2,?V0
   \   00009F   AB..         MOV     R3,?V1
   \   0000A1   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000A4   8002         SJMP    ??zcl_SendReadReportCfgCmd_3
   1395            }
   1396            else
   1397            {
   1398              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   0000A6   7E10         MOV     R6,#0x10
   1399            }
   1400          
   1401            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   0000A8   02....       LJMP    ?Subroutine10 & 0xFFFF
   1402          }
   1403          
   1404          /*********************************************************************
   1405           * @fn      zcl_SendReadReportCfgRspCmd
   1406           *
   1407           * @brief   Send a Read Reporting Configuration Response command
   1408           *
   1409           * @param   dstAddr - destination address
   1410           * @param   clusterID - cluster ID
   1411           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1412           * @param   direction - direction of the command
   1413           * @param   seqNum - transaction sequence number
   1414           *
   1415           * @return  ZSuccess if OK
   1416           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1417          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1418                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1419                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1420          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1421            uint8 *buf;
   1422            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1423            ZStatus_t status;
   1424            uint8 i;
   1425          
   1426            // Find out the data length
   1427            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   00001D   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1428            {
   1429              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1430          
   1431              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1432          
   1433              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1434              {
   1435                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1436                {
   1437                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1438          
   1439                  // Find out the size of the Reportable Change field (for Analog data types)
   1440                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1441                  {
   1442                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1443                  }
   1444                }
   1445                else
   1446                {
   1447                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1448                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   000028   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   00002B   5041         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00D       MOV     B,#0xd
   \   000032   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000035   2404         ADD     A,#0x4
   \   000037   FE           MOV     R6,A
   \   000038   E4           CLR     A
   \   000039   3F           ADDC    A,R7
   \   00003A   FF           MOV     R7,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   70E8         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   000042   EE           MOV     A,R6
   \   000043   2405         ADD     A,#0x5
   \   000045   FE           MOV     R6,A
   \   000046   E4           CLR     A
   \   000047   3F           ADDC    A,R7
   \   000048   FF           MOV     R7,A
   \   000049   E8           MOV     A,R0
   \   00004A   2404         ADD     A,#0x4
   \   00004C   F5..         MOV     ?V2,A
   \   00004E   E4           CLR     A
   \   00004F   39           ADDC    A,R1
   \   000050   F5..         MOV     ?V3,A
   \   000052                ; Setup parameters for call to function zclAnalogDataType
   \   000052   85..82       MOV     DPL,?V2
   \   000055   F583         MOV     DPH,A
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005C   E9           MOV     A,R1
   \   00005D   60C7         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   00005F                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005F   85..82       MOV     DPL,?V2
   \   000062   85..83       MOV     DPH,?V3
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F9           MOV     R1,A
   \   000067   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006A   EE           MOV     A,R6
   \   00006B   29           ADD     A,R1
   \   00006C   80B4         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1449              }
   1450            }
   1451          
   1452            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V2,R2
   \   000077   8B..         MOV     ?V3,R3
   1453            if ( buf != NULL )
   \   000079   EA           MOV     A,R2
   \   00007A   45..         ORL     A,?V3
   \   00007C   7003         JNZ     $+5
   \   00007E   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1454            {
   1455              // Load the buffer - serially
   1456              uint8 *pBuf = buf;
   \   000081   8A..         MOV     ?V6,R2
   \   000083   8B..         MOV     ?V7,R3
   1457          
   1458              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000085   75..00       MOV     ?V0,#0x0
   \   000088   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1459              {
   1460                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1461          
   1462                *pBuf++ = reportRspRec->status;
   1463                *pBuf++ = reportRspRec->direction;
   1464                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1465                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1466          
   1467                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1468                {
   1469                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1470                  {
   1471                    *pBuf++ = reportRspRec->dataType;
   1472                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1473                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1474                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1475                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1476          
   1477                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1478                    {
   1479                      pBuf = zclSerializeData( reportRspRec->dataType,
   1480                                               reportRspRec->reportableChange, pBuf );
   1481                    }
   1482                  }
   1483                  else
   1484                  {
   1485                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   00008A   E5..         MOV     A,?V4
   \   00008C   2409         ADD     A,#0x9
   \   00008E   12....       LCALL   ?Subroutine23 & 0xFFFF
   1486                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1487                  }
   \                     ??CrossCallReturnLabel_15:
   \   000091   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   000093   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000096   506C         JNC     ??zcl_SendReadReportCfgRspCmd_8
   \   000098   E5..         MOV     A,?V0
   \   00009A   75F00D       MOV     B,#0xd
   \   00009D   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   0000A7   E5..         MOV     A,?V4
   \   0000A9   2402         ADD     A,#0x2
   \   0000AB   F8           MOV     R0,A
   \   0000AC   E4           CLR     A
   \   0000AD   35..         ADDC    A,?V5
   \   0000AF   F9           MOV     R1,A
   \   0000B0   8882         MOV     DPL,R0
   \   0000B2   8983         MOV     DPH,R1
   \   0000B4   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000B7   85..82       MOV     DPL,?V4
   \   0000BA   85..83       MOV     DPH,?V5
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   70D1         JNZ     ??CrossCallReturnLabel_15
   \   0000C0   85..82       MOV     DPL,?V6
   \   0000C3   85..83       MOV     DPH,?V7
   \   0000C6   A3           INC     DPTR
   \   0000C7   A882         MOV     R0,DPL
   \   0000C9   A983         MOV     R1,DPH
   \   0000CB   8A82         MOV     DPL,R2
   \   0000CD   8B83         MOV     DPH,R3
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   70B8         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000D2   E5..         MOV     A,?V4
   \   0000D4   2404         ADD     A,#0x4
   \   0000D6   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000D9   2405         ADD     A,#0x5
   \   0000DB   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000DE   2407         ADD     A,#0x7
   \   0000E0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000E3   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000E6   E9           MOV     A,R1
   \   0000E7   60A8         JZ      ??CrossCallReturnLabel_15
   \   0000E9                ; Setup parameters for call to function zclSerializeData
   \   0000E9   AC..         MOV     R4,?V6
   \   0000EB   AD..         MOV     R5,?V7
   \   0000ED   E5..         MOV     A,?V4
   \   0000EF   240B         ADD     A,#0xb
   \   0000F1   F582         MOV     DPL,A
   \   0000F3   E4           CLR     A
   \   0000F4   35..         ADDC    A,?V5
   \   0000F6   F583         MOV     DPH,A
   \   0000F8   12....       LCALL   ?Subroutine79 & 0xFFFF
   1488                }
   1489              }
   \                     ??CrossCallReturnLabel_128:
   \   0000FB   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000FE   8A..         MOV     ?V6,R2
   \   000100   8B..         MOV     ?V7,R3
   \   000102   808D         SJMP    ??CrossCallReturnLabel_15
   1490          
   1491              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1492                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1493                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   000104                ; Setup parameters for call to function zcl_SendCommand
   \   000104   78..         MOV     R0,#?V2
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   8E..         MOV     ?V4,R6
   \   00010B   8F..         MOV     ?V5,R7
   \   00010D   78..         MOV     R0,#?V4
   \   00010F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000112   7420         MOV     A,#0x20
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00011D   E4           CLR     A
   \   00011E   F5..         MOV     ?V4,A
   \   000120   F5..         MOV     ?V5,A
   \   000122   78..         MOV     R0,#?V4
   \   000124   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000127   7422         MOV     A,#0x22
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000132   7422         MOV     A,#0x22
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00013D   75..00       MOV     ?V0,#0x0
   \   000140   78..         MOV     R0,#?V0
   \   000142   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000145   75..09       MOV     ?V0,#0x9
   \   000148   78..         MOV     R0,#?V0
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014D   AC..         MOV     R4,?V12
   \   00014F   AD..         MOV     R5,?V13
   \   000151   AA..         MOV     R2,?V14
   \   000153   AB..         MOV     R3,?V15
   \   000155   A9..         MOV     R1,?V1
   \   000157   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00015A   740B         MOV     A,#0xb
   \   00015C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00015F   E9           MOV     A,R1
   \   000160   FE           MOV     R6,A
   1494              zcl_mem_free( buf );
   \   000161                ; Setup parameters for call to function osal_mem_free
   \   000161   AA..         MOV     R2,?V2
   \   000163   AB..         MOV     R3,?V3
   \   000165   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000168   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_9
   1495            }
   1496            else
   1497            {
   1498              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   00016A   7E10         MOV     R6,#0x10
   1499            }
   1500          
   1501            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   00016C   02....       LJMP    ?Subroutine12 & 0xFFFF
   1502          }
   1503          
   1504          /*********************************************************************
   1505           * @fn      zcl_SendReportCmd
   1506           *
   1507           * @brief   Send a Report command
   1508           *
   1509           * @param   dstAddr - destination address
   1510           * @param   clusterID - cluster ID
   1511           * @param   reportCmd - report command to be sent
   1512           * @param   direction - direction of the command
   1513           * @param   seqNum - transaction sequence number
   1514           *
   1515           * @return  ZSuccess if OK
   1516           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1517          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1518                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1519                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1520          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1521            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1522            uint8 *buf;
   1523            ZStatus_t status;
   1524            uint8 i;
   1525          
   1526            // calculate the size of the command
   1527            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   00001D   8009         SJMP    ??CrossCallReturnLabel_212
   1528            {
   1529              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   00001F   12....       LCALL   ?Subroutine78 & 0xFFFF
   1530          
   1531              dataLen += 2 + 1; // Attribute ID + data type
   1532          
   1533              // Attribute Data
   1534              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1535            }
   \                     ??CrossCallReturnLabel_126:
   \   000022   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000025   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000028   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   00002B   40F2         JC      ??zcl_SendReportCmd_0
   1536          
   1537            buf = zcl_mem_alloc( dataLen );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000034   8A..         MOV     ?V0,R2
   \   000036   8B..         MOV     ?V1,R3
   1538            if ( buf != NULL )
   \   000038   EA           MOV     A,R2
   \   000039   45..         ORL     A,?V1
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1539            {
   1540              // Load the buffer - serially
   1541              uint8 *pBuf = buf;
   \   000040   AC..         MOV     R4,?V0
   \   000042   AD..         MOV     R5,?V1
   1542          
   1543              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   8010         SJMP    ??zcl_SendReportCmd_2
   1544              {
   1545                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   000049   12....       LCALL   ?Subroutine13 & 0xFFFF
   1546          
   1547                *pBuf++ = LO_UINT16( reportRec->attrID );
   1548                *pBuf++ = HI_UINT16( reportRec->attrID );
   1549                *pBuf++ = reportRec->dataType;
   1550          
   1551                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1552              }
   \                     ??CrossCallReturnLabel_1:
   \   00004C   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   00004F   8A..         MOV     ?V10,R2
   \   000051   8B..         MOV     ?V11,R3
   \   000053   AC..         MOV     R4,?V10
   \   000055   AD..         MOV     R5,?V11
   \   000057   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000059   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   00005C   40EB         JC      ??zcl_SendReportCmd_3
   1553          
   1554              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1555                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00005E                ; Setup parameters for call to function zcl_SendCommand
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   8E..         MOV     ?V4,R6
   \   000065   8F..         MOV     ?V5,R7
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   741C         MOV     A,#0x1c
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   E4           CLR     A
   \   000078   F5..         MOV     ?V4,A
   \   00007A   F5..         MOV     ?V5,A
   \   00007C   78..         MOV     R0,#?V4
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   741E         MOV     A,#0x1e
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   741E         MOV     A,#0x1e
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000097   75..00       MOV     ?V2,#0x0
   \   00009A   78..         MOV     R0,#?V2
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009F   75..0A       MOV     ?V2,#0xa
   \   0000A2   78..         MOV     R0,#?V2
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   AC..         MOV     R4,?V6
   \   0000A9   AD..         MOV     R5,?V7
   \   0000AB   AA..         MOV     R2,?V8
   \   0000AD   AB..         MOV     R3,?V9
   \   0000AF   A9..         MOV     R1,?V3
   \   0000B1   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B4   740B         MOV     A,#0xb
   \   0000B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B9   E9           MOV     A,R1
   \   0000BA   FE           MOV     R6,A
   1556              zcl_mem_free( buf );
   \   0000BB                ; Setup parameters for call to function osal_mem_free
   \   0000BB   AA..         MOV     R2,?V0
   \   0000BD   AB..         MOV     R3,?V1
   \   0000BF   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C2   8002         SJMP    ??zcl_SendReportCmd_4
   1557            }
   1558            else
   1559            {
   1560              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000C4   7E10         MOV     R6,#0x10
   1561            }
   1562          
   1563            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000C6   02....       LJMP    ?Subroutine10 & 0xFFFF
   1564          }
   1565          #endif // ZCL_REPORT
   1566          
   1567          /*********************************************************************
   1568           * @fn      zcl_SendDefaultRspCmd
   1569           *
   1570           * @brief   Send a Default Response command
   1571           *
   1572           *          Note: The manufacturer code field should be set if this
   1573           *          command is being sent in response to a manufacturer specific
   1574           *          command.
   1575           *
   1576           * @param   dstAddr - destination address
   1577           * @param   clusterID - cluster ID
   1578           * @param   defaultRspCmd - default response command to be sent
   1579           * @param   direction - direction of the command
   1580           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1581           * @param   seqNum - transaction sequence number
   1582           *
   1583           * @return  ZSuccess if OK
   1584           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1585          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1586                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1587                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1588          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine97 & 0xFFFF
   1589            uint8 buf[2]; // Command ID and Status;
   1590          
   1591            // Load the buffer - serially
   1592            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_160:
   \   000014   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000017   12....       LCALL   ?Subroutine42 & 0xFFFF
   1593            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_47:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1594          
   1595            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1596                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D   78..         MOV     R0,#?V0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V0,#0x2
   \   000035   75..00       MOV     ?V1,#0x0
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV     A,#0x15
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV     A,#0x16
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV     A,#0x16
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV     ?V0,#0x0
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV     ?V0,#0xb
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV     A,R6
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   02....       LJMP    ?Subroutine2 & 0xFFFF
   1597          }
   1598          
   1599          #ifdef ZCL_DISCOVER
   1600          /*********************************************************************
   1601           * @fn      zcl_SendDiscoverCmdsCmd
   1602           *
   1603           * @brief   Send a Discover Commands command
   1604           *
   1605           * @param   dstAddr - destination address
   1606           * @param   clusterID - cluster ID
   1607           * @param   cmdType - requesting command ID
   1608           * @param   pDiscoverCmd - discover command to be sent
   1609           * @param   direction - direction of the command
   1610           * @param   seqNum - transaction sequence number
   1611           *
   1612           * @return  ZSuccess if OK
   1613           */
   1614          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1615                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1616                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1617          {
   1618            uint8 payload[2]; // size of startCmdID and maxCmdID
   1619            ZStatus_t status;
   1620          
   1621            payload[0] = pDiscoverCmd->startCmdID;
   1622            payload[1] = pDiscoverCmd->maxCmdID;
   1623          
   1624            // Send message for either commands received or generated
   1625            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1626            {
   1627              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1628                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1629            }
   1630            else  // generated
   1631            {
   1632              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1633                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1634            }
   1635          
   1636            return ( status );
   1637          }
   1638          
   1639          /*********************************************************************
   1640           * @fn      zcl_SendDiscoverCmdsRspCmd
   1641           *
   1642           * @brief   Send a Discover Commands Response command
   1643           *
   1644           * @param   dstAddr - destination address
   1645           * @param   clusterID - cluster ID
   1646           * @param   pDiscoverRspCmd - response command to be sent
   1647           * @param   direction - direction of the command
   1648           * @param   seqNum - transaction sequence number
   1649           *
   1650           * @return  ZSuccess if OK
   1651           */
   1652          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1653                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1654                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1655          {
   1656            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1657            uint8 *pCmdBuf;
   1658            uint8 i;
   1659            ZStatus_t status = ZSuccess;
   1660          
   1661            // allocate memory
   1662            pCmdBuf = zcl_mem_alloc( payloadSize );
   1663            if ( pCmdBuf != NULL )
   1664            {
   1665              uint8 *pBuf = pCmdBuf;
   1666          
   1667              // Load the buffer - serially
   1668              *pBuf++ = pDiscoverRspCmd->discComplete;
   1669              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1670              {
   1671                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1672              }
   1673          
   1674              // Send response message for either commands received or generated
   1675              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1676              {
   1677                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1678                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1679              }
   1680              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1681              {
   1682                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1683                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1684              }
   1685          
   1686              zcl_mem_free( pCmdBuf );
   1687            }
   1688            else
   1689            {
   1690              status = ZMemError;
   1691            }
   1692          
   1693            return ( status );
   1694          }
   1695          
   1696          /*********************************************************************
   1697           * @fn      zcl_SendDiscoverAttrsCmd
   1698           *
   1699           * @brief   Send a Discover Attributes command
   1700           *
   1701           * @param   dstAddr - destination address
   1702           * @param   clusterID - cluster ID
   1703           * @param   pDiscoverCmd - discover command to be sent
   1704           * @param   direction - direction of the command
   1705           * @param   seqNum - transaction sequence number
   1706           *
   1707           * @return  ZSuccess if OK
   1708           */
   1709          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1710                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1711                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1712          {
   1713            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1714            uint8 *buf;
   1715            ZStatus_t status;
   1716          
   1717            buf = zcl_mem_alloc( dataLen );
   1718            if ( buf != NULL )
   1719            {
   1720              // Load the buffer - serially
   1721              uint8 *pBuf = buf;
   1722              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1723              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1724              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1725          
   1726              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1727                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1728              zcl_mem_free( buf );
   1729            }
   1730            else
   1731            {
   1732              status = ZMemError;
   1733            }
   1734          
   1735            return ( status );
   1736          }
   1737          
   1738          /*********************************************************************
   1739           * @fn      zcl_SendDiscoverAttrsRspCmd
   1740           *
   1741           * @brief   Send a Discover Attributes Response command
   1742           *
   1743           * @param   dstAddr - destination address
   1744           * @param   clusterID - cluster ID
   1745           * @param   reportRspCmd - report response command to be sent
   1746           * @param   direction - direction of the command
   1747           * @param   seqNum - transaction sequence number
   1748           *
   1749           * @return  ZSuccess if OK
   1750           */
   1751          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1752                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1753                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1754          {
   1755            uint16 dataLen = 1; // Discovery complete
   1756            uint8 *buf;
   1757            ZStatus_t status;
   1758          
   1759            // calculate the size of the command
   1760            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1761          
   1762            buf = zcl_mem_alloc( dataLen );
   1763            if ( buf != NULL )
   1764            {
   1765              // Load the buffer - serially
   1766              uint8 i;
   1767              uint8 *pBuf = buf;
   1768          
   1769              *pBuf++ = pDiscoverRspCmd->discComplete;
   1770          
   1771              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1772              {
   1773                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1774                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1775                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1776              }
   1777          
   1778              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1779                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1780              zcl_mem_free( buf );
   1781            }
   1782            else
   1783            {
   1784              status = ZMemError;
   1785            }
   1786          
   1787            return ( status );
   1788          }
   1789          
   1790          /*********************************************************************
   1791           * @fn      zcl_SendDiscoverAttrsExt
   1792           *
   1793           * @brief   Send a Discover Attributes Extended command
   1794           *
   1795           * @param   dstAddr - destination address
   1796           * @param   clusterID - cluster ID
   1797           * @param   pDiscoverAttrsExt:
   1798           *            - startAttrID: the first attribute to be selected
   1799           *            - maxAttrIDs: maximum number of returned attributes
   1800           * @param   direction - direction of the command
   1801           * @param   seqNum - transaction sequence number
   1802           *
   1803           * @return  ZSuccess if OK
   1804           */
   1805          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1806                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1807                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1808          {
   1809            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1810            ZStatus_t status;
   1811          
   1812            // Load the buffer - serially
   1813            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1814            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1815            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1816          
   1817            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1818                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1819          
   1820            return ( status );
   1821          }
   1822          
   1823          /*********************************************************************
   1824           * @fn      zcl_SendDiscoverAttrsExtRsp
   1825           *
   1826           * @brief   Send a Discover Attributes Extended Response command
   1827           *
   1828           * @param   dstAddr - destination address
   1829           * @param   clusterID - cluster ID
   1830           * @param   pDiscoverRspCmd:
   1831           *            - discComplete: indicates whether all requested attributes returned
   1832           *            - attrID: attribute ID
   1833           *            - attrDataType: data type of the given attribute
   1834           *            - attrAccessControl: access control of the given attribute
   1835           * @param   direction - direction of the command
   1836           * @param   seqNum - transaction sequence number
   1837           *
   1838           * @return  ZSuccess if OK
   1839           */
   1840          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1841                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1842                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1843          {
   1844            uint8 *buf;
   1845            uint8 i;
   1846            uint16 dataLen = 1; // Discovery complete
   1847            ZStatus_t status;
   1848          
   1849            // calculate the size of the command
   1850            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1851          
   1852            buf = zcl_mem_alloc( dataLen );
   1853            if ( buf != NULL )
   1854            {
   1855              // Load the buffer - serially
   1856              uint8 *pBuf = buf;
   1857              *pBuf++ = pDiscoverRspCmd->discComplete;
   1858              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1859              {
   1860                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1861                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1862                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1863                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1864              }
   1865          
   1866              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1867                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1868              zcl_mem_free( buf );
   1869            }
   1870            else
   1871            {
   1872              status = ZMemError;
   1873            }
   1874          
   1875            return ( status );
   1876          }
   1877          #endif // ZCL_DISCOVER
   1878          
   1879          /*********************************************************************
   1880           * @fn      zcl_ProcessMessageMSG
   1881           *
   1882           * @brief   Data message processor callback.  This function processes
   1883           *          any incoming data - probably from other devices.  So, based
   1884           *          on cluster ID, perform the intended action.
   1885           *
   1886           * @param   pkt - incoming message
   1887           *
   1888           * @return  zclProcMsgStatus_t
   1889           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1890          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1891          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1892            endPointDesc_t *epDesc;
   1893            zclIncoming_t inMsg;
   1894            zclLibPlugin_t *pInPlugin;
   1895            zclDefaultRspCmd_t defautlRspCmd;
   1896            uint8 options;
   1897            uint8 securityEnable;
   1898            uint8 interPanMsg;
   1899            ZStatus_t status = ZFailure;
   1900            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   1901          
   1902            if ( pkt->cmd.DataLength == 0 )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000017   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   00001A   7005         JNZ     ??zcl_ProcessMessageMSG_0
   1903            {
   1904              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1905            }
   1906          
   1907            // Initialize
   1908            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000021   90....       MOV     DPTR,#rawAFMsg
   \   000024   EE           MOV     A,R6
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EF           MOV     A,R7
   \   000028   F0           MOVX    @DPTR,A
   1909            inMsg.msg = pkt;
   \   000029   7402         MOV     A,#0x2
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   EE           MOV     A,R6
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   EF           MOV     A,R7
   \   000032   F0           MOVX    @DPTR,A
   1910            inMsg.attrCmd = NULL;
   \   000033   740E         MOV     A,#0xe
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   1911            inMsg.pData = NULL;
   \   00003C   740A         MOV     A,#0xa
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E4           CLR     A
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   F0           MOVX    @DPTR,A
   1912            inMsg.pDataLen = 0;
   \   000045   740C         MOV     A,#0xc
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   1913          
   1914            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00004E   EE           MOV     A,R6
   \   00004F   2422         ADD     A,#0x22
   \   000051   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000054   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   12....       LCALL   ??zclParseHdr?relay  ; Banked call to: zclParseHdr
   \   000063   8A..         MOV     ?V6,R2
   \   000065   8B..         MOV     ?V7,R3
   \   000067   A8..         MOV     R0,?V6
   \   000069   A9..         MOV     R1,?V7
   \   00006B   740A         MOV     A,#0xa
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   1915            inMsg.pDataLen = pkt->cmd.DataLength;
   1916            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_463:
   \   000073   85..82       MOV     DPL,?V4
   \   000076   85..83       MOV     DPH,?V5
   \   000079   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   00007C   EA           MOV     A,R2
   \   00007D   C3           CLR     C
   \   00007E   98           SUBB    A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   EB           MOV     A,R3
   \   000081   99           SUBB    A,R1
   \   000082   F9           MOV     R1,A
   \   000083   85..82       MOV     DPL,?V0
   \   000086   85..83       MOV     DPH,?V1
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   28           ADD     A,R0
   \   00008B   F8           MOV     R0,A
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   39           ADDC    A,R1
   \   00008F   F9           MOV     R1,A
   \   000090   740C         MOV     A,#0xc
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   1917          
   1918            // Temporary workaround to allow callback functions access to the 
   1919            // transaction sequence number.  Callback functions will call 
   1920            // zcl_getParsedTransSeqNum() to retrieve this number.
   1921            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_464:
   \   000098   7408         MOV     A,#0x8
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A1   F0           MOVX    @DPTR,A
   1922            
   1923            // Find the wanted endpoint
   1924            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A2   EE           MOV     A,R6
   \   0000A3   2414         ADD     A,#0x14
   \   0000A5   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   F9           MOV     R1,A
   \   0000AA   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   0000AD   8A82         MOV     DPL,R2
   \   0000AF   8B83         MOV     DPH,R3
   1925            if ( epDesc == NULL )
   \   0000B1   E582         MOV     A,DPL
   \   0000B3   4583         ORL     A,DPH
   \   0000B5   700C         JNZ     ??zcl_ProcessMessageMSG_2
   1926            {
   1927              rawAFMsg = NULL;
   \   0000B7   90....       MOV     DPTR,#rawAFMsg
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   F0           MOVX    @DPTR,A
   1928              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000BE   7902         MOV     R1,#0x2
   \   0000C0   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1929            }
   1930          
   1931            if ( ( epDesc->simpleDesc == NULL ) ||
   1932                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1933                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C3   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   0000C6   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000C8   EE           MOV     A,R6
   \   0000C9   2404         ADD     A,#0x4
   \   0000CB   F5..         MOV     ?V4,A
   \   0000CD   E4           CLR     A
   \   0000CE   3F           ADDC    A,R7
   \   0000CF   F5..         MOV     ?V5,A
   \   0000D1                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D1   A3           INC     DPTR
   \   0000D2   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D5   740B         MOV     A,#0xb
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   FD           MOV     R5,A
   \   0000DC   7406         MOV     A,#0x6
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   5403         ANL     A,#0x3
   \   0000E4   FC           MOV     R4,A
   \   0000E5   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0000E8   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000EB   7402         MOV     A,#0x2
   \   0000ED   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F0   E9           MOV     A,R1
   \   0000F1   700C         JNZ     ??zcl_ProcessMessageMSG_4
   1934            {
   1935              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F3   90....       MOV     DPTR,#rawAFMsg
   \   0000F6   E4           CLR     A
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   A3           INC     DPTR
   \   0000F9   F0           MOVX    @DPTR,A
   1936              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FA   7903         MOV     R1,#0x3
   \   0000FC   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1937            }
   1938          
   1939          #if defined ( INTER_PAN )
   1940            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1941            {
   1942              // No foundation command is supported thru Inter-PAN communication.
   1943              // But the Light Link cluster uses a different Frame Control format
   1944              // for it's Inter-PAN messages, where the messages could be confused
   1945              // with the foundation commands.
   1946              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1947              {
   1948                rawAFMsg = NULL;
   1949                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   1950              }
   1951          
   1952              interPanMsg = TRUE;
   1953              options = AF_TX_OPTIONS_NONE;
   1954            }
   1955            else
   1956          #endif
   1957            {
   1958              interPanMsg = FALSE;
   1959              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   0000FF                ; Setup parameters for call to function zclGetClusterOption
   \   0000FF   12....       LCALL   ?Subroutine63 & 0xFFFF
   1960            }
   \                     ??CrossCallReturnLabel_96:
   \   000102   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   000105   E9           MOV     A,R1
   \   000106   F5..         MOV     ?V3,A
   1961          
   1962            // Find the appropriate plugin
   1963            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000108   85..82       MOV     DPL,?V4
   \   00010B   85..83       MOV     DPH,?V5
   \   00010E   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   000111   EA           MOV     A,R2
   \   000112   FC           MOV     R4,A
   \   000113   EB           MOV     A,R3
   \   000114   FD           MOV     R5,A
   \   000115   90....       MOV     DPTR,#plugins
   \   000118   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   00011A   8882         MOV     DPL,R0
   \   00011C   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00011E   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000121   7003         JNZ     $+5
   \   000123   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000126   8882         MOV     DPL,R0
   \   000128   8983         MOV     DPH,R1
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   00012F   C3           CLR     C
   \   000130   EC           MOV     A,R4
   \   000131   95..         SUBB    A,?V6
   \   000133   ED           MOV     A,R5
   \   000134   95..         SUBB    A,?V7
   \   000136   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000138   8882         MOV     DPL,R0
   \   00013A   8983         MOV     DPH,R1
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   C3           CLR     C
   \   000141   E0           MOVX    A,@DPTR
   \   000142   9C           SUBB    A,R4
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   9D           SUBB    A,R5
   \   000146   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000148   E8           MOV     A,R0
   \   000149   FC           MOV     R4,A
   \   00014A   E9           MOV     A,R1
   \   00014B   FD           MOV     R5,A
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   5407         ANL     A,#0x7
   \   000154   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000156   7409         MOV     A,#0x9
   \   000158   12....       LCALL   ?XSTACK_DISP0_8
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   640B         XRL     A,#0xb
   \   00015E   7003         JNZ     $+5
   \   000160   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1964          
   1965            // Local and remote Security options must match except for Default Response command
   1966            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1967            {
   1968              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000163   E5..         MOV     A,?V3
   \   000165   A2E6         MOV     C,0xE0 /* A   */.6
   \   000167   4003         JC      $+5
   \   000169   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   00016C   EE           MOV     A,R6
   \   00016D   2419         ADD     A,#0x19
   \   00016F   F582         MOV     DPL,A
   \   000171   E4           CLR     A
   \   000172   3F           ADDC    A,R7
   \   000173   F583         MOV     DPH,A
   \   000175   E0           MOVX    A,@DPTR
   \   000176   6003         JZ      $+5
   \   000178   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1969          
   1970              // Make sure that Clusters specifically defined to use security are received secure,
   1971              // any other cluster that wants to use APS security will be allowed
   1972              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1973              {
   1974                if ( UNICAST_MSG( inMsg.msg ) )
   \   00017B   7402         MOV     A,#0x2
   \   00017D   12....       LCALL   ?XSTACK_DISP0_8
   \   000180   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000183   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   000185   7402         MOV     A,#0x2
   \   000187   12....       LCALL   ?XSTACK_DISP0_8
   \   00018A   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   00018D   7073         JNZ     ??zcl_ProcessMessageMSG_10
   1975                {
   1976                  // Send a Default Response command back with no Application Link Key security
   1977                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00018F                ; Setup parameters for call to function zclSetSecurityOption
   \   00018F   7C00         MOV     R4,#0x0
   \   000191   85..82       MOV     DPL,?V0
   \   000194   85..83       MOV     DPH,?V1
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F9           MOV     R1,A
   \   000199   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1978          
   1979                  defautlRspCmd.statusCode = status;
   \   00019C   7401         MOV     A,#0x1
   \   00019E   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A1   7401         MOV     A,#0x1
   \   0001A3   F0           MOVX    @DPTR,A
   1980                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A4   7409         MOV     A,#0x9
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   12....       LCALL   ?Subroutine94 & 0xFFFF
   1981                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1982                                         inMsg.msg->clusterId, &defautlRspCmd,
   1983                                         !inMsg.hdr.fc.direction, true,
   1984                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_152:
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   0001B2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B5   7407         MOV     A,#0x7
   \   0001B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001BD   75..01       MOV     ?V2,#0x1
   \   0001C0   78..         MOV     R0,#?V2
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C5   7408         MOV     A,#0x8
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_481:
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D0   7405         MOV     A,#0x5
   \   0001D2   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D5   88..         MOV     ?V2,R0
   \   0001D7   89..         MOV     ?V3,R1
   \   0001D9   78..         MOV     R0,#?V2
   \   0001DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DE   7409         MOV     A,#0x9
   \   0001E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   0001E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E9   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   0001EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EF   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0001F2   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   0001F5   7407         MOV     A,#0x7
   \   0001F7   12....       LCALL   ?DEALLOC_XSTACK8
   1985          
   1986                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001FA                ; Setup parameters for call to function zclSetSecurityOption
   \   0001FA   7C01         MOV     R4,#0x1
   \   0001FC   12....       LCALL   ?Subroutine63 & 0xFFFF
   1987                }
   \                     ??CrossCallReturnLabel_97:
   \   0001FF   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1988          
   1989                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000202   90....       MOV     DPTR,#rawAFMsg
   \   000205   E4           CLR     A
   \   000206   F0           MOVX    @DPTR,A
   \   000207   A3           INC     DPTR
   \   000208   F0           MOVX    @DPTR,A
   1990                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000209   7905         MOV     R1,#0x5
   \   00020B   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1991              }
   1992            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00020E   7C00         MOV     R4,#0x0
   \   000210   7D00         MOV     R5,#0x0
   1993          
   1994            // Is this a foundation type message
   1995            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000212   7404         MOV     A,#0x4
   \   000214   12....       LCALL   ?XSTACK_DISP0_8
   \   000217   E0           MOVX    A,@DPTR
   \   000218   F8           MOV     R0,A
   \   000219   5403         ANL     A,#0x3
   \   00021B   6003         JZ      $+5
   \   00021D   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   1996            {
   1997              if ( inMsg.hdr.fc.manuSpecific )
   \   000220   E8           MOV     A,R0
   \   000221   5404         ANL     A,#0x4
   \   000223   6005         JZ      ??zcl_ProcessMessageMSG_12
   1998              {
   1999                // We don't support any manufacturer specific command
   2000                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000225   7E84         MOV     R6,#-0x7c
   \   000227   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2001              }
   2002              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2003                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00022A   7409         MOV     A,#0x9
   \   00022C   12....       LCALL   ?XSTACK_DISP0_8
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F5..         MOV     ?V4,A
   \   000232   C3           CLR     C
   \   000233   9417         SUBB    A,#0x17
   \   000235   4003         JC      $+5
   \   000237   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00023A   75..00       MOV     ?V5,#0x0
   \   00023D   7402         MOV     A,#0x2
   \   00023F   78..         MOV     R0,#?V4
   \   000241   12....       LCALL   ?S_SHL
   \   000244   74..         MOV     A,#zclCmdTable & 0xff
   \   000246   25..         ADD     A,?V4
   \   000248   F582         MOV     DPL,A
   \   00024A   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00024C   35..         ADDC    A,?V5
   \   00024E   F583         MOV     DPH,A
   \   000250   E4           CLR     A
   \   000251   93           MOVC    A,@A+DPTR
   \   000252   F8           MOV     R0,A
   \   000253   7401         MOV     A,#0x1
   \   000255   93           MOVC    A,@A+DPTR
   \   000256   F9           MOV     R1,A
   \   000257   E8           MOV     A,R0
   \   000258   49           ORL     A,R1
   \   000259   7003         JNZ     $+5
   \   00025B   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2004              {
   2005                zclParseCmd_t parseCmd;
   2006          
   2007                parseCmd.endpoint = pkt->endPoint;
   \   00025E   85..82       MOV     DPL,?V0
   \   000261   85..83       MOV     DPH,?V1
   \   000264   E0           MOVX    A,@DPTR
   \   000265   C0E0         PUSH    A
   \   000267   7410         MOV     A,#0x10
   \   000269   12....       LCALL   ?XSTACK_DISP0_8
   \   00026C   D0E0         POP     A
   \   00026E   F0           MOVX    @DPTR,A
   2008                parseCmd.dataLen = inMsg.pDataLen;
   \   00026F   740C         MOV     A,#0xc
   \   000271   12....       LCALL   ?XSTACK_DISP0_8
   \   000274   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   000277   7411         MOV     A,#0x11
   \   000279   12....       LCALL   ?XSTACK_DISP0_8
   \   00027C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2009                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_465:
   \   00027F   740A         MOV     A,#0xa
   \   000281   12....       LCALL   ?XSTACK_DISP0_8
   \   000284   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   000287   7413         MOV     A,#0x13
   \   000289   12....       LCALL   ?XSTACK_DISP0_8
   \   00028C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2010          
   2011                // Parse the command, remember that the return value is a pointer to allocated memory
   2012                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_466:
   \   00028F                ; Setup parameters for indirect call
   \   00028F   7410         MOV     A,#0x10
   \   000291   12....       LCALL   ?XSTACK_DISP101_8
   \   000294   7409         MOV     A,#0x9
   \   000296   12....       LCALL   ?XSTACK_DISP0_8
   \   000299   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00029C   12....       LCALL   ?S_SHL
   \   00029F   74..         MOV     A,#zclCmdTable & 0xff
   \   0002A1   25..         ADD     A,?V0
   \   0002A3   F582         MOV     DPL,A
   \   0002A5   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002A7   35..         ADDC    A,?V1
   \   0002A9   F583         MOV     DPH,A
   \   0002AB   E4           CLR     A
   \   0002AC   93           MOVC    A,@A+DPTR
   \   0002AD   C0E0         PUSH    A
   \   0002AF   7401         MOV     A,#0x1
   \   0002B1   93           MOVC    A,@A+DPTR
   \   0002B2   F583         MOV     DPH,A
   \   0002B4   D082         POP     DPL
   \   0002B6   12....       LCALL   ?CALL_IND
   \   0002B9   8A..         MOV     ?V0,R2
   \   0002BB   8B..         MOV     ?V1,R3
   \   0002BD   A8..         MOV     R0,?V0
   \   0002BF   A9..         MOV     R1,?V1
   \   0002C1   740E         MOV     A,#0xe
   \   0002C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C6   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2013                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_467:
   \   0002C9   E8           MOV     A,R0
   \   0002CA   49           ORL     A,R1
   \   0002CB   6045         JZ      ??zcl_ProcessMessageMSG_15
   \   0002CD   7409         MOV     A,#0x9
   \   0002CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D2   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0002D5   12....       LCALL   ?S_SHL
   \   0002D8   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002DA   25..         ADD     A,?V0
   \   0002DC   F582         MOV     DPL,A
   \   0002DE   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002E0   35..         ADDC    A,?V1
   \   0002E2   F583         MOV     DPH,A
   \   0002E4   E4           CLR     A
   \   0002E5   93           MOVC    A,@A+DPTR
   \   0002E6   F8           MOV     R0,A
   \   0002E7   7401         MOV     A,#0x1
   \   0002E9   93           MOVC    A,@A+DPTR
   \   0002EA   F9           MOV     R1,A
   \   0002EB   8882         MOV     DPL,R0
   \   0002ED   8983         MOV     DPH,R1
   \   0002EF   E582         MOV     A,DPL
   \   0002F1   4583         ORL     A,DPH
   \   0002F3   6012         JZ      ??zcl_ProcessMessageMSG_16
   2014                {
   2015                  // Process the command
   2016                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002F5                ; Setup parameters for indirect call
   \   0002F5   7402         MOV     A,#0x2
   \   0002F7   12....       LCALL   ?XSTACK_DISP101_8
   \   0002FA   12....       LCALL   ?CALL_IND
   2017                  {
   2018                    // Couldn't find attribute in the table.
   2019                  }
   2020                }
   2021          
   2022                // Free the buffer
   2023                if ( inMsg.attrCmd )
   \   0002FD   740E         MOV     A,#0xe
   \   0002FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000302   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000305   600B         JZ      ??zcl_ProcessMessageMSG_15
   2024                {
   2025                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   000307                ; Setup parameters for call to function osal_mem_free
   \   000307   740E         MOV     A,#0xe
   \   000309   12....       LCALL   ?XSTACK_DISP0_8
   \   00030C   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   2026                }
   \                     ??CrossCallReturnLabel_343:
   \   00030F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   2027          
   2028                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000312   7409         MOV     A,#0x9
   \   000314   12....       LCALL   ?XSTACK_DISP0_8
   \   000317   E0           MOVX    A,@DPTR
   \   000318   F8           MOV     R0,A
   \   000319   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   00031B   7402         MOV     A,#0x2
   \   00031D   68           XRL     A,R0
   \   00031E   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   000320   7403         MOV     A,#0x3
   \   000322   68           XRL     A,R0
   \   000323   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000325   7406         MOV     A,#0x6
   \   000327   68           XRL     A,R0
   \   000328   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   00032A   7408         MOV     A,#0x8
   \   00032C   68           XRL     A,R0
   \   00032D   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00032F   740C         MOV     A,#0xc
   \   000331   68           XRL     A,R0
   \   000332   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   000334   7411         MOV     A,#0x11
   \   000336   68           XRL     A,R0
   \   000337   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000339   7413         MOV     A,#0x13
   \   00033B   68           XRL     A,R0
   \   00033C   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   00033E   7415         MOV     A,#0x15
   \   000340   68           XRL     A,R0
   \   000341   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   000343   740B         MOV     A,#0xb
   \   000345   68           XRL     A,R0
   \   000346   6027         JZ      ??zcl_ProcessMessageMSG_17
   2029                {
   2030                  rawAFMsg = NULL;
   2031                  return ( ZCL_PROC_SUCCESS ); // We're done
   2032                }
   2033          
   2034                status = ZSuccess;
   \   000348   7E00         MOV     R6,#0x0
   \   00034A   8043         SJMP    ??zcl_ProcessMessageMSG_13
   2035              }
   2036              else
   2037              {
   2038                // Unsupported message
   2039                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   00034C   7E82         MOV     R6,#-0x7e
   \   00034E   803F         SJMP    ??zcl_ProcessMessageMSG_13
   2040              }
   2041            }
   2042            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2043            {
   2044              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   000350   EC           MOV     A,R4
   \   000351   4D           ORL     A,R5
   \   000352   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   000354   8C82         MOV     DPL,R4
   \   000356   8D83         MOV     DPH,R5
   \   000358   A3           INC     DPTR
   \   000359   A3           INC     DPTR
   \   00035A   A3           INC     DPTR
   \   00035B   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00035E   601F         JZ      ??zcl_ProcessMessageMSG_18
   2045              {
   2046                // The return value of the plugin function will be
   2047                //  ZSuccess - Supported and need default response
   2048                //  ZFailure - Unsupported
   2049                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2050                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2051                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2052                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2053                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000360                ; Setup parameters for indirect call
   \   000360   7402         MOV     A,#0x2
   \   000362   12....       LCALL   ?XSTACK_DISP101_8
   \   000365   12....       LCALL   ?CALL_IND
   \   000368   E9           MOV     A,R1
   \   000369   FE           MOV     R6,A
   2054                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   00036A   74FF         MOV     A,#-0x1
   \   00036C   6E           XRL     A,R6
   \   00036D   700B         JNZ     ??zcl_ProcessMessageMSG_19
   2055                {
   2056                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00036F   90....       MOV     DPTR,#rawAFMsg
   \   000372   E4           CLR     A
   \   000373   F0           MOVX    @DPTR,A
   \   000374   A3           INC     DPTR
   \   000375   F0           MOVX    @DPTR,A
   2057                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000376   F9           MOV     R1,A
   \   000377   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2058                }
   2059              }
   2060          
   2061              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   00037A   7401         MOV     A,#0x1
   \   00037C   6E           XRL     A,R6
   \   00037D   7010         JNZ     ??zcl_ProcessMessageMSG_13
   2062              {
   2063                // Unsupported message
   2064                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00037F   7404         MOV     A,#0x4
   \   000381   12....       LCALL   ?XSTACK_DISP0_8
   \   000384   E0           MOVX    A,@DPTR
   \   000385   5404         ANL     A,#0x4
   \   000387   6004         JZ      ??zcl_ProcessMessageMSG_20
   2065                {
   2066                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000389   7E83         MOV     R6,#-0x7d
   \   00038B   8002         SJMP    ??zcl_ProcessMessageMSG_13
   2067                }
   2068                else
   2069                {
   2070                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   00038D   7E81         MOV     R6,#-0x7f
   2071                }
   2072              }
   2073            }
   2074          
   2075            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00038F   7402         MOV     A,#0x2
   \   000391   12....       LCALL   ?XSTACK_DISP0_8
   \   000394   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000397   7078         JNZ     ??zcl_ProcessMessageMSG_21
   \   000399   7402         MOV     A,#0x2
   \   00039B   12....       LCALL   ?XSTACK_DISP0_8
   \   00039E   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   0003A1   706E         JNZ     ??zcl_ProcessMessageMSG_21
   \   0003A3   7404         MOV     A,#0x4
   \   0003A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A8   E0           MOVX    A,@DPTR
   \   0003A9   5410         ANL     A,#0x10
   \   0003AB   7064         JNZ     ??zcl_ProcessMessageMSG_21
   2076            {
   2077              // Send a Default Response command back
   2078              defautlRspCmd.statusCode = status;
   \   0003AD   7401         MOV     A,#0x1
   \   0003AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B2   EE           MOV     A,R6
   \   0003B3   F0           MOVX    @DPTR,A
   2079              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003B4   7409         MOV     A,#0x9
   \   0003B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B9   12....       LCALL   ?Subroutine94 & 0xFFFF
   2080              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2081                                     inMsg.msg->clusterId, &defautlRspCmd,
   2082                                     !inMsg.hdr.fc.direction, true,
   2083                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_153:
   \   0003BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BF   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0003C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C5   7407         MOV     A,#0x7
   \   0003C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003CD   75..01       MOV     ?V0,#0x1
   \   0003D0   78..         MOV     R0,#?V0
   \   0003D2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D5   7408         MOV     A,#0x8
   \   0003D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DA   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_485:
   \   0003DD   F5..         MOV     ?V0,A
   \   0003DF   78..         MOV     R0,#?V0
   \   0003E1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003E4   7405         MOV     A,#0x5
   \   0003E6   12....       LCALL   ?XSTACK_DISP100_8
   \   0003E9   88..         MOV     ?V0,R0
   \   0003EB   89..         MOV     ?V1,R1
   \   0003ED   78..         MOV     R0,#?V0
   \   0003EF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003F2   7409         MOV     A,#0x9
   \   0003F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F7   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   0003FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FD   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000400   12....       LCALL   ?XSTACK_DISP0_8
   \   000403   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000406   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   000409   7407         MOV     A,#0x7
   \   00040B   12....       LCALL   ?DEALLOC_XSTACK8
   2084              defaultResponseSent = TRUE;
   \   00040E   75..01       MOV     ?V2,#0x1
   2085            }
   2086          
   2087            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000411   90....       MOV     DPTR,#rawAFMsg
   \   000414   E4           CLR     A
   \   000415   F0           MOVX    @DPTR,A
   \   000416   A3           INC     DPTR
   \   000417   F0           MOVX    @DPTR,A
   2088            if ( status == ZSuccess )
   \   000418   EE           MOV     A,R6
   \   000419   7004         JNZ     ??zcl_ProcessMessageMSG_22
   2089            {
   2090              return ( ZCL_PROC_SUCCESS );
   \   00041B   7900         MOV     R1,#0x0
   \   00041D   801F         SJMP    ??zcl_ProcessMessageMSG_1
   2091            }
   2092            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   00041F   7484         MOV     A,#-0x7c
   \   000421   6E           XRL     A,R6
   \   000422   700E         JNZ     ??zcl_ProcessMessageMSG_23
   2093            {
   2094              if ( defaultResponseSent )
   \   000424   E5..         MOV     A,?V2
   \   000426   A2E0         MOV     C,0xE0 /* A   */.0
   \   000428   5004         JNC     ??zcl_ProcessMessageMSG_24
   2095              {
   2096                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00042A   7907         MOV     R1,#0x7
   \   00042C   8010         SJMP    ??zcl_ProcessMessageMSG_1
   2097              }
   2098              else
   2099              {
   2100                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   00042E   7906         MOV     R1,#0x6
   \   000430   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2101              }
   2102            }
   2103            else
   2104            {
   2105              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   000432   E5..         MOV     A,?V2
   \   000434   A2E0         MOV     C,0xE0 /* A   */.0
   \   000436   5004         JNC     ??zcl_ProcessMessageMSG_25
   2106              {
   2107                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000438   7909         MOV     R1,#0x9
   \   00043A   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2108              }
   2109              else
   2110              {
   2111                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   00043C   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00043E   7415         MOV     A,#0x15
   2112              }
   2113            }
   \   000440   02....       LJMP    ?Subroutine7 & 0xFFFF
   2114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   C8           XCH     A,R0
   \   000004   2415         ADD     A,#0x15
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   38           ADDC    A,R0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000003   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_512:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine177_0
   \   000003                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine180_0
   \   000005                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine162:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   F583         MOV     DPH,A
   \   000005   8882         MOV     DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine181_0
   \   000003                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine209_0:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   000003   F5..         MOV     ?V2,A
   \   000005   78..         MOV     R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   F5..         MOV     ?V4,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V5,A
   \   000006   85..82       MOV     DPL,?V4
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine217_0
   \   000004                ; // Fall through to label ??Subroutine217_0
   2115          
   2116          /*********************************************************************
   2117           * PRIVATE FUNCTIONS
   2118           *********************************************************************/
   2119          
   2120          /*********************************************************************
   2121           * @fn      zclParseHdr
   2122           *
   2123           * @brief   Parse header of the ZCL format
   2124           *
   2125           * @param   hdr - place to put the frame control information
   2126           * @param   pData - incoming buffer to parse
   2127           *
   2128           * @return  pointer past the header
   2129           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2130          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2131          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2132            // Clear the header
   2133            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   2134          
   2135            // Parse the Frame Control
   2136            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   FA           MOV     R2,A
   \   00002B   E8           MOV     A,R0
   \   00002C   4A           ORL     A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine40 & 0xFFFF
   2137            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_43:
   \   000031   A2E2         MOV     C,0xE0 /* A   */.2
   \   000033   5004         JNC     ??zclParseHdr_0
   \   000035   D2F0         SETB    B.0
   \   000037   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000039   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   00003B   E8           MOV     A,R0
   \   00003C   54FB         ANL     A,#0xfb
   \   00003E   FA           MOV     R2,A
   \   00003F   A2F0         MOV     C,B.0
   \   000041   E4           CLR     A
   \   000042   33           RLC     A
   \   000043   F5..         MOV     ?V2,A
   \   000045   75..00       MOV     ?V3,#0x0
   \   000048   7402         MOV     A,#0x2
   \   00004A   78..         MOV     R0,#?V2
   \   00004C   12....       LCALL   ?S_SHL
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V2
   \   000052   12....       LCALL   ?Subroutine40 & 0xFFFF
   2138            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_44:
   \   000055   A2E3         MOV     C,0xE0 /* A   */.3
   \   000057   85..82       MOV     DPL,?V0
   \   00005A   85..83       MOV     DPH,?V1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5004         JNC     ??zclParseHdr_2
   2139            {
   2140              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000060   4408         ORL     A,#0x8
   \   000062   8002         SJMP    ??zclParseHdr_3
   2141            }
   2142            else
   2143            {
   2144              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000064   54F7         ANL     A,#0xf7
   2145            }
   \                     ??zclParseHdr_3:
   \   000066   12....       LCALL   ?Subroutine131 & 0xFFFF
   2146          
   2147            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_315:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   D2F0         SETB    B.0
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0
   \   000077   85..83       MOV     DPH,?V1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   FA           MOV     R2,A
   \   00007E   A2F0         MOV     C,B.0
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F5..         MOV     ?V2,A
   \   000084   7404         MOV     A,#0x4
   \   000086   78..         MOV     R0,#?V2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   EA           MOV     A,R2
   \   00008C   45..         ORL     A,?V2
   \   00008E   F8           MOV     R0,A
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   12....       LCALL   ?Subroutine33 & 0xFFFF
   2148            pData++;  // move past the frame control field
   2149          
   2150            // parse the manfacturer code
   2151            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_30:
   \   000095   E8           MOV     A,R0
   \   000096   5404         ANL     A,#0x4
   \   000098   600A         JZ      ??zclParseHdr_6
   2152            {
   2153              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   12....       LCALL   ?Subroutine83 & 0xFFFF
   2154              pData += 2;
   2155            }
   \                     ??CrossCallReturnLabel_133:
   \   00009E   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   0000A1   5001         JNC     ??zclParseHdr_6
   \   0000A3   0F           INC     R7
   2156          
   2157            // parse the Transaction Sequence Number
   2158            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   85..82       MOV     DPL,?V0
   \   0000AC   85..83       MOV     DPH,?V1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   2159          
   2160            // parse the Cluster's command ID
   2161            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_395:
   \   0000B5   85..82       MOV     DPL,?V0
   \   0000B8   85..83       MOV     DPH,?V1
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   12....       LCALL   ?Subroutine35 & 0xFFFF
   2162          
   2163            // Should point to the frame payload
   2164            return ( pData );
   \                     ??CrossCallReturnLabel_313:
   \   0000C0   AA82         MOV     R2,DPL
   \   0000C2   AB83         MOV     R3,DPH
   \   0000C4   02....       LJMP    ?Subroutine1 & 0xFFFF
   2165          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine178_0
   \   000003                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   AE82         MOV     R6,DPL
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine197_0
   \   000001                ; // Fall through to label ??Subroutine197_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine160:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EA           MOV     A,R2
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET
   2166          
   2167          /*********************************************************************
   2168           * @fn      zclBuildHdr
   2169           *
   2170           * @brief   Build header of the ZCL format
   2171           *
   2172           * @param   hdr - outgoing header information
   2173           * @param   pData - outgoing header space
   2174           *
   2175           * @return  pointer past the header
   2176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2177          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2178          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2179            // Build the Frame Control byte
   2180            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   2181            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_321:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine43 & 0xFFFF
   2182            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_319:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine43 & 0xFFFF
   2183            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_320:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   12....       LCALL   ?Subroutine37 & 0xFFFF
   2184            pData++;  // move past the frame control field
   2185          
   2186            // Add the manfacturer code
   2187            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_36:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   600E         JZ      ??CrossCallReturnLabel_159
   2188            {
   2189              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000031   12....       LCALL   ?Subroutine96 & 0xFFFF
   2190              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_158:
   \   000034   8882         MOV     DPL,R0
   \   000036   8983         MOV     DPH,R1
   \   000038   A3           INC     DPTR
   \   000039   12....       LCALL   ?Subroutine96 & 0xFFFF
   2191            }
   2192          
   2193            // Add the Transaction Sequence Number
   2194            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_159:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   12....       LCALL   ?Subroutine37 & 0xFFFF
   2195          
   2196            // Add the Cluster's command ID
   2197            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_37:
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   12....       LCALL   ?Subroutine159 & 0xFFFF
   2198          
   2199            // Should point to the frame payload
   2200            return ( pData );
   \                     ??CrossCallReturnLabel_261:
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058                REQUIRE ?Subroutine8
   \   000058                ; // Fall through to label ?Subroutine8
   2201          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine179_0
   \   000007                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   22           RET
   2202          
   2203          /*********************************************************************
   2204           * @fn      zclCalcHdrSize
   2205           *
   2206           * @brief   Calculate the number of bytes needed for an outgoing
   2207           *          ZCL header.
   2208           *
   2209           * @param   hdr - outgoing header information
   2210           *
   2211           * @return  returns the number of bytes needed
   2212           */
   2213          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2214          {
   2215            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2216          
   2217            // Add the manfacturer code
   2218            if ( hdr->fc.manuSpecific )
   2219            {
   2220              needed += 2;
   2221            }
   2222          
   2223            return ( needed );
   2224          }
   2225          
   2226          /*********************************************************************
   2227           * @fn      zclFindPlugin
   2228           *
   2229           * @brief   Find the right plugin for a cluster ID
   2230           *
   2231           * @param   clusterID - cluster ID to look for
   2232           * @param   profileID - profile ID
   2233           *
   2234           * @return  pointer to plugin, NULL if not found
   2235           */
   2236          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2237          {
   2238            zclLibPlugin_t *pLoop = plugins;
   2239          
   2240            (void)profileID;  // Intentionally unreferenced parameter
   2241          
   2242            while ( pLoop != NULL )
   2243            {
   2244              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2245              {
   2246                return ( pLoop );
   2247              }
   2248          
   2249              pLoop = pLoop->next;
   2250            }
   2251          
   2252            return ( (zclLibPlugin_t *)NULL );
   2253          }
   2254          
   2255          #ifdef ZCL_DISCOVER
   2256          /*********************************************************************
   2257           * @fn      zclFindCmdRecsList
   2258           *
   2259           * @brief   Find the right command record list for an endpoint
   2260           *
   2261           * @param   endpoint - endpoint to look for
   2262           *
   2263           * @return  pointer to record list, NULL if not found
   2264           */
   2265          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2266          {
   2267            zclCmdRecsList_t *pLoop = gpCmdList;
   2268          
   2269            while ( pLoop != NULL )
   2270            {
   2271              if ( pLoop->endpoint == endpoint )
   2272              {
   2273                return ( pLoop );
   2274              }
   2275          
   2276              pLoop = pLoop->pNext;
   2277            }
   2278          
   2279            return ( NULL );
   2280          }
   2281          
   2282          /*********************************************************************
   2283           * @fn      zclFindCmdRec
   2284           *
   2285           * @brief   Find the command record that matchs the parameters
   2286           *
   2287           * @param   endpoint - Application's endpoint
   2288           * @param   clusterID - cluster ID
   2289           * @param   attrId - attribute looking for
   2290           * @param   pAttr - attribute record to be returned
   2291           *
   2292           * @return  TRUE if record found. FALSE, otherwise.
   2293           */
   2294          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2295          {
   2296            uint8 i;
   2297            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2298          
   2299            if ( pRec != NULL )
   2300            {
   2301              for ( i = 0; i < pRec->numCommands; i++ )
   2302              {
   2303                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2304                {
   2305                  *pCmd = pRec->pCmdRecs[i];
   2306          
   2307                  return ( TRUE ); // EMBEDDED RETURN
   2308                }
   2309              }
   2310            }
   2311          
   2312            return ( FALSE );
   2313          }
   2314          #endif // ZCL_DISCOVER
   2315          
   2316          /*********************************************************************
   2317           * @fn      zclFindAttrRecsList
   2318           *
   2319           * @brief   Find the right attribute record list for an endpoint
   2320           *
   2321           * @param   clusterID - endpointto look for
   2322           *
   2323           * @return  pointer to record list, NULL if not found
   2324           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2325          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2326          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2327            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2328          
   2329            while ( pLoop != NULL )
   2330            {
   2331              if ( pLoop->endpoint == endpoint )
   2332              {
   2333                return ( pLoop );
   2334              }
   2335          
   2336              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2337            }
   2338          
   2339            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2340          }
   2341          
   2342          /*********************************************************************
   2343           * @fn      zclFindAttrRec
   2344           *
   2345           * @brief   Find the attribute record that matchs the parameters
   2346           *
   2347           * @param   endpoint - Application's endpoint
   2348           * @param   clusterID - cluster ID
   2349           * @param   attrId - attribute looking for
   2350           * @param   pAttr - attribute record to be returned
   2351           *
   2352           * @return  TRUE if record found. FALSE, otherwise.
   2353           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2354          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2355          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   2356          	zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   2357          
   2358          	if ( pRec != NULL ) {
   \   000014   E582         MOV     A,DPL
   \   000016   4583         ORL     A,DPH
   \   000018   6064         JZ      ??zclFindAttrRec_0
   2359          		zclAttrRec_t const __code  * iter =  pRec->attrs;
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   000024   8007         SJMP    ??zclFindAttrRec_1
   2360          		while(iter->clusterID != ACHDJIAN_LAST_CLUSTER){
   2361          			if ( iter->clusterID == clusterID && iter->attr.attrId == attrId )  {
   2362          				*pAttr = *iter;
   2363          				return ( TRUE ); // EMBEDDED RETURN
   2364          			}
   2365          			iter++;
   \                     ??zclFindAttrRec_2:
   \   000026   E8           MOV     A,R0
   \   000027   240A         ADD     A,#0xa
   \   000029   F8           MOV     R0,A
   \   00002A   5001         JNC     ??zclFindAttrRec_1
   \   00002C   09           INC     R1
   \                     ??zclFindAttrRec_1:
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   93           MOVC    A,@A+DPTR
   \   000033   C0E0         PUSH    A
   \   000035   7401         MOV     A,#0x1
   \   000037   93           MOVC    A,@A+DPTR
   \   000038   F583         MOV     DPH,A
   \   00003A   D082         POP     DPL
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   74FF         MOV     A,#-0x1
   \   000042   6A           XRL     A,R2
   \   000043   7003         JNZ     ??zclFindAttrRec_3
   \   000045   74FF         MOV     A,#-0x1
   \   000047   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000048   6034         JZ      ??zclFindAttrRec_0
   \   00004A   EE           MOV     A,R6
   \   00004B   6A           XRL     A,R2
   \   00004C   7002         JNZ     ??zclFindAttrRec_4
   \   00004E   EF           MOV     A,R7
   \   00004F   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000050   70D4         JNZ     ??zclFindAttrRec_2
   \   000052   8882         MOV     DPL,R0
   \   000054   8983         MOV     DPH,R1
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E4           CLR     A
   \   000059   93           MOVC    A,@A+DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   7401         MOV     A,#0x1
   \   00005D   93           MOVC    A,@A+DPTR
   \   00005E   FB           MOV     R3,A
   \   00005F   E5..         MOV     A,?V0
   \   000061   6A           XRL     A,R2
   \   000062   7003         JNZ     ??zclFindAttrRec_5
   \   000064   E5..         MOV     A,?V1
   \   000066   6B           XRL     A,R3
   \                     ??zclFindAttrRec_5:
   \   000067   70BD         JNZ     ??zclFindAttrRec_2
   \   000069   740E         MOV     A,#0xe
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   000071   8983         MOV     DPH,R1
   \   000073   8882         MOV     DPL,R0
   \   000075   740A         MOV     A,#0xa
   \   000077   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   00007A   7901         MOV     R1,#0x1
   \   00007C   8002         SJMP    ??zclFindAttrRec_6
   2366          		}
   2367          	}
   2368          	return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00007E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_6:
   \   000080   02....       LJMP    ?Subroutine3 & 0xFFFF
   2369          }
   2370          
   2371          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2372          /*********************************************************************
   2373           * @fn      zclGetReadWriteCB
   2374           *
   2375           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2376           *
   2377           * @param   endpoint - Application's endpoint
   2378           *
   2379           * @return  Read/Write CB, NULL if not found
   2380           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2381          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2382          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2383            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2384          
   2385            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2386            {
   2387              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine184_0 & 0xFFFF
   2388            }
   \                     ??CrossCallReturnLabel_348:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2389          
   2390            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   80..         SJMP    ?Subroutine2
   2391          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine185_0
   \   000003                ; // Fall through to label ??Subroutine185_0
   2392          
   2393          /*********************************************************************
   2394           * @fn      zclGetAuthorizeCB
   2395           *
   2396           * @brief   Get the Read/Write Authorization callback function pointer
   2397           *          for a given endpoint.
   2398           *
   2399           * @param   endpoint - Application's endpoint
   2400           *
   2401           * @return  Authorization CB, NULL if not found
   2402           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2403          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2404          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2405            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2406          
   2407            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetAuthorizeCB_0
   2408            {
   2409              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL   ?Subroutine90 & 0xFFFF
   2410            }
   \                     ??CrossCallReturnLabel_351:
   \   000015   8004         SJMP    ??zclGetAuthorizeCB_1
   2411          
   2412            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B                REQUIRE ?Subroutine2
   \   00001B                ; // Fall through to label ?Subroutine2
   2413          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine183_0
   \   000001                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine184_0
   \   000001                ; // Fall through to label ??Subroutine184_0
   2414          #endif // ZCL_READ || ZCL_WRITE
   2415          
   2416          /*********************************************************************
   2417           * @fn      zclFindClusterOption
   2418           *
   2419           * @brief   Find the option record that matchs the cluster id
   2420           *
   2421           * @param   endpoint - Application's endpoint
   2422           * @param   clusterID - cluster ID looking for
   2423           *
   2424           * @return  pointer to clutser option, NULL if not found
   2425           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2426          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2427          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2428            zclClusterOptionList *pLoop;
   2429          
   2430            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   8004         SJMP    ??zclFindClusterOption_0
   2431            while ( pLoop != NULL )
   2432            {
   2433              if ( pLoop->endpoint == endpoint )
   2434              {
   2435                uint8 x;
   2436                for ( x = 0; x < pLoop->numOptions; x++ )
   2437                {
   2438                  if ( pLoop->options[x].clusterID == clusterID )
   2439                  {
   2440                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2441                  }
   2442                }
   2443              }
   2444          
   2445              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000017   6047         JZ      ??zclFindClusterOption_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   70ED         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0,#0x0
   \   000026   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000028   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   E5..         MOV     A,?V0
   \   000035   C3           CLR     C
   \   000036   9A           SUBB    A,R2
   \   000037   50D7         JNC     ??zclFindClusterOption_1
   \   000039   E5..         MOV     A,?V0
   \   00003B   75F003       MOV     B,#0x3
   \   00003E   A4           MUL     AB
   \   00003F   FA           MOV     R2,A
   \   000040   ABF0         MOV     R3,B
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   3B           ADDC    A,R3
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6C           XRL     A,R4
   \   000057   7003         JNZ     ??zclFindClusterOption_5
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6D           XRL     A,R5
   \                     ??zclFindClusterOption_5:
   \   00005C   70CA         JNZ     ??zclFindClusterOption_4
   \   00005E   8004         SJMP    ??zclFindClusterOption_6
   2446            }
   2447          
   2448            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000064   02....       LJMP    ?Subroutine8 & 0xFFFF
   2449          }
   2450          
   2451          /*********************************************************************
   2452           * @fn      zclGetClusterOption
   2453           *
   2454           * @brief   Get the option record that matchs the cluster id
   2455           *
   2456           * @param   endpoint - Application's endpoint
   2457           * @param   clusterID - cluster ID looking for
   2458           *
   2459           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2460           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2461          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2462          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2463            uint8 option;
   2464            zclOptionRec_t *pOption;
   2465          
   2466            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2467            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6008         JZ      ??zclGetClusterOption_0
   2468            {
   2469              option = pOption->option;
   2470              if ( !ZG_SECURE_ENABLED )
   2471              {
   2472                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2473              }
   2474          
   2475              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   54BF         ANL     A,#0xbf
   \   000017   F9           MOV     R1,A
   \   000018   8002         SJMP    ??zclGetClusterOption_1
   2476            }
   2477          
   2478            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001C   02....       LJMP    ?Subroutine2 & 0xFFFF
   2479          }
   2480          
   2481          /*********************************************************************
   2482           * @fn      zclSetSecurityOption
   2483           *
   2484           * @brief   Set the security option for the cluster id
   2485           *
   2486           * @param   endpoint - Application's endpoint
   2487           * @param   clusterID - cluster ID looking for
   2488           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2489           *
   2490           * @return  none
   2491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2492          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2493          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2494            zclOptionRec_t *pOption;
   2495          
   2496            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2497            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2498            {
   2499              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2500              {
   2501                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2502              }
   2503              else
   2504              {
   2505                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2506              }
   2507            }
   2508          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   02....       LJMP    ?Subroutine2 & 0xFFFF
   2509          
   2510          #ifdef ZCL_DISCOVER
   2511          /*********************************************************************
   2512           * @fn      zclFindNextCmdRec
   2513           *
   2514           * @brief   Find the command (or next) record that matchs the parameters
   2515           *
   2516           * @param   endpoint - Application's endpoint
   2517           * @param   clusterID - cluster ID
   2518           * @param   commandID - command ID from requesting command
   2519           * @param   direction- direction of received command
   2520           * @param   pCmdID - command looking for
   2521           * @param   pCmd - command information within command record list
   2522           *
   2523           * @return  pointer to command record, NULL no more records of this cluster
   2524           */
   2525          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2526                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2527          {
   2528            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2529            uint8 i;
   2530          
   2531            if ( pRec != NULL )
   2532            {
   2533              for ( i = 0; i < pRec->numCommands; i++ )
   2534              {
   2535                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2536                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2537                {
   2538                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2539                  {
   2540                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2541                    {
   2542                      *pCmd = pRec->pCmdRecs[i];
   2543          
   2544                      // Update command ID
   2545                      *pCmdID = pCmd->cmdID;
   2546          
   2547                      return ( TRUE ); // EMBEDDED RETURN
   2548                    }
   2549                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2550                    {
   2551                      *pCmd = pRec->pCmdRecs[i];
   2552          
   2553                      // Update command ID
   2554                      *pCmdID = pCmd->cmdID;
   2555          
   2556                      return ( TRUE ); // EMBEDDED RETURN
   2557                    }
   2558                  }
   2559                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2560                  {
   2561                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2562                    {
   2563                      *pCmd = pRec->pCmdRecs[i];
   2564          
   2565                      // Update command ID
   2566                      *pCmdID = pCmd->cmdID;
   2567          
   2568                      return ( TRUE ); // EMBEDDED RETURN
   2569                    }
   2570                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2571                    {
   2572                      *pCmd = pRec->pCmdRecs[i];
   2573          
   2574                      // Update command ID
   2575                      *pCmdID = pCmd->cmdID;
   2576          
   2577                      return ( TRUE ); // EMBEDDED RETURN
   2578                    }
   2579                  }
   2580                  else
   2581                  {
   2582                    return ( FALSE ); // Incorrect Command ID
   2583                  }
   2584                }
   2585              }
   2586            }
   2587          
   2588            return ( FALSE );
   2589          }
   2590          
   2591          /*********************************************************************
   2592           * @fn      zclFindNextAttrRec
   2593           *
   2594           * @brief   Find the attribute (or next) record that matchs the parameters
   2595           *
   2596           * @param   endpoint - Application's endpoint
   2597           * @param   clusterID - cluster ID
   2598           * @param   attr - attribute looking for
   2599           *
   2600           * @return  pointer to attribute record, NULL if not found
   2601           */
   2602          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2603                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2604          {
   2605            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2606            uint8 attrDir;
   2607          
   2608            if ( pRec != NULL )
   2609            {
   2610              uint16 x;
   2611          
   2612              for ( x = 0; x < pRec->numAttributes; x++ )
   2613              {
   2614                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2615                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2616                {
   2617                  // also make sure direction is right
   2618                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2619                  if ( attrDir == direction )
   2620                  {
   2621                    // return attribute and found attribute ID
   2622                    *pAttr = pRec->attrs[x];
   2623                    *attrId = pAttr->attr.attrId;
   2624          
   2625                    return ( TRUE ); // EMBEDDED RETURN
   2626                  }
   2627                }
   2628              }
   2629            }
   2630          
   2631            return ( FALSE );
   2632          }
   2633          #endif // ZCL_DISCOVER
   2634          
   2635          /*********************************************************************
   2636           * @fn      zclSerializeData
   2637           *
   2638           * @brief   Builds a buffer from the attribute data to sent out over
   2639           *          the air.
   2640           *          NOTE - Not compatible with application's attributes callbacks.
   2641           *
   2642           * @param   dataType - data types defined in zcl.h
   2643           * @param   attrData - pointer to the attribute data
   2644           * @param   buf - where to put the serialized data
   2645           *
   2646           * @return  pointer to end of destination buffer
   2647           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2648          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2649          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V4,R2
   \   000009   8B..         MOV     ?V5,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   2650            uint8 *pStr;
   2651            uint16 len;
   2652          
   2653            if ( attrData == NULL )
   \   00000F   E5..         MOV     A,?V4
   \   000011   45..         ORL     A,?V5
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2654            {
   2655              return ( buf );
   2656            }
   2657          
   2658            switch ( dataType )
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   A3           INC     DPTR
   \   00001D   AC82         MOV     R4,DPL
   \   00001F   AD83         MOV     R5,DPH
   \   000021   85....       MOV     ?V0,?V4
   \   000024   85....       MOV     ?V1,?V5
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   EE           MOV     A,R6
   \   00002B   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   00002E   04           DB        4
   \   00002F   41           DB        65
   \   000030   42           DB        66
   \   000031   ....         DW        ??zclSerializeData_1
   \   000033   43           DB        67
   \   000034   44           DB        68
   \   000035   ....         DW        ??zclSerializeData_2
   \   000037   E0           DB        224
   \   000038   E2           DB        226
   \   000039   ....         DW        ??zclSerializeData_3
   \   00003B   E8           DB        232
   \   00003C   E9           DB        233
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   1A           DB        26
   \   000040   08           DB        8
   \   000041   ....         DW        ??zclSerializeData_5
   \   000043   09           DB        9
   \   000044   ....         DW        ??zclSerializeData_4
   \   000046   0A           DB        10
   \   000047   ....         DW        ??zclSerializeData_6
   \   000049   0B           DB        11
   \   00004A   ....         DW        ??zclSerializeData_3
   \   00004C   10           DB        16
   \   00004D   ....         DW        ??zclSerializeData_5
   \   00004F   18           DB        24
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   19           DB        25
   \   000053   ....         DW        ??zclSerializeData_4
   \   000055   1A           DB        26
   \   000056   ....         DW        ??zclSerializeData_6
   \   000058   1B           DB        27
   \   000059   ....         DW        ??zclSerializeData_3
   \   00005B   20           DB        32
   \   00005C   ....         DW        ??zclSerializeData_5
   \   00005E   21           DB        33
   \   00005F   ....         DW        ??zclSerializeData_4
   \   000061   22           DB        34
   \   000062   ....         DW        ??zclSerializeData_6
   \   000064   23           DB        35
   \   000065   ....         DW        ??zclSerializeData_3
   \   000067   24           DB        36
   \   000068   ....         DW        ??zclSerializeData_7
   \   00006A   25           DB        37
   \   00006B   ....         DW        ??zclSerializeData_8
   \   00006D   28           DB        40
   \   00006E   ....         DW        ??zclSerializeData_5
   \   000070   29           DB        41
   \   000071   ....         DW        ??zclSerializeData_4
   \   000073   2A           DB        42
   \   000074   ....         DW        ??zclSerializeData_6
   \   000076   2B           DB        43
   \   000077   ....         DW        ??zclSerializeData_3
   \   000079   30           DB        48
   \   00007A   ....         DW        ??zclSerializeData_5
   \   00007C   31           DB        49
   \   00007D   ....         DW        ??zclSerializeData_4
   \   00007F   38           DB        56
   \   000080   ....         DW        ??zclSerializeData_4
   \   000082   39           DB        57
   \   000083   ....         DW        ??zclSerializeData_3
   \   000085   EA           DB        234
   \   000086   ....         DW        ??zclSerializeData_3
   \   000088   F0           DB        240
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   F1           DB        241
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   ....         DW        ??zclSerializeData_0
   2659            {
   2660              case ZCL_DATATYPE_DATA8:
   2661              case ZCL_DATATYPE_BOOLEAN:
   2662              case ZCL_DATATYPE_BITMAP8:
   2663              case ZCL_DATATYPE_INT8:
   2664              case ZCL_DATATYPE_UINT8:
   2665              case ZCL_DATATYPE_ENUM8:
   2666                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   000090   85..82       MOV     DPL,?V4
   \   000093   85..83       MOV     DPH,?V5
   \   000096   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000099   EC           MOV     A,R4
   \   00009A   FA           MOV     R2,A
   \   00009B   ED           MOV     A,R5
   \   00009C   FB           MOV     R3,A
   2667                 break;
   \   00009D   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2668          
   2669              case ZCL_DATATYPE_DATA16:
   2670              case ZCL_DATATYPE_BITMAP16:
   2671              case ZCL_DATATYPE_UINT16:
   2672              case ZCL_DATATYPE_INT16:
   2673              case ZCL_DATATYPE_ENUM16:
   2674              case ZCL_DATATYPE_SEMI_PREC:
   2675              case ZCL_DATATYPE_CLUSTER_ID:
   2676              case ZCL_DATATYPE_ATTR_ID:
   2677                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000A0   85..82       MOV     DPL,?V4
   \   0000A3   85..83       MOV     DPH,?V5
   \   0000A6   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_423:
   \   0000A9   12....       LCALL   ?Subroutine32 & 0xFFFF
   2678                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_28:
   \   0000AC   A3           INC     DPTR
   \   0000AD   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   0000B0   8036         SJMP    ??zclSerializeData_11
   2679                break;
   2680          
   2681              case ZCL_DATATYPE_DATA24:
   2682              case ZCL_DATATYPE_BITMAP24:
   2683              case ZCL_DATATYPE_UINT24:
   2684              case ZCL_DATATYPE_INT24:
   2685                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000B2   85..82       MOV     DPL,?V4
   \   0000B5   85..83       MOV     DPH,?V5
   \   0000B8   78..         MOV     R0,#?V0
   \   0000BA   12....       LCALL   ?L_MOV_X
   \   0000BD   8A82         MOV     DPL,R2
   \   0000BF   8B83         MOV     DPH,R3
   \   0000C1   E5..         MOV     A,?V0
   \   0000C3   12....       LCALL   ?Subroutine32 & 0xFFFF
   2686                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_29:
   \   0000C6   78..         MOV     R0,#?V0
   \   0000C8   12....       LCALL   ?L_MOV_X
   \   0000CB   E5..         MOV     A,?V1
   \   0000CD   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   2687                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_287:
   \   0000D0   85..82       MOV     DPL,?V4
   \   0000D3   85..83       MOV     DPH,?V5
   \   0000D6   78..         MOV     R0,#?V0
   \   0000D8   12....       LCALL   ?L_MOV_X
   \   0000DB   7410         MOV     A,#0x10
   \   0000DD   78..         MOV     R0,#?V0
   \   0000DF   12....       LCALL   ?UL_SHR
   \   0000E2   8A82         MOV     DPL,R2
   \   0000E4   8B83         MOV     DPH,R3
   \   0000E6   E5..         MOV     A,?V0
   \                     ??zclSerializeData_11:
   \   0000E8   12....       LCALL   ??Subroutine172_0 & 0xFFFF
   2688                break;
   \                     ??CrossCallReturnLabel_286:
   \   0000EB   8067         SJMP    ??zclSerializeData_0
   2689          
   2690              case ZCL_DATATYPE_DATA32:
   2691              case ZCL_DATATYPE_BITMAP32:
   2692              case ZCL_DATATYPE_UINT32:
   2693              case ZCL_DATATYPE_INT32:
   2694              case ZCL_DATATYPE_SINGLE_PREC:
   2695              case ZCL_DATATYPE_TOD:
   2696              case ZCL_DATATYPE_DATE:
   2697              case ZCL_DATATYPE_UTC:
   2698              case ZCL_DATATYPE_BAC_OID:
   2699                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000ED                ; Setup parameters for call to function osal_buffer_uint32
   \   0000ED   85..82       MOV     DPL,?V4
   \   0000F0   85..83       MOV     DPH,?V5
   \   0000F3   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000F6   12....       LCALL   ??osal_buffer_uint32?relay; Banked call to: osal_buffer_uint32
   \   0000F9   7404         MOV     A,#0x4
   \   0000FB   12....       LCALL   ?DEALLOC_XSTACK8
   2700                break;
   \   0000FE   8054         SJMP    ??zclSerializeData_0
   2701          
   2702              case ZCL_DATATYPE_UINT40:
   2703                pStr = (uint8*)attrData;
   2704                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000100                ; Setup parameters for call to function osal_memcpy
   \   000100   78..         MOV     R0,#?V0
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000105   7C05         MOV     R4,#0x5
   \   000107   8041         SJMP    ??zclSerializeData_12
   2705                break;
   2706          
   2707              case ZCL_DATATYPE_UINT48:
   2708                pStr = (uint8*)attrData;
   2709                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   000109                ; Setup parameters for call to function osal_memcpy
   \   000109   78..         MOV     R0,#?V0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00010E   7C06         MOV     R4,#0x6
   \   000110   8038         SJMP    ??zclSerializeData_12
   2710                break;
   2711          
   2712              case ZCL_DATATYPE_IEEE_ADDR:
   2713                pStr = (uint8*)attrData;
   2714                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   000112                ; Setup parameters for call to function osal_memcpy
   \   000112   78..         MOV     R0,#?V0
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000117   7C08         MOV     R4,#0x8
   \   000119   802F         SJMP    ??zclSerializeData_12
   2715                break;
   2716          
   2717              case ZCL_DATATYPE_CHAR_STR:
   2718              case ZCL_DATATYPE_OCTET_STR:
   2719                pStr = (uint8*)attrData;
   2720                len = *pStr;
   2721                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   00011B                ; Setup parameters for call to function osal_memcpy
   \   00011B   78..         MOV     R0,#?V0
   \   00011D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000120   85..82       MOV     DPL,?V4
   \   000123   85..83       MOV     DPH,?V5
   \   000126   E0           MOVX    A,@DPTR
   \   000127   2401         ADD     A,#0x1
   \   000129   FC           MOV     R4,A
   \   00012A   E4           CLR     A
   \   00012B   3400         ADDC    A,#0x0
   \   00012D   8011         SJMP    ??zclSerializeData_13
   2722                break;
   2723          
   2724              case ZCL_DATATYPE_LONG_CHAR_STR:
   2725              case ZCL_DATATYPE_LONG_OCTET_STR:
   2726                pStr = (uint8*)attrData;
   2727                len = BUILD_UINT16( pStr[0], pStr[1] );
   2728                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   85..82       MOV     DPL,?V4
   \   000137   85..83       MOV     DPH,?V5
   \   00013A   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00013D   FC           MOV     R4,A
   \   00013E   E4           CLR     A
   \   00013F   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000140   FD           MOV     R5,A
   \   000141   8009         SJMP    ??zclSerializeData_14
   2729                break;
   2730          
   2731              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2732                pStr = (uint8*)attrData;
   2733                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   000143                ; Setup parameters for call to function osal_memcpy
   \   000143   78..         MOV     R0,#?V0
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000148   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   00014A   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   00014C   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00014F   7403         MOV     A,#0x3
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   2734                break;
   2735          
   2736              case ZCL_DATATYPE_NO_DATA:
   2737              case ZCL_DATATYPE_UNKNOWN:
   2738                // Fall through
   2739          
   2740              default:
   2741                break;
   2742            }
   2743          
   2744            return ( buf );
   \                     ??zclSerializeData_0:
   \   000154   02....       LJMP    ?Subroutine3 & 0xFFFF
   2745          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V4
   \   000008   85..83       MOV     DPH,?V5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_518:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   2746          
   2747          #ifdef ZCL_REPORT
   2748          /*********************************************************************
   2749           * @fn      zclAnalogDataType
   2750           *
   2751           * @brief   Checks to see if Data Type is Analog
   2752           *
   2753           * @param   dataType - data type
   2754           *
   2755           * @return  TRUE if data type is analog
   2756           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2757          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2758          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2759            uint8 analog;
   2760          
   2761            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2762            {
   2763              case ZCL_DATATYPE_UINT8:
   2764              case ZCL_DATATYPE_UINT16:
   2765              case ZCL_DATATYPE_UINT24:
   2766              case ZCL_DATATYPE_UINT32:
   2767              case ZCL_DATATYPE_UINT40:
   2768              case ZCL_DATATYPE_UINT48:
   2769              case ZCL_DATATYPE_UINT56:
   2770              case ZCL_DATATYPE_UINT64:
   2771              case ZCL_DATATYPE_INT8:
   2772              case ZCL_DATATYPE_INT16:
   2773              case ZCL_DATATYPE_INT24:
   2774              case ZCL_DATATYPE_INT32:
   2775              case ZCL_DATATYPE_INT40:
   2776              case ZCL_DATATYPE_INT48:
   2777              case ZCL_DATATYPE_INT56:
   2778              case ZCL_DATATYPE_INT64:
   2779              case ZCL_DATATYPE_SEMI_PREC:
   2780              case ZCL_DATATYPE_SINGLE_PREC:
   2781              case ZCL_DATATYPE_DOUBLE_PREC:
   2782              case ZCL_DATATYPE_TOD:
   2783              case ZCL_DATATYPE_DATE:
   2784              case ZCL_DATATYPE_UTC:
   2785                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2786                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2787          
   2788              default:
   2789                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2790                break;
   2791            }
   2792          
   2793            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2794          }
   2795          
   2796          /*********************************************************************
   2797           * @fn      zclIsLittleEndianMachine
   2798           *
   2799           * @brief   Verifies endianness in system.
   2800           *
   2801           * @param   none
   2802           *
   2803           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2804           */
   2805          static int zclIsLittleEndianMachine(void)
   2806          {
   2807            uint16 test = 0x0001;
   2808          
   2809            return (*((uint8 *)(&test)));
   2810          }
   2811          
   2812          /*********************************************************************
   2813           * @fn      zcl_BuildAnalogData
   2814           *
   2815           * @brief   Build an analog arribute out of sequential bytes.
   2816           *
   2817           * @param   dataType - type of data
   2818           * @param   pData - pointer to data
   2819           * @param   pBuf - where to put the data
   2820           *
   2821           * @return  none
   2822           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2823          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     zcl_BuildAnalogData:
   2824          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   2825            int current_byte_index;
   2826            int remaining_bytes;
   2827            int step;
   2828          
   2829            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   2830          
   2831            // decide if move forward or backwards to copy data
   2832            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000023   600C         JZ      ??zcl_BuildAnalogData_0
   2833            {
   2834              step = 1;
   \   000025   75..01       MOV     ?V4,#0x1
   \   000028   75..00       MOV     ?V5,#0x0
   2835              current_byte_index = 0;
   \   00002B   7800         MOV     R0,#0x0
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   8038         SJMP    ??zcl_BuildAnalogData_1
   2836            }
   2837            else
   2838            {
   2839              step = -1;
   \                     ??zcl_BuildAnalogData_0:
   \   000031   75..FF       MOV     ?V4,#-0x1
   \   000034   75..FF       MOV     ?V5,#-0x1
   2840              current_byte_index = remaining_bytes - 1;
   \   000037   EA           MOV     A,R2
   \   000038   24FF         ADD     A,#-0x1
   \   00003A   F8           MOV     R0,A
   \   00003B   EB           MOV     A,R3
   \   00003C   34FF         ADDC    A,#-0x1
   \   00003E   8028         SJMP    ??zcl_BuildAnalogData_2
   2841            }
   2842          
   2843            while ( remaining_bytes-- )
   2844            {
   2845              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_3:
   \   000040   85..82       MOV     DPL,?V0
   \   000043   85..83       MOV     DPH,?V1
   \   000046   E0           MOVX    A,@DPTR
   \   000047   C0E0         PUSH    A
   \   000049   EE           MOV     A,R6
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   EF           MOV     A,R7
   \   00004E   39           ADDC    A,R1
   \   00004F   F583         MOV     DPH,A
   \   000051   D0E0         POP     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   85..82       MOV     DPL,?V0
   \   000057   85..83       MOV     DPH,?V1
   \   00005A   A3           INC     DPTR
   \   00005B   8582..       MOV     ?V0,DPL
   \   00005E   8583..       MOV     ?V1,DPH
   2846              current_byte_index += step;
   \   000061   E8           MOV     A,R0
   \   000062   25..         ADD     A,?V4
   \   000064   F8           MOV     R0,A
   \   000065   E9           MOV     A,R1
   \   000066   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_2:
   \   000068   F9           MOV     R1,A
   2847            }
   \                     ??zcl_BuildAnalogData_1:
   \   000069   EA           MOV     A,R2
   \   00006A   FC           MOV     R4,A
   \   00006B   EB           MOV     A,R3
   \   00006C   FD           MOV     R5,A
   \   00006D   EC           MOV     A,R4
   \   00006E   24FF         ADD     A,#-0x1
   \   000070   1A           DEC     R2
   \   000071   ED           MOV     A,R5
   \   000072   34FF         ADDC    A,#-0x1
   \   000074   FB           MOV     R3,A
   \   000075   EC           MOV     A,R4
   \   000076   4D           ORL     A,R5
   \   000077   70C7         JNZ     ??zcl_BuildAnalogData_3
   2848          }
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007E                REQUIRE ?Subroutine3
   \   00007E                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
   2849          #endif // ZCL_REPORT
   2850          
   2851          /*********************************************************************
   2852           * @fn      zclGetDataTypeLength
   2853           *
   2854           * @brief   Return the length of the datatype in octet.
   2855           *
   2856           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2857           *                ZCL_DATATYPE_CHAR_STR data types.
   2858           *
   2859           * @param   dataType - data type
   2860           *
   2861           * @return  length of data
   2862           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2863          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2864          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   2865            uint8 len;
   2866          
   2867            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   2868            {
   2869              case ZCL_DATATYPE_DATA8:
   2870              case ZCL_DATATYPE_BOOLEAN:
   2871              case ZCL_DATATYPE_BITMAP8:
   2872              case ZCL_DATATYPE_INT8:
   2873              case ZCL_DATATYPE_UINT8:
   2874              case ZCL_DATATYPE_ENUM8:
   2875                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   2876                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   2877          
   2878              case ZCL_DATATYPE_DATA16:
   2879              case ZCL_DATATYPE_BITMAP16:
   2880              case ZCL_DATATYPE_UINT16:
   2881              case ZCL_DATATYPE_INT16:
   2882              case ZCL_DATATYPE_ENUM16:
   2883              case ZCL_DATATYPE_SEMI_PREC:
   2884              case ZCL_DATATYPE_CLUSTER_ID:
   2885              case ZCL_DATATYPE_ATTR_ID:
   2886                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   2887                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   2888          
   2889              case ZCL_DATATYPE_DATA24:
   2890              case ZCL_DATATYPE_BITMAP24:
   2891              case ZCL_DATATYPE_UINT24:
   2892              case ZCL_DATATYPE_INT24:
   2893                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   2894                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   2895          
   2896              case ZCL_DATATYPE_DATA32:
   2897              case ZCL_DATATYPE_BITMAP32:
   2898              case ZCL_DATATYPE_UINT32:
   2899              case ZCL_DATATYPE_INT32:
   2900              case ZCL_DATATYPE_SINGLE_PREC:
   2901              case ZCL_DATATYPE_TOD:
   2902              case ZCL_DATATYPE_DATE:
   2903              case ZCL_DATATYPE_UTC:
   2904              case ZCL_DATATYPE_BAC_OID:
   2905                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   2906                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   2907          
   2908             case ZCL_DATATYPE_UINT40:
   2909             case ZCL_DATATYPE_INT40:
   2910                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   2911                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   2912          
   2913             case ZCL_DATATYPE_UINT48:
   2914             case ZCL_DATATYPE_INT48:
   2915                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   2916                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   2917          
   2918             case ZCL_DATATYPE_UINT56:
   2919             case ZCL_DATATYPE_INT56:
   2920                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   2921                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   2922          
   2923             case ZCL_DATATYPE_DOUBLE_PREC:
   2924             case ZCL_DATATYPE_IEEE_ADDR:
   2925             case ZCL_DATATYPE_UINT64:
   2926             case ZCL_DATATYPE_INT64:
   2927               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   2928               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   2929          
   2930              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2931               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   2932               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   2933          
   2934              case ZCL_DATATYPE_NO_DATA:
   2935              case ZCL_DATATYPE_UNKNOWN:
   2936                // Fall through
   2937          
   2938              default:
   2939                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   2940                break;
   2941            }
   2942          
   2943            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   2944          }
   2945          
   2946          /*********************************************************************
   2947           * @fn      zclGetAttrDataLength
   2948           *
   2949           * @brief   Return the length of the attribute.
   2950           *
   2951           * @param   dataType - data type
   2952           * @param   pData - pointer to data
   2953           *
   2954           * @return  returns atrribute length
   2955           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2956          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2957          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2958            uint16 dataLen = 0;
   2959          
   2960            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   2961            {
   2962              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine105 & 0xFFFF
   2963            }
   \                     ??CrossCallReturnLabel_173:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   2964            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   2965            {
   2966              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   2967            }
   2968            else
   2969            {
   2970              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   2971            }
   2972          
   2973            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ?Subroutine8 & 0xFFFF
   2974          }
   2975          
   2976          #ifdef ZCL_READ
   2977          /*********************************************************************
   2978           * @fn      zclReadAttrData
   2979           *
   2980           * @brief   Read the attribute's current value into pAttrData.
   2981           *          NOTE - Not compatible with application's attributes callbacks.
   2982           *
   2983           * @param   pAttrData - where to put attribute data
   2984           * @param   pAttr - pointer to attribute
   2985           * @param   pDataLen - where to put attribute data length
   2986           *
   2987           * @return Success
   2988           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2989          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2990          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2991            uint16 dataLen;
   2992          
   2993            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   2994            {
   2995              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   2996            }
   2997          
   2998            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   2999            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine177_0 & 0xFFFF
   3000          
   3001            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_306:
   \   000062   6007         JZ      ??zclReadAttrData_2
   3002            {
   3003              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   3004            }
   3005          
   3006            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D                REQUIRE ?Subroutine9
   \   00006D                ; // Fall through to label ?Subroutine9
   3007          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   3008          
   3009          /*********************************************************************
   3010           * @fn      zcl_ReadAttrData
   3011           *
   3012           * @brief   Read the attribute's current value into pAttrData.
   3013           *          Use application's callback function if assigned to this attribute.
   3014           *
   3015           * @param   endpoint - application's endpoint
   3016           * @param   clusterId - cluster that attribute belongs to
   3017           * @param   attrId - attribute id
   3018           * @param   pAttrData - where to put attribute data
   3019           * @param   pDataLen - where to put attribute data length
   3020           *
   3021           * @return  Successful if data was read
   3022           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3023          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3024                                                   uint8 *pAttrData, uint16 *pDataLen )
   3025          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3026            zclAttrRec_t attrRec;
   3027          
   3028            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V4,R0
   \   00001A   89..         MOV     ?V5,R1
   \   00001C   78..         MOV     R0,#?V4
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV     R1,?V2
   \   000023   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002B   E9           MOV     A,R1
   \   00002C   7004         JNZ     ??zcl_ReadAttrData_0
   3029            {
   3030              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV     R1,#0x1
   \   000030   804C         SJMP    ??zcl_ReadAttrData_1
   3031            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   741A         MOV     A,#0x1a
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   00003A   741C         MOV     A,#0x1c
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine92 & 0xFFFF
   3032          
   3033            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_149:
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   6016         JZ      ??zcl_ReadAttrData_2
   3034            {
   3035              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP102_8
   \   000056   AA..         MOV     R2,?V6
   \   000058   AB..         MOV     R3,?V7
   \   00005A   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   801A         SJMP    ??zcl_ReadAttrData_1
   3036            }
   3037            else
   3038            {
   3039              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV     R0,#?V6
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V0
   \   000072   AB..         MOV     R3,?V1
   \   000074   A9..         MOV     R1,?V2
   \   000076   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   740A         MOV     A,#0xa
   3040            }
   \   000080   02....       LJMP    ?Subroutine7 & 0xFFFF
   3041          }
   3042          
   3043          /*********************************************************************
   3044           * @fn      zclGetAttrDataLengthUsingCB
   3045           *
   3046           * @brief   Use application's callback to get the length of the attribute's
   3047           *          current value stored in the database.
   3048           *
   3049           * @param   endpoint - application's endpoint
   3050           * @param   clusterId - cluster that attribute belongs to
   3051           * @param   attrId - attribute id
   3052           *
   3053           * @return  returns attribute length
   3054           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3055          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3056          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3057            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3058            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   3059          
   3060            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V1
   \   000026   602F         JZ      ??zclGetAttrDataLengthUsingCB_0
   3061            {
   3062              // Only get the attribute length
   3063              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV     R0,?XSP + 0
   \   00002A   A9..         MOV     R1,?XSP + 1
   \   00002C   88..         MOV     ?V6,R0
   \   00002E   89..         MOV     ?V7,R1
   \   000030   78..         MOV     R0,#?V6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V6,A
   \   000038   F5..         MOV     ?V7,A
   \   00003A   78..         MOV     R0,#?V6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV     R1,#0x0
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V4
   \   000047   AB..         MOV     R3,?V5
   \   000049   85..82       MOV     DPL,?V0
   \   00004C   85..83       MOV     DPH,?V1
   \   00004F   12....       LCALL   ?CALL_IND
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3064            }
   3065          
   3066            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   000060   7402         MOV     A,#0x2
   \   000062                REQUIRE ?Subroutine7
   \   000062                ; // Fall through to label ?Subroutine7
   3067          }
   3068          
   3069          /*********************************************************************
   3070           * @fn      zclReadAttrDataUsingCB
   3071           *
   3072           * @brief   Use application's callback to read the attribute's current
   3073           *          value stored in the database.
   3074           *
   3075           * @param   endpoint - application's endpoint
   3076           * @param   clusterId - cluster that attribute belongs to
   3077           * @param   attrId - attribute id
   3078           * @param   pAttrData - where to put attribute data
   3079           * @param   pDataLen - where to put attribute data length
   3080           *
   3081           * @return  Successful if data was read
   3082           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3083          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3084                                                   uint8 *pAttrData, uint16 *pDataLen )
   3085          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   3086            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   3087          
   3088            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_337:
   \   00001C   E5..         MOV     A,?V6
   \   00001E   45..         ORL     A,?V7
   \   000020   600A         JZ      ??zclReadAttrDataUsingCB_0
   3089            {
   3090              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV     DPL,?V6
   \   000025   85..83       MOV     DPH,?V7
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   3091            }
   3092          
   3093            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V3
   \   00002F   6027         JZ      ??zclReadAttrDataUsingCB_1
   3094            {
   3095              // Read the attribute value and its length
   3096              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV     R0,#?V6
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV     A,#0x12
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV     R1,#0x1
   \   000040   EE           MOV     A,R6
   \   000041   FC           MOV     R4,A
   \   000042   EF           MOV     A,R7
   \   000043   FD           MOV     R5,A
   \   000044   AA..         MOV     R2,?V0
   \   000046   AB..         MOV     R3,?V1
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ?CALL_IND
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3097            }
   3098          
   3099            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   80..         SJMP    ??Subroutine181_0
   3100          }
   3101          
   3102          /*********************************************************************
   3103           * @fn      zclAuthorizeRead
   3104           *
   3105           * @brief   Use application's callback to authorize a Read operation
   3106           *          on a given attribute.
   3107           *
   3108           * @param   endpoint - application's endpoint
   3109           * @param   srcAddr - source Address
   3110           * @param   pAttr - pointer to attribute
   3111           *
   3112           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3113           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3114           */
   3115          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3116          {
   3117            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3118            {
   3119              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3120          
   3121              if ( pfnAuthorizeCB != NULL )
   3122              {
   3123                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3124              }
   3125            }
   3126          
   3127            return ( ZCL_STATUS_SUCCESS );
   3128          }
   3129          #endif // ZCL_READ
   3130          
   3131          #ifdef ZCL_WRITE
   3132          /*********************************************************************
   3133           * @fn      zclWriteAttrData
   3134           *
   3135           * @brief   Write the received data.
   3136           *
   3137           * @param   endpoint - application's endpoint
   3138           * @param   pAttr - where to write data to
   3139           * @param   pWriteRec - data to be written
   3140           *
   3141           * @return  Successful if data was written
   3142           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3143          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3144                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3145          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3146            uint8 status;
   3147          
   3148            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   507B         JNC     ??zclWriteAttrData_0
   3149            {
   3150              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   ??zclAuthorizeWrite?relay; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V3,A
   3151              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7076         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V1,A
   3152              {
   3153                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00002B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002E   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000031   6013         JZ      ??zclWriteAttrData_2
   \   000033                ; Setup parameters for indirect call
   \   000033   AC..         MOV     R4,?V0
   \   000035   AD..         MOV     R5,?V1
   \   000037   EE           MOV     A,R6
   \   000038   FA           MOV     R2,A
   \   000039   EF           MOV     A,R7
   \   00003A   FB           MOV     R3,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F583         MOV     DPH,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   12....       LCALL   ?CALL_IND
   \   000043   E9           MOV     A,R1
   \   000044   6047         JZ      ??zclWriteAttrData_3
   3154                {
   3155                  // Write the attribute value
   3156                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000046   E5..         MOV     A,?V0
   \   000048   2403         ADD     A,#0x3
   \   00004A   F8           MOV     R0,A
   \   00004B   E4           CLR     A
   \   00004C   35..         ADDC    A,?V1
   \   00004E   F9           MOV     R1,A
   \   00004F   88..         MOV     ?V0,R0
   \   000051   89..         MOV     ?V1,R1
   \   000053                ; Setup parameters for call to function zclGetAttrDataLength
   \   000053   8882         MOV     DPL,R0
   \   000055   F583         MOV     DPH,A
   \   000057   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F9           MOV     R1,A
   \   000064   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000067   8A..         MOV     ?V4,R2
   \   000069   8B..         MOV     ?V5,R3
   \   00006B   AC..         MOV     R4,?V4
   \   00006D   AD..         MOV     R5,?V5
   3157                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006F                ; Setup parameters for call to function osal_memcpy
   \   00006F   85..82       MOV     DPL,?V0
   \   000072   85..83       MOV     DPH,?V1
   \   000075   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   000083   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000086   7403         MOV     A,#0x3
   \   000088   12....       LCALL   ?DEALLOC_XSTACK8
   3158          
   3159                  status = ZCL_STATUS_SUCCESS;
   \   00008B   8008         SJMP    ??zclWriteAttrData_1
   3160                }
   3161                else
   3162                {
   3163                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   00008D   75..87       MOV     ?V3,#-0x79
   \   000090   8003         SJMP    ??zclWriteAttrData_1
   3164                }
   3165              }
   3166            }
   3167            else
   3168            {
   3169              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000092   75..88       MOV     ?V3,#-0x78
   3170            }
   3171          
   3172            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000095   A9..         MOV     R1,?V3
   \   000097   02....       LJMP    ?Subroutine9 & 0xFFFF
   3173          }
   3174          
   3175          /*********************************************************************
   3176           * @fn      zclWriteAttrDataUsingCB
   3177           *
   3178           * @brief   Use application's callback to write the attribute's current
   3179           *          value stored in the database.
   3180           *
   3181           * @param   endpoint - application's endpoint
   3182           * @param   pAttr - where to write data to
   3183           * @param   pAttrData - data to be written
   3184           *
   3185           * @return  Successful if data was written
   3186           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3187          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3188                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3189          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   3190            uint8 status;
   3191          
   3192            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   504A         JNC     ??zclWriteAttrDataUsingCB_0
   3193            {
   3194              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL   ??zclAuthorizeWrite?relay; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV     A,R1
   3195              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7046         JNZ     ??zclWriteAttrDataUsingCB_1
   3196              {
   3197                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001F   A9..         MOV     R1,?V0
   \   000021   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   000024   8A..         MOV     ?V2,R2
   \   000026   8B..         MOV     ?V3,R3
   3198                if ( pfnReadWriteCB != NULL )
   \   000028   EA           MOV     A,R2
   \   000029   45..         ORL     A,?V3
   \   00002B   6032         JZ      ??zclWriteAttrDataUsingCB_2
   3199                {
   3200                  // Write the attribute value
   3201                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3202                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002D                ; Setup parameters for indirect call
   \   00002D   E4           CLR     A
   \   00002E   F5..         MOV     ?V4,A
   \   000030   F5..         MOV     ?V5,A
   \   000032   78..         MOV     R0,#?V4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7410         MOV     A,#0x10
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003F   7902         MOV     R1,#0x2
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   3203                }
   \                     ??CrossCallReturnLabel_498:
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   00004F   85..82       MOV     DPL,?V2
   \   000052   85..83       MOV     DPH,?V3
   \   000055   12....       LCALL   ?CALL_IND
   \   000058   7404         MOV     A,#0x4
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3204                else
   3205                {
   3206                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   00005F   79C1         MOV     R1,#-0x3f
   \   000061   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3207                }
   3208              }
   3209            }
   3210            else
   3211            {
   3212              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000063   7988         MOV     R1,#-0x78
   3213            }
   3214          
   3215            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000065   02....       LJMP    ?Subroutine3 & 0xFFFF
   3216          }
   3217          
   3218          /*********************************************************************
   3219           * @fn      zclAuthorizeWrite
   3220           *
   3221           * @brief   Use application's callback to authorize a Write operation
   3222           *          on a given attribute.
   3223           *
   3224           * @param   endpoint - application's endpoint
   3225           * @param   srcAddr - source Address
   3226           * @param   pAttr - pointer to attribute
   3227           *
   3228           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3229           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3230           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3231          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3232          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3233            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3234            {
   3235              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   ??zclGetAuthorizeCB?relay; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3236          
   3237              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3238              {
   3239                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0
   \   00002C   AD..         MOV     R5,?V1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3240              }
   3241            }
   3242          
   3243            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   02....       LJMP    ?Subroutine3 & 0xFFFF
   3244          }
   3245          #endif // ZCL_WRITE
   3246          
   3247          #ifdef ZCL_READ
   3248          /*********************************************************************
   3249           * @fn      zclParseInReadCmd
   3250           *
   3251           * @brief   Parse the "Profile" Read Commands
   3252           *
   3253           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3254           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3255           *
   3256           * @param   pCmd - pointer to incoming data to parse
   3257           *
   3258           * @return  pointer to the parsed command structure
   3259           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3260          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3261          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3262            zclReadCmd_t *readCmd;
   3263            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00000F   FE           MOV     R6,A
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   3264          
   3265            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000012   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000015   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3266            if ( readCmd != NULL )
   \   000018   EA           MOV     A,R2
   \   000019   4B           ORL     A,R3
   \   00001A   6049         JZ      ??zclParseInReadCmd_0
   3267            {
   3268              uint8 i;
   3269              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00001C   85..82       MOV     DPL,?V0
   \   00001F   85..83       MOV     DPH,?V1
   \   000022   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_419:
   \   000025   C3           CLR     C
   \   000026   13           RRC     A
   \   000027   E8           MOV     A,R0
   \   000028   13           RRC     A
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   F0           MOVX    @DPTR,A
   3270              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002E   75..00       MOV     ?V0,#0x0
   \   000031   8029         SJMP    ??zclParseInReadCmd_1
   3271              {
   3272                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   12....       LCALL   ?Subroutine163 & 0xFFFF
   3273                pBuf += 2;
   3274              }
   \                     ??CrossCallReturnLabel_517:
   \   00003A   F8           MOV     R0,A
   \   00003B   E4           CLR     A
   \   00003C   C8           XCH     A,R0
   \   00003D   F9           MOV     R1,A
   \   00003E   EC           MOV     A,R4
   \   00003F   28           ADD     A,R0
   \   000040   E4           CLR     A
   \   000041   39           ADDC    A,R1
   \   000042   FD           MOV     R5,A
   \   000043   A8..         MOV     R0,?V0
   \   000045   E8           MOV     A,R0
   \   000046   28           ADD     A,R0
   \   000047   F8           MOV     R0,A
   \   000048   E4           CLR     A
   \   000049   33           RLC     A
   \   00004A   F9           MOV     R1,A
   \   00004B   EA           MOV     A,R2
   \   00004C   28           ADD     A,R0
   \   00004D   F582         MOV     DPL,A
   \   00004F   EB           MOV     A,R3
   \   000050   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   000053   EC           MOV     A,R4
   \   000054   12....       LCALL   ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000057   5001         JNC     ??zclParseInReadCmd_3
   \   000059   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   00005A   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   3275            }
   \                     ??CrossCallReturnLabel_281:
   \   000063   40CE         JC      ??zclParseInReadCmd_2
   3276          
   3277            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000065   02....       LJMP    ?Subroutine1 & 0xFFFF
   3278          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0,DPL
   \   000008   8583..       MOV     ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
   3279          
   3280          /*********************************************************************
   3281           * @fn      zclParseInReadRspCmd
   3282           *
   3283           * @brief   Parse the "Profile" Read Response Commands
   3284           *
   3285           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3286           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3287           *
   3288           * @param   pCmd - pointer to incoming data to parse
   3289           *
   3290           * @return  pointer to the parsed command structure
   3291           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3292          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3293          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3294            zclReadRspCmd_t *readRspCmd;
   3295            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine74 & 0xFFFF
   3296            uint8 *dataPtr;
   3297            uint8 numAttr = 0;
   3298            uint8 hdrLen;
   3299            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_117:
   \   000019   803A         SJMP    ??zclParseInReadRspCmd_0
   3300            uint16 attrDataLen;
   3301          
   3302            // find out the number of attributes and the length of attribute data
   3303            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3304            {
   3305              uint8 status;
   3306          
   3307              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00001B   05..         INC     ?V2
   3308              pBuf += 2; // move pass attribute id
   \   00001D   EE           MOV     A,R6
   \   00001E   2402         ADD     A,#0x2
   \   000020   FE           MOV     R6,A
   \   000021   5001         JNC     ??zclParseInReadRspCmd_2
   \   000023   0F           INC     R7
   3309          
   3310              status = *pBuf++;
   \                     ??zclParseInReadRspCmd_2:
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   E0           MOVX    A,@DPTR
   \   000029   A3           INC     DPTR
   \   00002A   AE82         MOV     R6,DPL
   \   00002C   AF83         MOV     R7,DPH
   3311              if ( status == ZCL_STATUS_SUCCESS )
   \   00002E   7025         JNZ     ??zclParseInReadRspCmd_0
   3312              {
   3313                uint8 dataType = *pBuf++;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   A3           INC     DPTR
   \   000033   0E           INC     R6
   \   000034   AF83         MOV     R7,DPH
   3314          
   3315                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000036                ; Setup parameters for call to function zclGetAttrDataLength
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00003D   12....       LCALL   ?Subroutine116 & 0xFFFF
   3316                pBuf += attrDataLen; // move pass attribute data
   3317          
   3318                // add padding if needed
   3319                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_202:
   \   000040   5007         JNC     ??zclParseInReadRspCmd_3
   3320                {
   3321                  attrDataLen++;
   \   000042   05..         INC     ?V0
   \   000044   04           INC     A
   \   000045   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000047   05..         INC     ?V1
   3322                }
   3323          
   3324                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000049   E5..         MOV     A,?V6
   \   00004B   25..         ADD     A,?V0
   \   00004D   F5..         MOV     ?V6,A
   \   00004F   E5..         MOV     A,?V7
   \   000051   35..         ADDC    A,?V1
   \   000053   F5..         MOV     ?V7,A
   3325              }
   3326            }
   \                     ??zclParseInReadRspCmd_0:
   \   000055   85..82       MOV     DPL,?V8
   \   000058   85..83       MOV     DPH,?V9
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00005F   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   000062   40B7         JC      ??zclParseInReadRspCmd_1
   3327          
   3328            // calculate the length of the response header
   3329            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000064   75F006       MOV     B,#0x6
   \   000067   12....       LCALL   ?Subroutine124 & 0xFFFF
   3330          
   3331            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_358:
   \   00006A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00006D   8A..         MOV     ?V10,R2
   \   00006F   8B..         MOV     ?V11,R3
   3332            if ( readRspCmd != NULL )
   \   000071   EA           MOV     A,R2
   \   000072   45..         ORL     A,?V11
   \   000074   7003         JNZ     $+5
   \   000076   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   3333            {
   3334              uint8 i;
   3335              pBuf = pCmd->pData;
   \   000079   85..82       MOV     DPL,?V4
   \   00007C   85..83       MOV     DPH,?V5
   \   00007F   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   3336              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_384:
   \   000082   F5..         MOV     ?V8,A
   \   000084   E4           CLR     A
   \   000085   3B           ADDC    A,R3
   \   000086   F5..         MOV     ?V9,A
   3337          
   3338              readRspCmd->numAttr = numAttr;
   \   000088   8A82         MOV     DPL,R2
   \   00008A   8B83         MOV     DPH,R3
   \   00008C   E5..         MOV     A,?V2
   \   00008E   F0           MOVX    @DPTR,A
   3339              for ( i = 0; i < numAttr; i++ )
   \   00008F   75..00       MOV     ?V3,#0x0
   \   000092   8077         SJMP    ??zclParseInReadRspCmd_5
   3340              {
   3341                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   000094   E5..         MOV     A,?V3
   \   000096   75F006       MOV     B,#0x6
   \   000099   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   3342          
   3343                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3344                pBuf += 2;
   \                     ??CrossCallReturnLabel_363:
   \   00009C   5001         JNC     ??zclParseInReadRspCmd_7
   \   00009E   0F           INC     R7
   3345          
   3346                statusRec->status = *pBuf++;
   \                     ??zclParseInReadRspCmd_7:
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   85..82       MOV     DPL,?V12
   \   0000A7   85..83       MOV     DPH,?V13
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   12....       LCALL   ?Subroutine33 & 0xFFFF
   3347                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_31:
   \   0000AF   7058         JNZ     ??zclParseInReadRspCmd_8
   3348                {
   3349                  statusRec->dataType = *pBuf++;
   \   0000B1   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   0000B4   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   0000B7   0E           INC     R6
   \   0000B8   AF83         MOV     R7,DPH
   3350          
   3351                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0000BA                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000BA   EE           MOV     A,R6
   \   0000BB   FA           MOV     R2,A
   \   0000BC   EF           MOV     A,R7
   \   0000BD   FB           MOV     R3,A
   \   0000BE   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000C1   8A..         MOV     ?V0,R2
   \   0000C3   8B..         MOV     ?V1,R3
   3352                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000C5                ; Setup parameters for call to function osal_memcpy
   \   0000C5   8E..         MOV     ?V4,R6
   \   0000C7   8F..         MOV     ?V5,R7
   \   0000C9   75..00       MOV     ?V6,#0x0
   \   0000CC   78..         MOV     R0,#?V4
   \   0000CE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D1   AC..         MOV     R4,?V0
   \   0000D3   AD..         MOV     R5,?V1
   \   0000D5   AA..         MOV     R2,?V8
   \   0000D7   AB..         MOV     R3,?V9
   \   0000D9   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000DC   7403         MOV     A,#0x3
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   3353                  statusRec->data = dataPtr;
   \   0000E1   85..82       MOV     DPL,?V12
   \   0000E4   85..83       MOV     DPH,?V13
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   E5..         MOV     A,?V8
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E5..         MOV     A,?V9
   \   0000F1   12....       LCALL   ??Subroutine190_0 & 0xFFFF
   3354          
   3355                  pBuf += attrDataLen; // move pass attribute data
   3356          
   3357                  // advance attribute data pointer
   3358                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_375:
   \   0000F4   5007         JNC     ??zclParseInReadRspCmd_9
   3359                  {
   3360                    attrDataLen++;
   \   0000F6   05..         INC     ?V0
   \   0000F8   04           INC     A
   \   0000F9   7002         JNZ     ??zclParseInReadRspCmd_9
   \   0000FB   05..         INC     ?V1
   3361                  }
   3362          
   3363                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   0000FD   E5..         MOV     A,?V8
   \   0000FF   25..         ADD     A,?V0
   \   000101   F5..         MOV     ?V8,A
   \   000103   E5..         MOV     A,?V9
   \   000105   35..         ADDC    A,?V1
   \   000107   F5..         MOV     ?V9,A
   3364                }
   3365              }
   \                     ??zclParseInReadRspCmd_8:
   \   000109   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00010B   E5..         MOV     A,?V3
   \   00010D   C3           CLR     C
   \   00010E   95..         SUBB    A,?V2
   \   000110   4082         JC      ??zclParseInReadRspCmd_6
   3366            }
   3367          
   3368            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000112   02....       LJMP    ?Subroutine6 & 0xFFFF
   3369          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   E5..         MOV     A,?V2
   \   000002                REQUIRE ??Subroutine187_0
   \   000002                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   A4           MUL     AB
   \   000001   04           INC     A
   \   000002   F5..         MOV     ?V8,A
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   25..         ADD     A,?V6
   \   000006   FA           MOV     R2,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V7
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   00000E   8582..       MOV     ?V12,DPL
   \   000011   8583..       MOV     ?V13,DPH
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   EA           MOV     A,R2
   \   00001E   85..82       MOV     DPL,?V12
   \   000021   85..83       MOV     DPH,?V13
   \   000024                REQUIRE ??Subroutine189_0
   \   000024                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   8A..         MOV     ?V0,R2
   \   000002   8B..         MOV     ?V1,R3
   \   000004   EE           MOV     A,R6
   \   000005   2A           ADD     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EF           MOV     A,R7
   \   000008   35..         ADDC    A,?V1
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   25..         ADD     A,?V0
   \   000004   FE           MOV     R6,A
   \   000005   EF           MOV     A,R7
   \   000006   35..         ADDC    A,?V1
   \   000008   FF           MOV     R7,A
   \   000009   E5..         MOV     A,?V0
   \   00000B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   EE           MOV     A,R6
   \   000009   98           SUBB    A,R0
   \   00000A   EF           MOV     A,R7
   \   00000B   99           SUBB    A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   000003   EA           MOV     A,R2
   \   000004   25..         ADD     A,?V8
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   000003   75..00       MOV     ?V2,#0x0
   \   000006   75..00       MOV     ?V6,#0x0
   \   000009   75..00       MOV     ?V7,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004                REQUIRE ??Subroutine199_0
   \   000004                ; // Fall through to label ??Subroutine199_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   85..83       MOV     DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine204_0
   \   000002                ; // Fall through to label ??Subroutine204_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine204_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
   3370          #endif // ZCL_READ
   3371          
   3372          #ifdef ZCL_WRITE
   3373          /*********************************************************************
   3374           * @fn      zclParseInWriteCmd
   3375           *
   3376           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3377           *          Response Commands
   3378           *
   3379           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3380           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3381           *
   3382           * @param   pCmd - pointer to incoming data to parse
   3383           *
   3384           * @return  pointer to the parsed command structure
   3385           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E5..         MOV     A,?V8
   \   000002   75F005       MOV     B,#0x5
   \   000005                REQUIRE ??Subroutine188_0
   \   000005                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3386          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3387          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   3388            zclWriteCmd_t *writeCmd;
   3389            uint8 *pBuf = pCmd->pData;
   3390            uint16 attrDataLen;
   3391            uint8 *dataPtr;
   3392            uint8 numAttr = 0;
   3393            uint8 hdrLen;
   3394            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_119:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_215
   3395          
   3396            // find out the number of attributes and the length of attribute data
   3397            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3398            {
   3399              uint8 dataType;
   3400          
   3401              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000A   05..         INC     ?V7
   3402              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInWriteCmd_1
   \   000012   0F           INC     R7
   3403          
   3404              dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_1:
   \   000013   12....       LCALL   ?Subroutine84 & 0xFFFF
   3405          
   3406              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_135:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine116 & 0xFFFF
   3407              pBuf += attrDataLen; // move pass attribute data
   3408          
   3409              // add padding if needed
   3410              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_203:
   \   00001C   5007         JNC     ??zclParseInWriteCmd_2
   3411              {
   3412                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInWriteCmd_2
   \   000023   05..         INC     ?V1
   3413              }
   3414          
   3415              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000025   12....       LCALL   ?Subroutine122 & 0xFFFF
   3416            }
   \                     ??CrossCallReturnLabel_215:
   \   000028   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   00002B   40DD         JC      ??zclParseInWriteCmd_0
   3417          
   3418            // calculate the length of the response header
   3419            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   00002D   75F005       MOV     B,#0x5
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   3420          
   3421            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   3422            if ( writeCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   6047         JZ      ??zclParseInWriteCmd_3
   3423            {
   3424              uint8 i;
   3425              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine56 & 0xFFFF
   3426              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3427          
   3428              writeCmd->numAttr = numAttr;
   3429              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_64:
   \   00004C   803B         SJMP    ??CrossCallReturnLabel_213
   3430              {
   3431                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   3432          
   3433                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3434                pBuf += 2;
   \                     ??CrossCallReturnLabel_361:
   \   000051   5001         JNC     ??zclParseInWriteCmd_5
   \   000053   0F           INC     R7
   3435                statusRec->dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_5:
   \   000054   12....       LCALL   ?Subroutine25 & 0xFFFF
   3436          
   3437                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_18:
   \   000057   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005A   8A..         MOV     ?V0,R2
   \   00005C   8B..         MOV     ?V1,R3
   3438                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   8E..         MOV     ?V4,R6
   \   000060   8F..         MOV     ?V5,R7
   \   000062   75..00       MOV     ?V6,#0x0
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006A   AC..         MOV     R4,?V0
   \   00006C   AD..         MOV     R5,?V1
   \   00006E   AA..         MOV     R2,?V2
   \   000070   AB..         MOV     R3,?V3
   \   000072   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   3439                statusRec->attrData = dataPtr;
   \   00007A   12....       LCALL   ?Subroutine20 & 0xFFFF
   3440          
   3441                pBuf += attrDataLen; // move pass attribute data
   3442          
   3443                // advance attribute data pointer
   3444                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_373:
   \   00007D   5007         JNC     ??zclParseInWriteCmd_6
   3445                {
   3446                  attrDataLen++;
   \   00007F   05..         INC     ?V0
   \   000081   04           INC     A
   \   000082   7002         JNZ     ??zclParseInWriteCmd_6
   \   000084   05..         INC     ?V1
   3447                }
   3448          
   3449                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_6:
   \   000086   12....       LCALL   ?Subroutine121 & 0xFFFF
   3450              }
   \                     ??CrossCallReturnLabel_213:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40BE         JC      ??zclParseInWriteCmd_4
   3451            }
   3452          
   3453            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   000090   02....       LJMP    ?Subroutine6 & 0xFFFF
   3454          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   E5..         MOV     A,?V2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E5..         MOV     A,?V3
   \   00000F                REQUIRE ??Subroutine190_0
   \   00000F                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine191_0
   \   000007                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_504:
   \   000003                REQUIRE ??Subroutine192_0
   \   000003                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   E5..         MOV     A,?V4
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V4,A
   \   000006   E5..         MOV     A,?V5
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V5,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   E5..         MOV     A,?V2
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V2,A
   \   000006   E5..         MOV     A,?V3
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V3,A
   \   00000C   05..         INC     ?V8
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   AE82         MOV     R6,DPL
   \   000009   AF83         MOV     R7,DPH
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V2,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V9
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   000014   75..00       MOV     ?V7,#0x0
   \   000017   75..00       MOV     ?V4,#0x0
   \   00001A   75..00       MOV     ?V5,#0x0
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   000009   85....       MOV     ?V0,?V6
   \   00000C   EA           MOV     A,R2
   \   00000D   25..         ADD     A,?V0
   \   00000F   F5..         MOV     ?V2,A
   \   000011   E4           CLR     A
   \   000012   3B           ADDC    A,R3
   \   000013   F5..         MOV     ?V3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V8,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   EE           MOV     A,R6
   \   00000D   FA           MOV     R2,A
   \   00000E   EF           MOV     A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine215_0
   \   000003                ; // Fall through to label ??Subroutine215_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine215_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002   85..82       MOV     DPL,?V2
   \   000005   85..83       MOV     DPH,?V3
   \   000008   22           RET
   3455          
   3456          /*********************************************************************
   3457           * @fn      zclParseInWriteRspCmd
   3458           *
   3459           * @brief   Parse the "Profile" Write Response Commands
   3460           *
   3461           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3462           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3463           *
   3464           * @param   pCmd - pointer to incoming data to parse
   3465           *
   3466           * @return  pointer to the parsed command structure
   3467           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3468          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3469          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3470            zclWriteRspCmd_t *writeRspCmd;
   3471            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine107 & 0xFFFF
   3472            uint8 i = 0;
   3473          
   3474            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_176:
   \   000014   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3475            if ( writeRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   604A         JZ      ??zclParseInWriteRspCmd_0
   3476            {
   3477              if ( pCmd->dataLen == 1 )
   \   00001E   85..82       MOV     DPL,?V0
   \   000021   85..83       MOV     DPH,?V1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6401         XRL     A,#0x1
   \   000027   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00002B   7029         JNZ     ??zclParseInWriteRspCmd_2
   3478              {
   3479                // special case when all writes were successfull
   3480                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002D   12....       LCALL   ?Subroutine101 & 0xFFFF
   3481              }
   \                     ??CrossCallReturnLabel_426:
   \   000030   A3           INC     DPTR
   \   000031   F0           MOVX    @DPTR,A
   \   000032   75..01       MOV     ?V4,#0x1
   \   000035   802A         SJMP    ??zclParseInWriteRspCmd_3
   3482              else
   3483              {
   3484                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3485                {
   3486                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000037   E5..         MOV     A,?V4
   \   000039   12....       LCALL   ?Subroutine15 & 0xFFFF
   3487                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_392:
   \   00003C   F5..         MOV     ?V6,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FD           MOV     R5,A
   \   000041   E5..         MOV     A,?V6
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   ED           MOV     A,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   05..         INC     ?V4
   3488                  pBuf += 2;
   \   00004F   EE           MOV     A,R6
   \   000050   2402         ADD     A,#0x2
   \   000052   FE           MOV     R6,A
   \   000053   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000055   0F           INC     R7
   3489                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000056   85..82       MOV     DPL,?V0
   \   000059   85..83       MOV     DPH,?V1
   \   00005C   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   3490              }
   \                     ??CrossCallReturnLabel_379:
   \   00005F   40D6         JC      ??zclParseInWriteRspCmd_4
   3491          
   3492              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   E5..         MOV     A,?V4
   \   000067   F0           MOVX    @DPTR,A
   3493            }
   3494          
   3495            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000068   02....       LJMP    ??Subroutine181_0 & 0xFFFF
   3496          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C                REQUIRE ??Subroutine195_0
   \   00000C                ; // Fall through to label ??Subroutine195_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000008                REQUIRE ??Subroutine196_0
   \   000008                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   000003   75..00       MOV     ?V4,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine200_0
   \   000004                ; // Fall through to label ??Subroutine200_0
   3497          #endif // ZCL_WRITE
   3498          
   3499          #ifdef ZCL_REPORT
   3500          /*********************************************************************
   3501           * @fn      zclParseInConfigReportCmd
   3502           *
   3503           * @brief   Parse the "Profile" Configure Reporting Command
   3504           *
   3505           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3506           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3507           *
   3508           * @param   pCmd - pointer to incoming data to parse
   3509           *
   3510           * @return  pointer to the parsed command structure
   3511           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine168_0
   \   000004                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3512          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3513          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   3514            zclCfgReportCmd_t *cfgReportCmd;
   3515            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine74 & 0xFFFF
   3516            uint8 *dataPtr;
   3517            uint8 numAttr = 0;
   3518            uint8 dataType;
   3519            uint8 hdrLen;
   3520            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_118:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   3521            uint8 reportChangeLen; // length of Reportable Change field
   3522          
   3523            // Calculate the length of the Request command
   3524            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3525            {
   3526              uint8 direction;
   3527          
   3528              numAttr++;
   3529              direction = *pBuf++;
   3530              pBuf += 2; // move pass the attribute ID
   3531          
   3532              // Is there a Reportable Change field?
   3533              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3534              {
   3535                dataType = *pBuf++;
   3536                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3537          
   3538                // For attributes of 'discrete' data types this field is omitted
   3539                if ( zclAnalogDataType( dataType ) )
   3540                {
   3541                  reportChangeLen = zclGetDataTypeLength( dataType );
   3542                  pBuf += reportChangeLen;
   3543          
   3544                  // add padding if needed
   3545                  if ( PADDING_NEEDED( reportChangeLen ) )
   3546                  {
   3547                    reportChangeLen++;
   3548                  }
   3549          
   3550                  dataLen += reportChangeLen;
   3551                }
   3552                else
   3553                {
   3554                  pBuf++; // move past reportable change field
   3555                }
   3556              }
   3557              else
   3558              {
   3559                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2402         ADD     A,#0x2
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   3560              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   00002B   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   00002E   504B         JNC     ??zclParseInConfigReportCmd_2
   \   000030   05..         INC     ?V2
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   AF83         MOV     R7,DPH
   \   00003B   E582         MOV     A,DPL
   \   00003D   2402         ADD     A,#0x2
   \   00003F   FE           MOV     R6,A
   \   000040   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000042   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000043   E8           MOV     A,R0
   \   000044   70D5         JNZ     ??zclParseInConfigReportCmd_1
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5..         MOV     ?V3,A
   \   00004D   A3           INC     DPTR
   \   00004E   AF83         MOV     R7,DPH
   \   000050   E582         MOV     A,DPL
   \   000052   2404         ADD     A,#0x4
   \   000054   FE           MOV     R6,A
   \   000055   5001         JNC     ??zclParseInConfigReportCmd_4
   \   000057   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_4:
   \   000058                ; Setup parameters for call to function zclAnalogDataType
   \   000058   A9..         MOV     R1,?V3
   \   00005A   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005D   E9           MOV     A,R1
   \   00005E   6011         JZ      ??zclParseInConfigReportCmd_5
   \   000060                ; Setup parameters for call to function zclGetDataTypeLength
   \   000060   A9..         MOV     R1,?V3
   \   000062   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000065   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000068   5002         JNC     ??zclParseInConfigReportCmd_6
   \   00006A   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_6:
   \   00006C   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00006F   80B1         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_5:
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   A3           INC     DPTR
   \   000076   0E           INC     R6
   \   000077   AF83         MOV     R7,DPH
   \   000079   80A7         SJMP    ??zclParseInConfigReportCmd_0
   3561            } // while loop
   3562          
   3563            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   00007B   75F00C       MOV     B,#0xc
   \   00007E   12....       LCALL   ?Subroutine124 & 0xFFFF
   3564          
   3565            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_359:
   \   000081   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000084   8A..         MOV     ?V6,R2
   \   000086   8B..         MOV     ?V7,R3
   3566            if ( cfgReportCmd != NULL )
   \   000088   EA           MOV     A,R2
   \   000089   45..         ORL     A,?V7
   \   00008B   7003         JNZ     $+5
   \   00008D   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   3567            {
   3568              uint8 i;
   3569              pBuf = pCmd->pData;
   \   000090   12....       LCALL   ?Subroutine80 & 0xFFFF
   3570              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_382:
   \   000093   F5..         MOV     ?V4,A
   \   000095   E4           CLR     A
   \   000096   3B           ADDC    A,R3
   \   000097   F5..         MOV     ?V5,A
   3571          
   3572              cfgReportCmd->numAttr = numAttr;
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V2
   \   00009F   F0           MOVX    @DPTR,A
   3573              for ( i = 0; i < numAttr; i++ )
   \   0000A0   75..00       MOV     ?V3,#0x0
   \   0000A3   800B         SJMP    ??zclParseInConfigReportCmd_8
   3574              {
   3575                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3576          
   3577                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3578          
   3579                reportRec->direction = *pBuf++;
   3580                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3581                pBuf += 2;
   3582                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3583                {
   3584                  // Attribute to be reported
   3585                  reportRec->dataType = *pBuf++;
   3586                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3587                  pBuf += 2;
   3588                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3589                  pBuf += 2;
   3590          
   3591                  // For attributes of 'discrete' data types this field is omitted
   3592                  if ( zclAnalogDataType( reportRec->dataType ) )
   3593                  {
   3594                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3595                    reportRec->reportableChange = dataPtr;
   3596          
   3597                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3598                    pBuf += reportChangeLen;
   3599          
   3600                    // advance attribute data pointer
   3601                    if ( PADDING_NEEDED( reportChangeLen ) )
   3602                    {
   3603                      reportChangeLen++;
   3604                    }
   3605          
   3606                    dataPtr += reportChangeLen;
   3607                  }
   3608                }
   3609                else
   3610                {
   3611                  // Attribute reports to be received
   3612                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_9:
   \   0000A5   12....       LCALL   ?Subroutine69 & 0xFFFF
   3613                  pBuf += 2;
   3614                }
   \                     ??CrossCallReturnLabel_108:
   \   0000A8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   0000AB   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000AD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000AE   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B0   E5..         MOV     A,?V3
   \   0000B2   C3           CLR     C
   \   0000B3   95..         SUBB    A,?V2
   \   0000B5   4003         JC      $+5
   \   0000B7   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   \   0000BA   E5..         MOV     A,?V3
   \   0000BC   75F00C       MOV     B,#0xc
   \   0000BF   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   0000C2                ; Setup parameters for call to function osal_memset
   \   0000C2   7C0C         MOV     R4,#0xc
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   AA..         MOV     R2,?V0
   \   0000CA   AB..         MOV     R3,?V1
   \   0000CC   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0000CF   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0000D2   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   0000D5   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   0000D8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   0000DB   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000DD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000DE   8E82         MOV     DPL,R6
   \   0000E0   8F83         MOV     DPH,R7
   \   0000E2   A3           INC     DPTR
   \   0000E3   A882         MOV     R0,DPL
   \   0000E5   A983         MOV     R1,DPH
   \   0000E7   8E82         MOV     DPL,R6
   \   0000E9   8F83         MOV     DPH,R7
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   F5..         MOV     ?V10,A
   \   0000EE   EC           MOV     A,R4
   \   0000EF   70B4         JNZ     ??zclParseInConfigReportCmd_9
   \   0000F1   E5..         MOV     A,?V0
   \   0000F3   2403         ADD     A,#0x3
   \   0000F5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000F8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   0000FB   5001         JNC     ??zclParseInConfigReportCmd_12
   \   0000FD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_12:
   \   0000FE   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000101   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   000104   5001         JNC     ??zclParseInConfigReportCmd_13
   \   000106   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_13:
   \   000107                ; Setup parameters for call to function zclAnalogDataType
   \   000107   A9..         MOV     R1,?V10
   \   000109   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00010C   E9           MOV     A,R1
   \   00010D   609F         JZ      ??zclParseInConfigReportCmd_10
   \   00010F                ; Setup parameters for call to function zcl_BuildAnalogData
   \   00010F   EE           MOV     A,R6
   \   000110   FC           MOV     R4,A
   \   000111   EF           MOV     A,R7
   \   000112   FD           MOV     R5,A
   \   000113   AA..         MOV     R2,?V4
   \   000115   AB..         MOV     R3,?V5
   \   000117   85..82       MOV     DPL,?V8
   \   00011A   85..83       MOV     DPH,?V9
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F9           MOV     R1,A
   \   00011F   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000122   85..82       MOV     DPL,?V0
   \   000125   85..83       MOV     DPH,?V1
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E5..         MOV     A,?V4
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V5
   \   000138   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000141   5002         JNC     ??zclParseInConfigReportCmd_14
   \   000143   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_14:
   \   000145   E5..         MOV     A,?V4
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V4,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V5
   \   00014E   F5..         MOV     ?V5,A
   \   000150   02....       LJMP    ??zclParseInConfigReportCmd_10 & 0xFFFF
   3615              } // while loop
   3616            }
   3617          
   3618            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_7:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3619          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine193_0
   \   000006                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   E5..         MOV     A,?V6
   \   000002   25..         ADD     A,?V10
   \   000004   F5..         MOV     ?V6,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V7
   \   000009   F5..         MOV     ?V7,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   00000E   8582..       MOV     ?V0,DPL
   \   000011   8583..       MOV     ?V1,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V10,A
   \   000003   EE           MOV     A,R6
   \   000004   29           ADD     A,R1
   \   000005   FE           MOV     R6,A
   \   000006   E4           CLR     A
   \   000007   3F           ADDC    A,R7
   \   000008   FF           MOV     R7,A
   \   000009   E9           MOV     A,R1
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FC           MOV     R4,A
   \   000006   85..82       MOV     DPL,?V0
   \   000009   85..83       MOV     DPH,?V1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000004   85..82       MOV     DPL,?V0
   \   000007   85..83       MOV     DPH,?V1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   E5..         MOV     A,?V10
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   85..82       MOV     DPL,?V8
   \   00000A   F583         MOV     DPH,A
   \   00000C   E5..         MOV     A,?V10
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   0E           INC     R6
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   3620          
   3621          /*********************************************************************
   3622           * @fn      zclParseInConfigReportRspCmd
   3623           *
   3624           * @brief   Parse the "Profile" Configure Reporting Response Command
   3625           *
   3626           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3627           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3628           *
   3629           * @param   pCmd - pointer to incoming data to parse
   3630           *
   3631           * @return  pointer to the parsed command structure
   3632           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3633          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3634          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   3635            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3636            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine91 & 0xFFFF
   3637            uint8 numAttr;
   3638          
   3639            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_145:
   \   000008   F5..         MOV     ?V0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?US_SHR
   \   000015   E5..         MOV     A,?V0
   \   000017   F5..         MOV     ?V2,A
   3640          
   3641            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3642                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   E5..         MOV     A,?V0
   \   000025   2401         ADD     A,#0x1
   \   000027   FA           MOV     R2,A
   \   000028   E4           CLR     A
   \   000029   35..         ADDC    A,?V1
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3643            if ( cfgReportRspCmd != NULL )
   \   00002F   EA           MOV     A,R2
   \   000030   4B           ORL     A,R3
   \   000031   6040         JZ      ??zclParseInConfigReportRspCmd_0
   3644            {
   3645              uint8 i;
   3646              cfgReportRspCmd->numAttr = numAttr;
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   E5..         MOV     A,?V2
   \   000039   F0           MOVX    @DPTR,A
   3647              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003A   75..00       MOV     ?V2,#0x0
   \   00003D   802B         SJMP    ??zclParseInConfigReportRspCmd_1
   3648              {
   3649                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_2:
   \   00003F   85....       MOV     ?V0,?V2
   \   000042   75..00       MOV     ?V1,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   EA           MOV     A,R2
   \   00004D   25..         ADD     A,?V0
   \   00004F   F8           MOV     R0,A
   \   000050   EB           MOV     A,R3
   \   000051   35..         ADDC    A,?V1
   \   000053   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   3650                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3651                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3652                pBuf += 2;
   3653              }
   \                     ??CrossCallReturnLabel_394:
   \   000056   8882         MOV     DPL,R0
   \   000058   8983         MOV     DPH,R1
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00005E   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000065   5001         JNC     ??zclParseInConfigReportRspCmd_3
   \   000067   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_3:
   \   000068   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00006A   8A82         MOV     DPL,R2
   \   00006C   8B83         MOV     DPH,R3
   \   00006E   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   3654            }
   \                     ??CrossCallReturnLabel_455:
   \   000071   40CC         JC      ??zclParseInConfigReportRspCmd_2
   3655          
   3656            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000073   7F03         MOV     R7,#0x3
   \   000075   02....       LJMP    ?BANKED_LEAVE_XDATA
   3657          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine194_0
   \   000002                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000004   A3           INC     DPTR
   \   000005   0E           INC     R6
   \   000006   AF83         MOV     R7,DPH
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET
   3658          
   3659          /*********************************************************************
   3660           * @fn      zclParseInReadReportCfgCmd
   3661           *
   3662           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3663           *
   3664           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3665           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3666           *
   3667           * @param   pCmd - pointer to incoming data to parse
   3668           *
   3669           * @return  pointer to the parsed command structure
   3670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3671          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3672          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3673            zclReadReportCfgCmd_t *readReportCfgCmd;
   3674            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine91 & 0xFFFF
   3675            uint8 numAttr;
   3676          
   3677            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_146:
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   7A03         MOV     R2,#0x3
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   ?US_DIV_MOD
   \   000013   E8           MOV     A,R0
   \   000014   F5..         MOV     ?V0,A
   3678          
   3679            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3680                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_506:
   \   000019   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3681            if ( readReportCfgCmd != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6025         JZ      ??zclParseInReadReportCfgCmd_0
   3682            {
   3683              uint8 i;
   3684              readReportCfgCmd->numAttr = numAttr;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E5..         MOV     A,?V0
   \   000026   F0           MOVX    @DPTR,A
   3685              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   8010         SJMP    ??zclParseInReadReportCfgCmd_1
   3686              {
   3687                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002C   E5..         MOV     A,?V2
   \   00002E   12....       LCALL   ?Subroutine15 & 0xFFFF
   3688                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3689                pBuf += 2;
   3690              }
   \                     ??CrossCallReturnLabel_393:
   \   000031   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000034   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000037   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   000039   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00003A   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   3691            }
   \                     ??CrossCallReturnLabel_456:
   \   000043   40E7         JC      ??zclParseInReadReportCfgCmd_2
   3692          
   3693            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000045   02....       LJMP    ?Subroutine1 & 0xFFFF
   3694          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine156:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine216_0
   \   000003                ; // Fall through to label ??Subroutine216_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine216_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3695          
   3696          /*********************************************************************
   3697           * @fn      zclParseInReadReportCfgRspCmd
   3698           *
   3699           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3700           *
   3701           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3702           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3703           *
   3704           * @param   pCmd - pointer to incoming data to parse
   3705           *
   3706           * @return  pointer to the parsed command structure
   3707           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3708          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3709          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   3710            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3711            uint8 reportChangeLen;
   3712            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine107 & 0xFFFF
   3713            uint8 *dataPtr;
   3714            uint8 numAttr = 0;
   3715            uint8 hdrLen;
   3716            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_177:
   \   000019   75..00       MOV     ?V6,#0x0
   \   00001C   75..00       MOV     ?V7,#0x0
   \   00001F   8007         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3717          
   3718            // Calculate the length of the response command
   3719            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3720            {
   3721              uint8 status;
   3722              uint8 direction;
   3723          
   3724              numAttr++;
   3725              status = *pBuf++;
   3726              direction = *pBuf++;
   3727              pBuf += 2; // move pass the attribute ID
   3728          
   3729              if ( status == ZCL_STATUS_SUCCESS )
   3730              {
   3731                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3732                {
   3733                  uint8 dataType = *pBuf++;
   3734                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3735          
   3736                  // For attributes of 'discrete' data types this field is omitted
   3737                  if ( zclAnalogDataType( dataType ) )
   3738                  {
   3739                    reportChangeLen = zclGetDataTypeLength( dataType );
   3740                    pBuf += reportChangeLen;
   3741          
   3742                    // add padding if needed
   3743                    if ( PADDING_NEEDED( reportChangeLen ) )
   3744                    {
   3745                      reportChangeLen++;
   3746                    }
   3747          
   3748                    dataLen += reportChangeLen;
   3749                  }
   3750                }
   3751                else
   3752                {
   3753                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   000021   EE           MOV     A,R6
   \   000022   2402         ADD     A,#0x2
   \   000024   FE           MOV     R6,A
   \   000025   5001         JNC     ??zclParseInReadReportCfgRspCmd_0
   \   000027   0F           INC     R7
   3754                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000028   85..82       MOV     DPL,?V2
   \   00002B   85..83       MOV     DPH,?V3
   \   00002E   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000031   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   000034   5045         JNC     ??zclParseInReadReportCfgRspCmd_2
   \   000036   05..         INC     ?V4
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   00003F   A3           INC     DPTR
   \   000040   AF83         MOV     R7,DPH
   \   000042   E582         MOV     A,DPL
   \   000044   2402         ADD     A,#0x2
   \   000046   FE           MOV     R6,A
   \   000047   5001         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000049   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   00004A   E8           MOV     A,R0
   \   00004B   70DB         JNZ     ??zclParseInReadReportCfgRspCmd_0
   \   00004D   E9           MOV     A,R1
   \   00004E   70D1         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F5..         MOV     ?V5,A
   \   000057   A3           INC     DPTR
   \   000058   AF83         MOV     R7,DPH
   \   00005A   E582         MOV     A,DPL
   \   00005C   2404         ADD     A,#0x4
   \   00005E   FE           MOV     R6,A
   \   00005F   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000061   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000062                ; Setup parameters for call to function zclAnalogDataType
   \   000062   A9..         MOV     R1,?V5
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60BE         JZ      ??zclParseInReadReportCfgRspCmd_0
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   A9..         MOV     R1,?V5
   \   00006C   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006F   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000072   5002         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   000074   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   000076   12....       LCALL   ?Subroutine123 & 0xFFFF
   3755              }
   3756            } // while loop
   \                     ??CrossCallReturnLabel_218:
   \   000079   80AD         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3757          
   3758            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   00007B   75F00D       MOV     B,#0xd
   \   00007E   E5..         MOV     A,?V4
   \   000080   12....       LCALL   ??Subroutine187_0 & 0xFFFF
   3759          
   3760            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_360:
   \   000083   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000086   8A..         MOV     ?V6,R2
   \   000088   8B..         MOV     ?V7,R3
   3761            if ( readReportCfgRspCmd != NULL )
   \   00008A   EA           MOV     A,R2
   \   00008B   45..         ORL     A,?V7
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3762            {
   3763              uint8 i;
   3764              pBuf = pCmd->pData;
   \   000092   12....       LCALL   ?Subroutine80 & 0xFFFF
   3765              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_383:
   \   000095   F5..         MOV     ?V2,A
   \   000097   E4           CLR     A
   \   000098   3B           ADDC    A,R3
   \   000099   F5..         MOV     ?V3,A
   3766          
   3767              readReportCfgRspCmd->numAttr = numAttr;
   \   00009B   8A82         MOV     DPL,R2
   \   00009D   8B83         MOV     DPH,R3
   \   00009F   E5..         MOV     A,?V4
   \   0000A1   F0           MOVX    @DPTR,A
   3768              for ( i = 0; i < numAttr; i++ )
   \   0000A2   75..00       MOV     ?V5,#0x0
   \   0000A5   800C         SJMP    ??zclParseInReadReportCfgRspCmd_7
   3769              {
   3770                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3771          
   3772                reportRspRec->status = *pBuf++;
   3773                reportRspRec->direction = *pBuf++;
   3774                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3775                pBuf += 2;
   3776          
   3777                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3778                {
   3779                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3780                  {
   3781                    reportRspRec->dataType = *pBuf++;
   3782                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3783                    pBuf += 2;
   3784                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3785                    pBuf += 2;
   3786          
   3787                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3788                    {
   3789                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3790                      reportRspRec->reportableChange = dataPtr;
   3791          
   3792                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3793                      pBuf += reportChangeLen;
   3794          
   3795                      // advance attribute data pointer
   3796                      if ( PADDING_NEEDED( reportChangeLen ) )
   3797                      {
   3798                        reportChangeLen++;
   3799                      }
   3800          
   3801                      dataPtr += reportChangeLen;
   3802                    }
   3803                  }
   3804                  else
   3805                  {
   3806                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000A7   12....       LCALL   ?Subroutine69 & 0xFFFF
   3807                    pBuf += 2;
   3808                  }
   \                     ??CrossCallReturnLabel_109:
   \   0000AA   A3           INC     DPTR
   \   0000AB   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   0000AE   5001         JNC     ??zclParseInReadReportCfgRspCmd_9
   \   0000B0   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000B1   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0000B3   E5..         MOV     A,?V5
   \   0000B5   C3           CLR     C
   \   0000B6   95..         SUBB    A,?V4
   \   0000B8   4003         JC      $+5
   \   0000BA   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   \   0000BD   E5..         MOV     A,?V5
   \   0000BF   75F00D       MOV     B,#0xd
   \   0000C2   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   0000C5   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0000C8   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   0000CB   FD           MOV     R5,A
   \   0000CC   85..82       MOV     DPL,?V0
   \   0000CF   85..83       MOV     DPH,?V1
   \   0000D2   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000D5   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000D8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   0000DB   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000DD   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000DE   EC           MOV     A,R4
   \   0000DF   70D0         JNZ     ??zclParseInReadReportCfgRspCmd_9
   \   0000E1   8E82         MOV     DPL,R6
   \   0000E3   8F83         MOV     DPH,R7
   \   0000E5   A3           INC     DPTR
   \   0000E6   A882         MOV     R0,DPL
   \   0000E8   A983         MOV     R1,DPH
   \   0000EA   8E82         MOV     DPL,R6
   \   0000EC   8F83         MOV     DPH,R7
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V10,A
   \   0000F1   ED           MOV     A,R5
   \   0000F2   70B3         JNZ     ??zclParseInReadReportCfgRspCmd_8
   \   0000F4   E5..         MOV     A,?V0
   \   0000F6   2404         ADD     A,#0x4
   \   0000F8   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000FB   A3           INC     DPTR
   \   0000FC   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   0000FF   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   000101   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   000102   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000105   A3           INC     DPTR
   \   000106   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000109   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   00010B   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   00010C                ; Setup parameters for call to function zclAnalogDataType
   \   00010C   A9..         MOV     R1,?V10
   \   00010E   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000111   E9           MOV     A,R1
   \   000112   609D         JZ      ??zclParseInReadReportCfgRspCmd_9
   \   000114                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000114   EE           MOV     A,R6
   \   000115   FC           MOV     R4,A
   \   000116   EF           MOV     A,R7
   \   000117   FD           MOV     R5,A
   \   000118   AA..         MOV     R2,?V2
   \   00011A   AB..         MOV     R3,?V3
   \   00011C   85..82       MOV     DPL,?V8
   \   00011F   85..83       MOV     DPH,?V9
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000127   E5..         MOV     A,?V0
   \   000129   240B         ADD     A,#0xb
   \   00012B   F582         MOV     DPL,A
   \   00012D   E4           CLR     A
   \   00012E   35..         ADDC    A,?V1
   \   000130   F583         MOV     DPH,A
   \   000132   E5..         MOV     A,?V2
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V3
   \   000138   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000141   5002         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   000143   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   000145   E5..         MOV     A,?V2
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V2,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V3
   \   00014E   F5..         MOV     ?V3,A
   \   000150   02....       LJMP    ??zclParseInReadReportCfgRspCmd_9 & 0xFFFF
   3809                }
   3810              }
   3811            }
   3812          
   3813            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3814          }
   3815          
   3816          /*********************************************************************
   3817           * @fn      zclParseInReportCmd
   3818           *
   3819           * @brief   Parse the "Profile" Report Command
   3820           *
   3821           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3822           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3823           *
   3824           * @param   pCmd - pointer to incoming data to parse
   3825           *
   3826           * @return  pointer to the parsed command structure
   3827           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3828          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   3829          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   3830            zclReportCmd_t *reportCmd;
   3831            uint8 *pBuf = pCmd->pData;
   3832            uint16 attrDataLen;
   3833            uint8 *dataPtr;
   3834            uint8 numAttr = 0;
   3835            uint8 hdrLen;
   3836            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_120:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_216
   3837          
   3838            // find out the number of attributes and the length of attribute data
   3839            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3840            {
   3841              uint8 dataType;
   3842          
   3843              numAttr++;
   \                     ??zclParseInReportCmd_0:
   \   00000A   05..         INC     ?V7
   3844              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInReportCmd_1
   \   000012   0F           INC     R7
   3845          
   3846              dataType = *pBuf++;
   \                     ??zclParseInReportCmd_1:
   \   000013   12....       LCALL   ?Subroutine84 & 0xFFFF
   3847          
   3848              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_136:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine116 & 0xFFFF
   3849              pBuf += attrDataLen; // move pass attribute data
   3850          
   3851              // add padding if needed
   3852              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_204:
   \   00001C   5007         JNC     ??zclParseInReportCmd_2
   3853              {
   3854                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInReportCmd_2
   \   000023   05..         INC     ?V1
   3855              }
   3856          
   3857              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000025   12....       LCALL   ?Subroutine122 & 0xFFFF
   3858            }
   \                     ??CrossCallReturnLabel_216:
   \   000028   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   00002B   40DD         JC      ??zclParseInReportCmd_0
   3859          
   3860            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   00002D   75F005       MOV     B,#0x5
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   3861          
   3862            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   3863            if (reportCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   6047         JZ      ??zclParseInReportCmd_3
   3864            {
   3865              uint8 i;
   3866              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine56 & 0xFFFF
   3867              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3868          
   3869              reportCmd->numAttr = numAttr;
   3870              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_65:
   \   00004C   803B         SJMP    ??CrossCallReturnLabel_214
   3871              {
   3872                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_4:
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   3873          
   3874                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3875                pBuf += 2;
   \                     ??CrossCallReturnLabel_362:
   \   000051   5001         JNC     ??zclParseInReportCmd_5
   \   000053   0F           INC     R7
   3876                reportRec->dataType = *pBuf++;
   \                     ??zclParseInReportCmd_5:
   \   000054   12....       LCALL   ?Subroutine25 & 0xFFFF
   3877          
   3878                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_19:
   \   000057   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005A   8A..         MOV     ?V0,R2
   \   00005C   8B..         MOV     ?V1,R3
   3879                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   8E..         MOV     ?V4,R6
   \   000060   8F..         MOV     ?V5,R7
   \   000062   75..00       MOV     ?V6,#0x0
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006A   AC..         MOV     R4,?V0
   \   00006C   AD..         MOV     R5,?V1
   \   00006E   AA..         MOV     R2,?V2
   \   000070   AB..         MOV     R3,?V3
   \   000072   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   3880                reportRec->attrData = dataPtr;
   \   00007A   12....       LCALL   ?Subroutine20 & 0xFFFF
   3881          
   3882                pBuf += attrDataLen; // move pass attribute data
   3883          
   3884                // advance attribute data pointer
   3885                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_374:
   \   00007D   5007         JNC     ??zclParseInReportCmd_6
   3886                {
   3887                  attrDataLen++;
   \   00007F   05..         INC     ?V0
   \   000081   04           INC     A
   \   000082   7002         JNZ     ??zclParseInReportCmd_6
   \   000084   05..         INC     ?V1
   3888                }
   3889          
   3890                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_6:
   \   000086   12....       LCALL   ?Subroutine121 & 0xFFFF
   3891              }
   \                     ??CrossCallReturnLabel_214:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40BE         JC      ??zclParseInReportCmd_4
   3892            }
   3893          
   3894            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   000090                REQUIRE ?Subroutine6
   \   000090                ; // Fall through to label ?Subroutine6
   3895          }
   3896          #endif // ZCL_REPORT
   3897          
   3898          /*********************************************************************
   3899           * @fn      zclParseInDefaultRspCmd
   3900           *
   3901           * @brief   Parse the "Profile" Default Response Command
   3902           *
   3903           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3904           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3905           *
   3906           * @param   pCmd - pointer to incoming data to parse
   3907           *
   3908           * @return  pointer to the parsed command structure
   3909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3910          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3911          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3912            zclDefaultRspCmd_t *defaultRspCmd;
   3913            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine108 & 0xFFFF
   3914          
   3915            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_179:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3916            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   600B         JZ      ??zclParseInDefaultRspCmd_0
   3917            {
   3918              defaultRspCmd->commandID = *pBuf++;
   \   00001A   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   00001D   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   3919              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_312:
   \   000020   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   3920            }
   \                     ??CrossCallReturnLabel_425:
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   3921          
   3922            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000025   02....       LJMP    ?Subroutine2 & 0xFFFF
   3923          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   000003   22           RET
   3924          
   3925          #ifdef ZCL_DISCOVER
   3926          /*********************************************************************
   3927           * @fn      zclParseInDiscAttrsCmd
   3928           *
   3929           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3930           *
   3931           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3932           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3933           *
   3934           * @param   pCmd - pointer to incoming data to parse
   3935           *
   3936           * @return  pointer to the parsed command structure
   3937           */
   3938          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3939          {
   3940            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3941            uint8 *pBuf = pCmd->pData;
   3942          
   3943            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3944            if ( pDiscoverCmd != NULL )
   3945            {
   3946              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3947              pBuf += 2;
   3948              pDiscoverCmd->maxAttrIDs = *pBuf;
   3949            }
   3950          
   3951            return ( (void *)pDiscoverCmd );
   3952          }
   3953          
   3954          /*********************************************************************
   3955           * @fn      zclParseInDiscAttrsRspCmd
   3956           *
   3957           * @brief   Parse the "Profile" Discovery Response Commands
   3958           *
   3959           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3960           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3961           *
   3962           * @param   pCmd - pointer to incoming data to parse
   3963           *
   3964           * @return  pointer to the parsed command structure
   3965           */
   3966          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3967          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3968          {
   3969            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3970            uint8 *pBuf = pCmd->pData;
   3971            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3972          
   3973            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3974                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3975          
   3976            if ( pDiscoverRspCmd != NULL )
   3977            {
   3978              uint8 i;
   3979          
   3980              pDiscoverRspCmd->discComplete = *pBuf++;
   3981              pDiscoverRspCmd->numAttr = numAttr;
   3982          
   3983              for ( i = 0; i < numAttr; i++ )
   3984              {
   3985                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3986                pBuf += 2;
   3987                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3988              }
   3989            }
   3990          
   3991            return ( (void *)pDiscoverRspCmd );
   3992          }
   3993          
   3994          /*********************************************************************
   3995           * @fn      zclParseInDiscCmdsCmd
   3996           *
   3997           * @brief   Parse the "Profile" Discovery Commands
   3998           *
   3999           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4000           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4001           *
   4002           * @param   pCmd - pointer to incoming data to parse
   4003           *
   4004           * @return  pointer to the parsed command structure
   4005           */
   4006          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4007          {
   4008            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4009            uint8 *pBuf = pCmd->pData;
   4010          
   4011            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4012            if ( pDiscoverCmd != NULL )
   4013            {
   4014              pDiscoverCmd->startCmdID = *pBuf++;
   4015              pDiscoverCmd->maxCmdID = *pBuf++;
   4016            }
   4017          
   4018            return ( (void *)pDiscoverCmd );
   4019          }
   4020          
   4021          /*********************************************************************
   4022           * @fn      zclParseInDiscCmdsRspCmd
   4023           *
   4024           * @brief   Parse the Discover Commands Response Command
   4025           *
   4026           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4027           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4028           *
   4029           * @param   pCmd - pointer to incoming data to parse
   4030           *
   4031           * @return  pointer to the parsed command structure
   4032           */
   4033          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4034          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4035          {
   4036            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4037            uint8 *pBuf = pCmd->pData;
   4038            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4039          
   4040              // allocate memory for size of structure plus variable array
   4041            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4042                              ( numCmds * sizeof(uint8) ) );
   4043            if ( pDiscoverRspCmd != NULL )
   4044            {
   4045              uint8 i;
   4046              pDiscoverRspCmd->discComplete = *pBuf++;
   4047              pDiscoverRspCmd->numCmd = numCmds;
   4048          
   4049              for ( i = 0; i < numCmds; i++ )
   4050              {
   4051                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4052              }
   4053            }
   4054          
   4055            return ( (void *)pDiscoverRspCmd );
   4056          }
   4057          
   4058          /*********************************************************************
   4059           * @fn      zclParseInDiscAttrsExtRspCmd
   4060           *
   4061           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4062           *
   4063           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4064           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4065           *
   4066           * @param   pCmd - pointer to incoming data to parse
   4067           *
   4068           * @return  pointer to the parsed command structure
   4069           */
   4070          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4071          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4072          {
   4073            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4074            uint8 i;
   4075            uint8 *pBuf = pCmd->pData;
   4076            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4077          
   4078            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4079                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4080          
   4081            if ( pDiscoverRspCmd != NULL )
   4082            {
   4083              pDiscoverRspCmd->discComplete = *pBuf++;
   4084              pDiscoverRspCmd->numAttr = numAttrs;
   4085          
   4086              for ( i = 0; i < numAttrs; i++ )
   4087              {
   4088                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4089                pBuf += 2;
   4090                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4091                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4092              }
   4093            }
   4094          
   4095            return ( (void *)pDiscoverRspCmd );
   4096          }
   4097          #endif // ZCL_DISCOVER
   4098          
   4099          #ifdef ZCL_READ
   4100          /*********************************************************************
   4101           * @fn      zclProcessInReadCmd
   4102           *
   4103           * @brief   Process the "Profile" Read Command
   4104           *
   4105           * @param   pInMsg - incoming message to process
   4106           *
   4107           * @return  TRUE if command processed. FALSE, otherwise.
   4108           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine186_0
   \   000004                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4109          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4110          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4111            zclReadCmd_t *readCmd;
   4112            zclReadRspCmd_t *readRspCmd;
   4113            zclAttrRec_t attrRec;
   4114            uint16 len;
   4115            uint8 i;
   4116          
   4117            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V10,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V11,A
   4118          
   4119            // calculate the length of the response status record
   4120            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4121          
   4122            readRspCmd = zcl_mem_alloc( len );
   \   00001E                ; Setup parameters for call to function osal_mem_alloc
   \   00001E   85..82       MOV     DPL,?V10
   \   000021   F583         MOV     DPH,A
   \   000023   E0           MOVX    A,@DPTR
   \   000024   75F006       MOV     B,#0x6
   \   000027   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_505:
   \   00002A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV     ?V0,R2
   \   00002F   8B..         MOV     ?V1,R3
   4123            if ( readRspCmd == NULL )
   \   000031   EA           MOV     A,R2
   \   000032   45..         ORL     A,?V1
   \   000034   7005         JNZ     ??zclProcessInReadCmd_0
   4124            {
   4125              return FALSE; // EMBEDDED RETURN
   \   000036   7900         MOV     R1,#0x0
   \   000038   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4126            }
   4127          
   4128            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   00003B   85..82       MOV     DPL,?V10
   \   00003E   85..83       MOV     DPH,?V11
   \   000041   12....       LCALL   ?Subroutine100 & 0xFFFF
   4129            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_167:
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   800B         SJMP    ??zclProcessInReadCmd_2
   4130            {
   4131              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4132          
   4133              statusRec->attrID = readCmd->attrID[i];
   4134          
   4135              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4136                                   readCmd->attrID[i], &attrRec ) )
   4137              {
   4138                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4139                {
   4140                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4141                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4142                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4143                  {
   4144                    statusRec->data = attrRec.attr.dataPtr;
   4145                    statusRec->dataType = attrRec.attr.dataType;
   4146                  }
   4147                }
   4148                else
   4149                {
   4150                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4151                }
   4152              }
   4153              else
   4154              {
   4155                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000049   85..82       MOV     DPL,?V6
   \   00004C   85..83       MOV     DPH,?V7
   \   00004F   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000051   F0           MOVX    @DPTR,A
   4156              }
   \                     ??zclProcessInReadCmd_5:
   \   000052   05..         INC     ?V2
   \                     ??zclProcessInReadCmd_2:
   \   000054   85..82       MOV     DPL,?V10
   \   000057   85..83       MOV     DPH,?V11
   \   00005A   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_457:
   \   00005D   4003         JC      $+5
   \   00005F   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   000062   85..82       MOV     DPL,?V2
   \   000065   A882         MOV     R0,DPL
   \   000067   E8           MOV     A,R0
   \   000068   75F006       MOV     B,#0x6
   \   00006B   A4           MUL     AB
   \   00006C   FA           MOV     R2,A
   \   00006D   ABF0         MOV     R3,B
   \   00006F   E5..         MOV     A,?V0
   \   000071   2A           ADD     A,R2
   \   000072   F582         MOV     DPL,A
   \   000074   E5..         MOV     A,?V1
   \   000076   3B           ADDC    A,R3
   \   000077   F583         MOV     DPH,A
   \   000079   A3           INC     DPTR
   \   00007A   8582..       MOV     ?V4,DPL
   \   00007D   8583..       MOV     ?V5,DPH
   \   000080   E8           MOV     A,R0
   \   000081   28           ADD     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   E4           CLR     A
   \   000084   33           RLC     A
   \   000085   F9           MOV     R1,A
   \   000086   E5..         MOV     A,?V10
   \   000088   28           ADD     A,R0
   \   000089   F582         MOV     DPL,A
   \   00008B   E5..         MOV     A,?V11
   \   00008D   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000090   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000093   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_468:
   \   000096   E5..         MOV     A,?V4
   \   000098   2402         ADD     A,#0x2
   \   00009A   F5..         MOV     ?V6,A
   \   00009C   E4           CLR     A
   \   00009D   35..         ADDC    A,?V5
   \   00009F   F5..         MOV     ?V7,A
   \   0000A1   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_479:
   \   0000A4                ; Setup parameters for call to function zclFindAttrRec
   \   0000A4   A8..         MOV     R0,?XSP + 0
   \   0000A6   A9..         MOV     R1,?XSP + 1
   \   0000A8   88..         MOV     ?V12,R0
   \   0000AA   89..         MOV     ?V13,R1
   \   0000AC   78..         MOV     R0,#?V12
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   8B83         MOV     DPH,R3
   \   0000B5   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000B8   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000BB   7402         MOV     A,#0x2
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C0   E9           MOV     A,R1
   \   0000C1   6086         JZ      ??zclProcessInReadCmd_3
   \   0000C3   7405         MOV     A,#0x5
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000CB   5065         JNC     ??zclProcessInReadCmd_7
   \   0000CD   8E82         MOV     DPL,R6
   \   0000CF   8F83         MOV     DPH,R7
   \   0000D1   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   0000D4   2406         ADD     A,#0x6
   \   0000D6   F5..         MOV     ?V8,A
   \   0000D8   E4           CLR     A
   \   0000D9   39           ADDC    A,R1
   \   0000DA   F5..         MOV     ?V9,A
   \   0000DC   7405         MOV     A,#0x5
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000E4   5020         JNC     ??zclProcessInReadCmd_8
   \   0000E6                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000E6   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000E9   12....       LCALL   ??zclGetAuthorizeCB?relay; Banked call to: zclGetAuthorizeCB
   \   0000EC   8A82         MOV     DPL,R2
   \   0000EE   8B83         MOV     DPH,R3
   \   0000F0   E582         MOV     A,DPL
   \   0000F2   4583         ORL     A,DPH
   \   0000F4   6010         JZ      ??zclProcessInReadCmd_8
   \   0000F6                ; Setup parameters for indirect call
   \   0000F6   7901         MOV     R1,#0x1
   \   0000F8   AC..         MOV     R4,?XSP + 0
   \   0000FA   AD..         MOV     R5,?XSP + 1
   \   0000FC   AA..         MOV     R2,?V8
   \   0000FE   AB..         MOV     R3,?V9
   \   000100   12....       LCALL   ?CALL_IND
   \   000103   E9           MOV     A,R1
   \   000104   8001         SJMP    ??zclProcessInReadCmd_9
   \                     ??zclProcessInReadCmd_8:
   \   000106   E4           CLR     A
   \                     ??zclProcessInReadCmd_9:
   \   000107   85..82       MOV     DPL,?V6
   \   00010A   85..83       MOV     DPH,?V7
   \   00010D   F0           MOVX    @DPTR,A
   \   00010E   6003         JZ      $+5
   \   000110   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000113   7406         MOV     A,#0x6
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000120   7404         MOV     A,#0x4
   \   000122   12....       LCALL   ?XSTACK_DISP0_8
   \   000125   E0           MOVX    A,@DPTR
   \   000126   85..82       MOV     DPL,?V4
   \   000129   85..83       MOV     DPH,?V5
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   000132   85..82       MOV     DPL,?V6
   \   000135   85..83       MOV     DPH,?V7
   \   000138   748F         MOV     A,#-0x71
   \   00013A   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4157            }
   4158          
   4159            // Build and send Read Response command
   4160            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4161                             readRspCmd, !pInMsg->hdr.fc.direction,
   4162                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00013D   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_480:
   \   000140                ; Setup parameters for call to function zcl_SendReadRsp
   \   000140   8E82         MOV     DPL,R6
   \   000142   8F83         MOV     DPH,R7
   \   000144   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014A   75..01       MOV     ?V2,#0x1
   \   00014D   78..         MOV     R0,#?V2
   \   00014F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000152   8E82         MOV     DPL,R6
   \   000154   8F83         MOV     DPH,R7
   \   000156   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_482:
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015C   78..         MOV     R0,#?V0
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000161   85..82       MOV     DPL,?V8
   \   000164   85..83       MOV     DPH,?V9
   \   000167   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   00016A   E5..         MOV     A,?V8
   \   00016C   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   00016F   35..         ADDC    A,?V9
   \   000171   FB           MOV     R3,A
   \   000172   E5..         MOV     A,?V8
   \   000174   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000177   35..         ADDC    A,?V9
   \   000179   F583         MOV     DPH,A
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   F9           MOV     R1,A
   \   00017D   12....       LCALL   ??zcl_SendReadRsp?relay; Banked call to: zcl_SendReadRsp
   \   000180   7405         MOV     A,#0x5
   \   000182   12....       LCALL   ?DEALLOC_XSTACK8
   4163            zcl_mem_free( readRspCmd );
   \   000185                ; Setup parameters for call to function osal_mem_free
   \   000185   AA..         MOV     R2,?V0
   \   000187   AB..         MOV     R3,?V1
   \   000189   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4164          
   4165            return TRUE;
   \   00018C   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   00018E   740A         MOV     A,#0xa
   \   000190   02....       LJMP    ?Subroutine11 & 0xFFFF
   4166          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine203_0
   \   000006                ; // Fall through to label ??Subroutine203_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine206_0
   \   000002                ; // Fall through to label ??Subroutine206_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine207_0
   \   000004                ; // Fall through to label ??Subroutine207_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_509:
   \   000003   85..82       MOV     DPL,?V8
   \   000006   85..83       MOV     DPH,?V9
   \   000009   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00000C   E5..         MOV     A,?V8
   \   00000E   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000011   35..         ADDC    A,?V9
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine208_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine209_0
   \   000002                ; // Fall through to label ??Subroutine209_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine211_0:
   \   000000   2406         ADD     A,#0x6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   22           RET
   4167          #endif // ZCL_READ
   4168          
   4169          #ifdef ZCL_WRITE
   4170          /*********************************************************************
   4171           * @fn      processInWriteCmd
   4172           *
   4173           * @brief   Process the "Profile" Write and Write No Response Commands
   4174           *
   4175           * @param   pInMsg - incoming message to process
   4176           *
   4177           * @return  TRUE if command processed. FALSE, otherwise.
   4178           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V5
   \   00000A   F583         MOV     DPH,A
   \   00000C                REQUIRE ??Subroutine198_0
   \   00000C                ; // Fall through to label ??Subroutine198_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009   85..82       MOV     DPL,?V4
   \   00000C   85..83       MOV     DPH,?V5
   \   00000F                REQUIRE ??Subroutine202_0
   \   00000F                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4179          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4180          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4181            zclWriteCmd_t *writeCmd;
   4182            zclWriteRspCmd_t *writeRspCmd;
   4183            uint8 sendRsp = FALSE;
   \   00000E   7F00         MOV     R7,#0x0
   4184            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine99 & 0xFFFF
   4185            uint8 i;
   4186          
   4187            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_401:
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   4188            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_469:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6402         XRL     A,#0x2
   \   00002A   701B         JNZ     ??zclProcessInWriteCmd_0
   4189            {
   4190              // We need to send a response back - allocate space for it
   4191              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4192                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002C                ; Setup parameters for call to function osal_mem_alloc
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000035   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000038   8A..         MOV     ?V0,R2
   \   00003A   8B..         MOV     ?V1,R3
   4193              if ( writeRspCmd == NULL )
   \   00003C   EA           MOV     A,R2
   \   00003D   45..         ORL     A,?V1
   \   00003F   7005         JNZ     ??zclProcessInWriteCmd_1
   4194              {
   4195                return FALSE; // EMBEDDED RETURN
   \   000041   7900         MOV     R1,#0x0
   \   000043   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4196              }
   4197          
   4198              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000046   0F           INC     R7
   4199            }
   4200          
   4201            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000047   8E..         MOV     ?V6,R6
   \   000049   801C         SJMP    ??zclProcessInWriteCmd_3
   4202            {
   4203              zclAttrRec_t attrRec;
   4204              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4205          
   4206              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4207                                   statusRec->attrID, &attrRec ) )
   4208              {
   4209                if ( statusRec->dataType == attrRec.attr.dataType )
   4210                {
   4211                  uint8 status;
   4212          
   4213                  // Write the new attribute value
   4214                  if ( attrRec.attr.dataPtr != NULL )
   4215                  {
   4216                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4217                                               &attrRec, statusRec );
   4218                  }
   4219                  else // Use CB
   4220                  {
   4221                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4222                                                      &attrRec, statusRec->attrData );
   4223                  }
   4224          
   4225                  // If successful, a write attribute status record shall NOT be generated
   4226                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4227                  {
   4228                    // Attribute is read only - move on to the next write attribute record
   4229                    writeRspCmd->attrList[j].status = status;
   4230                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4231                  }
   4232                }
   4233                else
   4234                {
   4235                  // Attribute data type is incorrect - move on to the next write attribute record
   4236                  if ( sendRsp )
   4237                  {
   4238                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4239                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4240                  }
   4241                }
   4242              }
   4243              else
   4244              {
   4245                // Attribute is not supported - move on to the next write attribute record
   4246                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   00004B   EF           MOV     A,R7
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   5015         JNC     ??zclProcessInWriteCmd_5
   4247                {
   4248                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000050   85..82       MOV     DPL,?V14
   \   000053   85..83       MOV     DPH,?V15
   \   000056   7486         MOV     A,#-0x7a
   4249                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4250                }
   4251              }
   \                     ??zclProcessInWriteCmd_6:
   \   000058   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00005B   85..82       MOV     DPL,?V12
   \   00005E   85..83       MOV     DPH,?V13
   \   000061   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   000064   0E           INC     R6
   \                     ??zclProcessInWriteCmd_5:
   \   000065   05..         INC     ?V6
   \                     ??zclProcessInWriteCmd_3:
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000070   E5..         MOV     A,?V6
   \   000072   C3           CLR     C
   \   000073   98           SUBB    A,R0
   \   000074   4003         JC      $+5
   \   000076   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \   000079   E5..         MOV     A,?V6
   \   00007B   75F005       MOV     B,#0x5
   \   00007E   A4           MUL     AB
   \   00007F   F8           MOV     R0,A
   \   000080   A9F0         MOV     R1,B
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00008B   EE           MOV     A,R6
   \   00008C   75F003       MOV     B,#0x3
   \   00008F   A4           MUL     AB
   \   000090   F8           MOV     R0,A
   \   000091   A9F0         MOV     R1,B
   \   000093   E5..         MOV     A,?V0
   \   000095   28           ADD     A,R0
   \   000096   F582         MOV     DPL,A
   \   000098   E5..         MOV     A,?V1
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   E582         MOV     A,DPL
   \   00009F   2402         ADD     A,#0x2
   \   0000A1   F5..         MOV     ?V12,A
   \   0000A3   E4           CLR     A
   \   0000A4   3583         ADDC    A,DPH
   \   0000A6   F5..         MOV     ?V13,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   8582..       MOV     ?V14,DPL
   \   0000AC   8583..       MOV     ?V15,DPH
   \   0000AF   85..82       MOV     DPL,?V4
   \   0000B2   85..83       MOV     DPH,?V5
   \   0000B5   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   0000B8                ; Setup parameters for call to function zclFindAttrRec
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?XSTACK_DISP100_8
   \   0000BD   88..         MOV     ?V10,R0
   \   0000BF   89..         MOV     ?V11,R1
   \   0000C1   78..         MOV     R0,#?V10
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C6   85..82       MOV     DPL,?V2
   \   0000C9   85..83       MOV     DPH,?V3
   \   0000CC   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000CF   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000D2   7402         MOV     A,#0x2
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D7   E9           MOV     A,R1
   \   0000D8   7003         JNZ     $+5
   \   0000DA   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000DD   85..82       MOV     DPL,?V2
   \   0000E0   85..83       MOV     DPH,?V3
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F8           MOV     R0,A
   \   0000E7   7406         MOV     A,#0x6
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   68           XRL     A,R0
   \   0000EE   7071         JNZ     ??zclProcessInWriteCmd_8
   \   0000F0   85..82       MOV     DPL,?V4
   \   0000F3   85..83       MOV     DPH,?V5
   \   0000F6   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   0000F9   2414         ADD     A,#0x14
   \   0000FB   F5..         MOV     ?V8,A
   \   0000FD   E4           CLR     A
   \   0000FE   39           ADDC    A,R1
   \   0000FF   F5..         MOV     ?V9,A
   \   000101   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   000104   39           ADDC    A,R1
   \   000105   FB           MOV     R3,A
   \   000106   7408         MOV     A,#0x8
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   00010E   6017         JZ      ??zclProcessInWriteCmd_9
   \   000110                ; Setup parameters for call to function zclWriteAttrData
   \   000110   78..         MOV     R0,#?V2
   \   000112   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?XSTACK_DISP102_8
   \   00011A   85..82       MOV     DPL,?V8
   \   00011D   85..83       MOV     DPH,?V9
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData
   \   000125   801C         SJMP    ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   000127                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000127   85..82       MOV     DPL,?V2
   \   00012A   85..83       MOV     DPH,?V3
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000133   7404         MOV     A,#0x4
   \   000135   12....       LCALL   ?XSTACK_DISP102_8
   \   000138   85..82       MOV     DPL,?V8
   \   00013B   85..83       MOV     DPH,?V9
   \   00013E   E0           MOVX    A,@DPTR
   \   00013F   F9           MOV     R1,A
   \   000140   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_10:
   \   000143   7402         MOV     A,#0x2
   \   000145   12....       LCALL   ?DEALLOC_XSTACK8
   \   000148   E9           MOV     A,R1
   \   000149   F8           MOV     R0,A
   \   00014A   EF           MOV     A,R7
   \   00014B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00014D   4003         JC      $+5
   \   00014F   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000152   E8           MOV     A,R0
   \   000153   7003         JNZ     $+5
   \   000155   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000158   85..82       MOV     DPL,?V14
   \   00015B   85..83       MOV     DPH,?V15
   \   00015E   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteCmd_8:
   \   000161   EF           MOV     A,R7
   \   000162   A2E0         MOV     C,0xE0 /* A   */.0
   \   000164   4003         JC      $+5
   \   000166   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000169   85..82       MOV     DPL,?V14
   \   00016C   85..83       MOV     DPH,?V15
   \   00016F   748D         MOV     A,#-0x73
   \   000171   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   4252            } // for loop
   4253          
   4254            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   000174   EF           MOV     A,R7
   \   000175   A2E0         MOV     C,0xE0 /* A   */.0
   \   000177   5038         JNC     ??zclProcessInWriteCmd_11
   4255            {
   4256              writeRspCmd->numAttr = j;
   \   000179   EE           MOV     A,R6
   \   00017A   85..82       MOV     DPL,?V0
   \   00017D   85..83       MOV     DPH,?V1
   \   000180   F0           MOVX    @DPTR,A
   4257              if ( writeRspCmd->numAttr == 0 )
   \   000181   7003         JNZ     ??CrossCallReturnLabel_48
   4258              {
   4259                // Since all records were written successful, include a single status record
   4260                // in the resonse command with the status field set to SUCCESS and the
   4261                // attribute ID field omitted.
   4262                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000183   12....       LCALL   ?Subroutine44 & 0xFFFF
   4263                writeRspCmd->numAttr = 1;
   4264              }
   4265          
   4266              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4267                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4268                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_48:
   \   000186   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   000189   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018C   75..01       MOV     ?V2,#0x1
   \   00018F   78..         MOV     R0,#?V2
   \   000191   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000194   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   000197   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00019A   78..         MOV     R0,#?V0
   \   00019C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019F   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   0001A2   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0001A5   7405         MOV     A,#0x5
   \   0001A7   12....       LCALL   ?DEALLOC_XSTACK8
   4269              zcl_mem_free( writeRspCmd );
   \   0001AA                ; Setup parameters for call to function osal_mem_free
   \   0001AA   AA..         MOV     R2,?V0
   \   0001AC   AB..         MOV     R3,?V1
   \   0001AE   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4270            }
   4271          
   4272            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0001B1   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   0001B3   740C         MOV     A,#0xc
   \   0001B5   02....       LJMP    ?Subroutine4 & 0xFFFF
   4273          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine208_0
   \   000006                ; // Fall through to label ??Subroutine208_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine211_0
   \   000001                ; // Fall through to label ??Subroutine211_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_507:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_511:
   \   000007   EE           MOV     A,R6
   \   000008   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   00000B   3F           ADDC    A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   EE           MOV     A,R6
   \   00000E   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000011   3F           ADDC    A,R7
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   8582..       MOV     ?V2,DPL
   \   00000E   8583..       MOV     ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   00000A   22           RET
   4274          
   4275          /*********************************************************************
   4276           * @fn      zclRevertWriteUndividedCmd
   4277           *
   4278           * @brief   Revert the "Profile" Write Undevided Command
   4279           *
   4280           * @param   pInMsg - incoming message to process
   4281           * @param   curWriteRec - old data
   4282           * @param   numAttr - number of attributes to be reverted
   4283           *
   4284           * @return  none
   4285           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4286          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4287                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4288          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   4289            uint8 i;
   4290          
   4291            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   741E         MOV     A,#0x1e
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   00001D   8030         SJMP    ??zclRevertWriteUndividedCmd_0
   4292            {
   4293              zclAttrRec_t attrRec;
   4294              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4295          
   4296              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4297                                    statusRec->attrID, &attrRec ) )
   4298              {
   4299                break; // should never happen
   4300              }
   4301          
   4302              if ( attrRec.attr.dataPtr != NULL )
   4303              {
   4304                // Just copy the old data back - no need to validate the data
   4305                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4306                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4307              }
   4308              else // Use CB
   4309              {
   4310                // Write the old data back
   4311                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4312                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   85..83       MOV     DPH,?V3
   \   000025   12....       LCALL   ?Subroutine108 & 0xFFFF
   4313              }
   \                     ??CrossCallReturnLabel_180:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V4,R2
   \   00002A   8B..         MOV     ?V5,R3
   \   00002C   78..         MOV     R0,#?V4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   EE           MOV     A,R6
   \   000037   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_488:
   \   00003A   3F           ADDC    A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000040   3F           ADDC    A,R7
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004D   05..         INC     ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004F   85....       MOV     ?V4,?V0
   \   000052   C3           CLR     C
   \   000053   E5..         MOV     A,?V4
   \   000055   95..         SUBB    A,?V8
   \   000057   E4           CLR     A
   \   000058   95..         SUBB    A,?V9
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005F   E5..         MOV     A,?V0
   \   000061   75F005       MOV     B,#0x5
   \   000064   A4           MUL     AB
   \   000065   F8           MOV     R0,A
   \   000066   A9F0         MOV     R1,B
   \   000068   E5..         MOV     A,?V10
   \   00006A   28           ADD     A,R0
   \   00006B   FE           MOV     R6,A
   \   00006C   E5..         MOV     A,?V11
   \   00006E   39           ADDC    A,R1
   \   00006F   FF           MOV     R7,A
   \   000070   85..82       MOV     DPL,?V2
   \   000073   85..83       MOV     DPH,?V3
   \   000076   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000079   88..         MOV     ?V4,R0
   \   00007B   89..         MOV     ?V5,R1
   \   00007D                ; Setup parameters for call to function zclFindAttrRec
   \   00007D   A8..         MOV     R0,?XSP + 0
   \   00007F   A9..         MOV     R1,?XSP + 1
   \   000081   88..         MOV     ?V6,R0
   \   000083   89..         MOV     ?V7,R1
   \   000085   78..         MOV     R0,#?V6
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   8E82         MOV     DPL,R6
   \   00008C   8F83         MOV     DPH,R7
   \   00008E   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   000091   85..82       MOV     DPL,?V4
   \   000094   85..83       MOV     DPH,?V5
   \   000097   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   00009A   E5..         MOV     A,?V4
   \   00009C   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   00009F   35..         ADDC    A,?V5
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F9           MOV     R1,A
   \   0000A5   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AD   E9           MOV     A,R1
   \   0000AE   6045         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000B0   EE           MOV     A,R6
   \   0000B1   2403         ADD     A,#0x3
   \   0000B3   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   0000B6   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   0000B9   7406         MOV     A,#0x6
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   0000C1   EE           MOV     A,R6
   \   0000C2   4F           ORL     A,R7
   \   0000C3   7003         JNZ     $+5
   \   0000C5   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C8                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C8   7404         MOV     A,#0x4
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F9           MOV     R1,A
   \   0000CF   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000D2   8A..         MOV     ?V6,R2
   \   0000D4   8B..         MOV     ?V7,R3
   \   0000D6   AC..         MOV     R4,?V6
   \   0000D8   AD..         MOV     R5,?V7
   \   0000DA                ; Setup parameters for call to function osal_memcpy
   \   0000DA   85..82       MOV     DPL,?V4
   \   0000DD   85..83       MOV     DPH,?V5
   \   0000E0   12....       LCALL   ?Subroutine66 & 0xFFFF
   4314            } // for loop
   \                     ??CrossCallReturnLabel_102:
   \   0000E3   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E6   EE           MOV     A,R6
   \   0000E7   FA           MOV     R2,A
   \   0000E8   EF           MOV     A,R7
   \   0000E9   FB           MOV     R3,A
   \   0000EA   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000ED   7403         MOV     A,#0x3
   \   0000EF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F2   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4315          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F5   740A         MOV     A,#0xa
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FA   02....       LJMP    ??Subroutine168_0 & 0xFFFF
   4316          
   4317          /*********************************************************************
   4318           * @fn      zclProcessInWriteUndividedCmd
   4319           *
   4320           * @brief   Process the "Profile" Write Undivided Command
   4321           *
   4322           * @param   pInMsg - incoming message to process
   4323           *
   4324           * @return  TRUE if command processed. FALSE, otherwise.
   4325           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine182_0
   \   000006                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4326          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4327          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4328            zclWriteCmd_t *writeCmd;
   4329            zclWriteRspCmd_t *writeRspCmd;
   4330            zclAttrRec_t attrRec;
   4331            uint16 dataLen;
   4332            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V8,#0x0
   \   000011   75..00       MOV     ?V9,#0x0
   4333            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine99 & 0xFFFF
   4334            uint8 i;
   4335          
   4336            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_402:
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   4337          
   4338            // Allocate space for Write Response Command
   4339            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4340                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_471:
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   4341            if ( writeRspCmd == NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4342            {
   4343              return FALSE; // EMBEDDED RETURN
   4344            }
   4345          
   4346            // If any attribute cannot be written, no attribute values are changed. Hence,
   4347            // make sure all the attributes are supported and writable
   4348            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000036   7F00         MOV     R7,#0x0
   \   000038   8039         SJMP    ??zclProcessInWriteUndividedCmd_1
   4349            {
   4350              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4351          
   4352              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4353                                    statusRec->attrID, &attrRec ) )
   4354              {
   4355                // Attribute is not supported - stop here
   4356                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4357                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4358                break;
   4359              }
   4360          
   4361              if ( statusRec->dataType != attrRec.attr.dataType )
   4362              {
   4363                // Attribute data type is incorrect - stope here
   4364                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4365                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4366                break;
   4367              }
   4368          
   4369              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4370              {
   4371                // Attribute is not writable - stop here
   4372                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4373                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4374                break;
   4375              }
   4376          
   4377              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4378              {
   4379                // Not authorized to write - stop here
   4380                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4381                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4382                break;
   4383              }
   4384          
   4385              // Attribute Data length
   4386              if ( attrRec.attr.dataPtr != NULL )
   4387              {
   4388                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4389              }
   4390              else // Use CB
   4391              {
   4392                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4393                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00003A   12....       LCALL   ?Subroutine86 & 0xFFFF
   4394              }
   \                     ??CrossCallReturnLabel_139:
   \   00003D   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   000040   8882         MOV     DPL,R0
   \   000042   8983         MOV     DPH,R1
   \   000044   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   000047   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00004A   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   EA           MOV     A,R2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   EB           MOV     A,R3
   \   000057   12....       LCALL   ?Subroutine47 & 0xFFFF
   4395          
   4396              // add padding if needed
   4397              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_55:
   \   00005A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005C   5003         JNC     ??CrossCallReturnLabel_219
   4398              {
   4399                dataLen++;
   \   00005E   12....       LCALL   ?Subroutine125 & 0xFFFF
   4400              }
   4401          
   4402              curLen += dataLen;
   \                     ??CrossCallReturnLabel_219:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   25..         ADD     A,?V8
   \   00006A   F5..         MOV     ?V8,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   35..         ADDC    A,?V9
   \   000070   F5..         MOV     ?V9,A
   \   000072   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000073   7402         MOV     A,#0x2
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00007B   5043         JNC     ??zclProcessInWriteUndividedCmd_4
   \   00007D   EF           MOV     A,R7
   \   00007E   75F005       MOV     B,#0x5
   \   000081   A4           MUL     AB
   \   000082   F8           MOV     R0,A
   \   000083   A9F0         MOV     R1,B
   \   000085   7402         MOV     A,#0x2
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00008D   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000090   12....       LCALL   ?XSTACK_DISP100_8
   \   000093   88..         MOV     ?V10,R0
   \   000095   89..         MOV     ?V11,R1
   \   000097   78..         MOV     R0,#?V10
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00009F   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   E9           MOV     A,R1
   \   0000A8   7047         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000AA   85..82       MOV     DPL,?V0
   \   0000AD   85..83       MOV     DPH,?V1
   \   0000B0   A3           INC     DPTR
   \   0000B1   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000B3   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000B6   85..82       MOV     DPL,?V0
   \   0000B9   85..83       MOV     DPH,?V1
   \   0000BC   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   0000BF   0E           INC     R6
   4403            } // for loop
   4404          
   4405            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000C0   EE           MOV     A,R6
   \   0000C1   85..82       MOV     DPL,?V0
   \   0000C4   85..83       MOV     DPH,?V1
   \   0000C7   F0           MOVX    @DPTR,A
   4406            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000C8   6003         JZ      $+5
   \   0000CA   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4407            {
   4408              uint8 *curDataPtr;
   4409              zclWriteRec_t *curWriteRec;
   4410          
   4411              // calculate the length of the current data header
   4412              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000CD   75F005       MOV     B,#0x5
   \   0000D0   A4           MUL     AB
   \   0000D1   FF           MOV     R7,A
   4413          
   4414              // Allocate space to keep a copy of the current data
   4415              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000D2                ; Setup parameters for call to function osal_mem_alloc
   \   0000D2   25..         ADD     A,?V8
   \   0000D4   FA           MOV     R2,A
   \   0000D5   E4           CLR     A
   \   0000D6   35..         ADDC    A,?V9
   \   0000D8   FB           MOV     R3,A
   \   0000D9   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   0000DC   8A..         MOV     ?V14,R2
   \   0000DE   8B..         MOV     ?V15,R3
   4416              if ( curWriteRec == NULL )
   \   0000E0   EA           MOV     A,R2
   \   0000E1   45..         ORL     A,?V15
   \   0000E3   705C         JNZ     ??zclProcessInWriteUndividedCmd_8
   4417              {
   4418                zcl_mem_free(writeRspCmd );
   \   0000E5                ; Setup parameters for call to function osal_mem_free
   \   0000E5   AA..         MOV     R2,?V0
   \   0000E7   AB..         MOV     R3,?V1
   \   0000E9   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4419                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000EC   7900         MOV     R1,#0x0
   \   0000EE   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4420              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000F1   7408         MOV     A,#0x8
   \   0000F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F6   12....       LCALL   ??Subroutine215_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   0000F9   A3           INC     DPTR
   \   0000FA   A3           INC     DPTR
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   69           XRL     A,R1
   \   0000FD   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   0000FF   85..82       MOV     DPL,?V0
   \   000102   85..83       MOV     DPH,?V1
   \   000105   A3           INC     DPTR
   \   000106   748D         MOV     A,#-0x73
   \   000108   80A9         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00010A   7409         MOV     A,#0x9
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   A2E1         MOV     C,0xE0 /* A   */.1
   \   000112   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   000114   85..82       MOV     DPL,?V0
   \   000117   85..83       MOV     DPH,?V1
   \   00011A   A3           INC     DPTR
   \   00011B   7488         MOV     A,#-0x78
   \   00011D   8094         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   00011F   A2E5         MOV     C,0xE0 /* A   */.5
   \   000121   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   000123   85..82       MOV     DPL,?V0
   \   000126   85..83       MOV     DPH,?V1
   \   000129   A3           INC     DPTR
   \   00012A   747E         MOV     A,#0x7e
   \   00012C   8085         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   00012E   740A         MOV     A,#0xa
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000136   7003         JNZ     $+5
   \   000138   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00013B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00013B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00013E   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4421          
   4422              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000141   EA           MOV     A,R2
   \   000142   2F           ADD     A,R7
   \   000143   F5..         MOV     ?V8,A
   \   000145   E4           CLR     A
   \   000146   3B           ADDC    A,R3
   \   000147   F5..         MOV     ?V9,A
   4423          
   4424              // Write the new data over
   4425              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000149   7F00         MOV     R7,#0x0
   \   00014B   8022         SJMP    ??zclProcessInWriteUndividedCmd_13
   4426              {
   4427                uint8 status;
   4428                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4429                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4430          
   4431                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4432                                      statusRec->attrID, &attrRec ) )
   4433                {
   4434                  break; // should never happen
   4435                }
   4436          
   4437                // Keep a copy of the current data before before writing the new data over
   4438                curStatusRec->attrID = statusRec->attrID;
   4439                curStatusRec->attrData = curDataPtr;
   4440          
   4441                if ( attrRec.attr.dataPtr != NULL )
   4442                {
   4443                  // Read the current value
   4444                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4445          
   4446                  // Write the new attribute value
   4447                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4448                                             &attrRec, statusRec );
   4449                }
   4450                else // Use CBs
   4451                {
   4452                  // Read the current value
   4453                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4454                                          statusRec->attrID, curDataPtr, &dataLen );
   4455                  // Write the new attribute value
   4456                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4457                                                    &attrRec, statusRec->attrData );
   4458                }
   4459          
   4460                // If successful, a write attribute status record shall NOT be generated
   4461                if ( status != ZCL_STATUS_SUCCESS )
   4462                {
   4463                  writeRspCmd->attrList[j].status = status;
   4464                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4465          
   4466                  // Since this write failed, we need to revert all the pervious writes
   4467                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4468                  break;
   4469                }
   4470          
   4471                // add padding if needed
   4472                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   00014D   85..82       MOV     DPL,?XSP + 0
   \   000150   85..83       MOV     DPH,?XSP + 1
   \   000153   E0           MOVX    A,@DPTR
   \   000154   A2E0         MOV     C,0xE0 /* A   */.0
   \   000156   5003         JNC     ??CrossCallReturnLabel_220
   4473                {
   4474                  dataLen++;
   \   000158   12....       LCALL   ?Subroutine125 & 0xFFFF
   4475                }
   4476          
   4477                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_220:
   \   00015B   85..82       MOV     DPL,?XSP + 0
   \   00015E   85..83       MOV     DPH,?XSP + 1
   \   000161   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000164   E5..         MOV     A,?V8
   \   000166   28           ADD     A,R0
   \   000167   F5..         MOV     ?V8,A
   \   000169   E5..         MOV     A,?V9
   \   00016B   39           ADDC    A,R1
   \   00016C   F5..         MOV     ?V9,A
   \   00016E   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   00016F   7402         MOV     A,#0x2
   \   000171   12....       LCALL   ?XSTACK_DISP0_8
   \   000174   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000177   4003         JC      $+5
   \   000179   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   00017C   EF           MOV     A,R7
   \   00017D   75F005       MOV     B,#0x5
   \   000180   A4           MUL     AB
   \   000181   F8           MOV     R0,A
   \   000182   A9F0         MOV     R1,B
   \   000184   7402         MOV     A,#0x2
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00018C   E5..         MOV     A,?V14
   \   00018E   28           ADD     A,R0
   \   00018F   F5..         MOV     ?V12,A
   \   000191   E5..         MOV     A,?V15
   \   000193   39           ADDC    A,R1
   \   000194   F5..         MOV     ?V13,A
   \   000196   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000199   12....       LCALL   ?XSTACK_DISP100_8
   \   00019C   88..         MOV     ?V10,R0
   \   00019E   89..         MOV     ?V11,R1
   \   0001A0   78..         MOV     R0,#?V10
   \   0001A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A5   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0001A8   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0001AB   7402         MOV     A,#0x2
   \   0001AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B0   E9           MOV     A,R1
   \   0001B1   7003         JNZ     $+5
   \   0001B3   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001B6   85..82       MOV     DPL,?V2
   \   0001B9   85..83       MOV     DPH,?V3
   \   0001BC   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   0001BF   85..82       MOV     DPL,?V12
   \   0001C2   85..83       MOV     DPH,?V13
   \   0001C5   E8           MOV     A,R0
   \   0001C6   F0           MOVX    @DPTR,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   E9           MOV     A,R1
   \   0001C9   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0001CC   E5..         MOV     A,?V8
   \   0001CE   F0           MOVX    @DPTR,A
   \   0001CF   A3           INC     DPTR
   \   0001D0   E5..         MOV     A,?V9
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   740A         MOV     A,#0xa
   \   0001D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D8   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   0001DB   6043         JZ      ??zclProcessInWriteUndividedCmd_16
   \   0001DD                ; Setup parameters for call to function zclReadAttrData
   \   0001DD   A8..         MOV     R0,?XSP + 0
   \   0001DF   A9..         MOV     R1,?XSP + 1
   \   0001E1   88..         MOV     ?V6,R0
   \   0001E3   89..         MOV     ?V7,R1
   \   0001E5   78..         MOV     R0,#?V6
   \   0001E7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001EA   7406         MOV     A,#0x6
   \   0001EC   12....       LCALL   ?XSTACK_DISP102_8
   \   0001EF   AA..         MOV     R2,?V8
   \   0001F1   AB..         MOV     R3,?V9
   \   0001F3   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   0001F6   7402         MOV     A,#0x2
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FB   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0001FE                ; Setup parameters for call to function zclWriteAttrData
   \   0001FE   78..         MOV     R0,#?V2
   \   000200   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000203   7406         MOV     A,#0x6
   \   000205   12....       LCALL   ?XSTACK_DISP102_8
   \   000208   E5..         MOV     A,?V6
   \   00020A   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   00020D   35..         ADDC    A,?V7
   \   00020F   FB           MOV     R3,A
   \   000210   E5..         MOV     A,?V6
   \   000212   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000215   35..         ADDC    A,?V7
   \   000217   F583         MOV     DPH,A
   \   000219   E0           MOVX    A,@DPTR
   \   00021A   F9           MOV     R1,A
   \   00021B   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData
   \   00021E   8039         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000220   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000223                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000223   A8..         MOV     R0,?XSP + 0
   \   000225   A9..         MOV     R1,?XSP + 1
   \   000227   88..         MOV     ?V10,R0
   \   000229   89..         MOV     ?V11,R1
   \   00022B   78..         MOV     R0,#?V10
   \   00022D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000230   78..         MOV     R0,#?V8
   \   000232   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000235   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000238   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   00023B   7404         MOV     A,#0x4
   \   00023D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000240   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000243   A3           INC     DPTR
   \   000244   A3           INC     DPTR
   \   000245   A3           INC     DPTR
   \   000246   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000249   7406         MOV     A,#0x6
   \   00024B   12....       LCALL   ?XSTACK_DISP102_8
   \   00024E   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   000251   39           ADDC    A,R1
   \   000252   FB           MOV     R3,A
   \   000253   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000256   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000259   7402         MOV     A,#0x2
   \   00025B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00025E   E9           MOV     A,R1
   \   00025F   FB           MOV     R3,A
   \   000260   EB           MOV     A,R3
   \   000261   7003         JNZ     $+5
   \   000263   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000266   EE           MOV     A,R6
   \   000267   75F003       MOV     B,#0x3
   \   00026A   A4           MUL     AB
   \   00026B   F8           MOV     R0,A
   \   00026C   A9F0         MOV     R1,B
   \   00026E   E5..         MOV     A,?V0
   \   000270   28           ADD     A,R0
   \   000271   F8           MOV     R0,A
   \   000272   E5..         MOV     A,?V1
   \   000274   39           ADDC    A,R1
   \   000275   F9           MOV     R1,A
   \   000276   EB           MOV     A,R3
   \   000277   8882         MOV     DPL,R0
   \   000279   8983         MOV     DPH,R1
   \   00027B   A3           INC     DPTR
   \   00027C   F0           MOVX    @DPTR,A
   \   00027D   85..82       MOV     DPL,?V2
   \   000280   85..83       MOV     DPH,?V3
   \   000283   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000286   EA           MOV     A,R2
   \   000287   F0           MOVX    @DPTR,A
   \   000288   A3           INC     DPTR
   \   000289   EB           MOV     A,R3
   \   00028A   F0           MOVX    @DPTR,A
   \   00028B   0E           INC     R6
   \   00028C                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   00028C   8F..         MOV     ?V2,R7
   \   00028E   75..00       MOV     ?V3,#0x0
   \   000291   78..         MOV     R0,#?V2
   \   000293   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000296   AC..         MOV     R4,?V14
   \   000298   AD..         MOV     R5,?V15
   \   00029A   AA..         MOV     R2,?V4
   \   00029C   AB..         MOV     R3,?V5
   \   00029E   12....       LCALL   ??zclRevertWriteUndividedCmd?relay; Banked call to: zclRevertWriteUndividedCmd
   \   0002A1   7402         MOV     A,#0x2
   \   0002A3   12....       LCALL   ?DEALLOC_XSTACK8
   4478              } // for loop
   4479          
   4480              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002A6   EE           MOV     A,R6
   \   0002A7   85..82       MOV     DPL,?V0
   \   0002AA   85..83       MOV     DPH,?V1
   \   0002AD   F0           MOVX    @DPTR,A
   4481              if ( writeRspCmd->numAttr  == 0 )
   \   0002AE   7003         JNZ     ??CrossCallReturnLabel_49
   4482              {
   4483                // Since all records were written successful, include a single status record
   4484                // in the resonse command with the status field set to SUCCESS and the
   4485                // attribute ID field omitted.
   4486                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002B0   12....       LCALL   ?Subroutine44 & 0xFFFF
   4487                writeRspCmd->numAttr = 1;
   4488              }
   4489          
   4490              zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_49:
   \   0002B3                ; Setup parameters for call to function osal_mem_free
   \   0002B3   AA..         MOV     R2,?V14
   \   0002B5   AB..         MOV     R3,?V15
   \   0002B7   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4491            }
   4492          
   4493            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4494                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4495                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002BA   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   0002BD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C0   75..01       MOV     ?V2,#0x1
   \   0002C3   78..         MOV     R0,#?V2
   \   0002C5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C8   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   0002CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002CE   78..         MOV     R0,#?V0
   \   0002D0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D3   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   0002D6   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0002D9   7405         MOV     A,#0x5
   \   0002DB   12....       LCALL   ?DEALLOC_XSTACK8
   4496            zcl_mem_free( writeRspCmd );
   \   0002DE                ; Setup parameters for call to function osal_mem_free
   \   0002DE   AA..         MOV     R2,?V0
   \   0002E0   AB..         MOV     R3,?V1
   \   0002E2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4497          
   4498            return TRUE;
   \   0002E5   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0002E7   740E         MOV     A,#0xe
   \   0002E9                REQUIRE ?Subroutine4
   \   0002E9                ; // Fall through to label ?Subroutine4
   4499          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V6,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV     A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   EF           MOV     A,R7
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_508:
   \   000009   85..82       MOV     DPL,?V6
   \   00000C   85..83       MOV     DPH,?V7
   \   00000F   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   000012   E5..         MOV     A,?V6
   \   000014   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000017   35..         ADDC    A,?V7
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_HandleExternal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getParsedTransSeqNum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRecsList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAuthorizeCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAnalogDataType?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_BuildAnalogData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLengthUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAuthorizeWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclRevertWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4500          #endif // ZCL_WRITE
   4501          
   4502          #ifdef ZCL_DISCOVER
   4503          /*********************************************************************
   4504           * @fn      zclProcessInDiscAttrs
   4505           *
   4506           * @brief   Process the "Profile" Discover Attributes Commands
   4507           *
   4508           * @param   pInMsg - incoming message to process
   4509           *
   4510           * @return  TRUE if command processed. FALSE, otherwise.
   4511           */
   4512          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4513          {
   4514            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4515            zclAttrRec_t attrRec;
   4516            uint16 attrID;
   4517            uint8 numAttrs;
   4518            uint8 i;
   4519          
   4520            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4521          
   4522            // Find out the number of attributes supported within the specified range
   4523            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4524            {
   4525              // finds the next attribute on this endpoint/cluster after the range.
   4526              // attributes must be in numerical order in the list.
   4527              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4528              {
   4529                break;
   4530              }
   4531            }
   4532          
   4533            numAttrs = i;  // store range of attributes in buffer
   4534          
   4535              // Process message for either attributes or extended attributes
   4536            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4537            {
   4538              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4539            }
   4540            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4541            {
   4542              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4543            }
   4544          
   4545            return TRUE;
   4546          }
   4547          
   4548          /*********************************************************************
   4549           * @fn      zclProcessInDiscAttrsCmd
   4550           *
   4551           * @brief   Process the Discover Attributes Command
   4552           *
   4553           * @param   pInMsg - incoming message to process
   4554           *
   4555           * @param   pDiscoverCmd - structure from requesting command
   4556           *
   4557           * @param   attrLenBuf - describes the amount of attributes to be processed
   4558           *
   4559           * @return  none
   4560           */
   4561          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4562          {
   4563            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4564            uint8 discComplete = TRUE;
   4565            zclAttrRec_t attrRec;
   4566            uint16 attrID;
   4567            uint8 i;
   4568          
   4569            // Allocate space for the response command
   4570            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4571                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4572            if ( pDiscoverRsp == NULL )
   4573            {
   4574              return; // EMBEDDED RETURN
   4575            }
   4576          
   4577            if ( numAttrs != 0 )
   4578            {
   4579              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4580              {
   4581                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4582                {
   4583                  break; // should not happen, as numAttrs already calculated
   4584                }
   4585          
   4586                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4587                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4588              }
   4589          
   4590              // Are there more attributes to be discovered?
   4591              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4592              {
   4593                discComplete = FALSE;
   4594              }
   4595            }
   4596          
   4597            pDiscoverRsp->discComplete = discComplete;
   4598            pDiscoverRsp->numAttr = numAttrs;
   4599          
   4600            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4601                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4602                                         true, pInMsg->hdr.transSeqNum );
   4603            zcl_mem_free( pDiscoverRsp );
   4604          
   4605            return;
   4606          }
   4607          
   4608          /*********************************************************************
   4609           * @fn      zclProcessInDiscAttrsExtCmd
   4610           *
   4611           * @brief   Process the Discover Attributes Extended Command
   4612           *
   4613           * @param   pInMsg - incoming message to process
   4614           *
   4615           * @param   pDiscoverCmd - structure from requesting command
   4616           *
   4617           * @param   attrLenBuf - describes the amount of attributes to be processed
   4618           *
   4619           * @return  none
   4620           */
   4621          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4622          {
   4623            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4624            uint8 discComplete = TRUE;
   4625            zclAttrRec_t attrRec;
   4626            uint16 attrID;
   4627            uint8 i;
   4628          
   4629              // Allocate space for the response command
   4630            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4631                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4632            if ( pDiscoverExtRsp == NULL )
   4633            {
   4634              return; // EMBEDDED RETURN
   4635            }
   4636          
   4637          
   4638            if ( numAttrs != 0 )
   4639            {
   4640              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4641              {
   4642                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4643                {
   4644                  break; // Should not happen, as numAttrs already calculated
   4645                }
   4646          
   4647                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4648                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4649                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4650              }
   4651          
   4652              // Are there more attributes to be discovered?
   4653              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4654              {
   4655                discComplete = FALSE;
   4656              }
   4657            }
   4658          
   4659            pDiscoverExtRsp->discComplete = discComplete;
   4660            pDiscoverExtRsp->numAttr = numAttrs;
   4661          
   4662            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4663                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4664                                         true, pInMsg->hdr.transSeqNum );
   4665          
   4666            zcl_mem_free( pDiscoverExtRsp );
   4667          
   4668            return;
   4669          }
   4670          
   4671          /*********************************************************************
   4672           * @fn      zclProcessInDiscCmd
   4673           *
   4674           * @brief   Process the "Profile" Discover Command
   4675           *
   4676           * @param   pInMsg - incoming message to process
   4677           *
   4678           * @return  TRUE if command processed. FALSE, otherwise.
   4679           */
   4680          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4681          {
   4682            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4683            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4684            ZStatus_t status;
   4685            zclCommandRec_t cmdRec;
   4686            uint8 cmdID;
   4687            uint8 i;
   4688            uint8 j;
   4689          
   4690            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4691          
   4692            // Find out the number of commands supported within the specified range
   4693            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4694            {
   4695              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4696              {
   4697                break;  // Command not supported
   4698              }
   4699            }
   4700          
   4701            // Allocate space for the response command
   4702            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4703          
   4704            if ( cmdRsp.pCmdID == NULL )
   4705            {
   4706              return FALSE; // EMBEDDED RETURN
   4707            }
   4708          
   4709            if ( i != 0 )
   4710            {
   4711              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4712              {
   4713                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4714                {
   4715                  break; // Attribute not supported
   4716                }
   4717          
   4718                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4719              }
   4720            }
   4721          
   4722            // Are there more commands to be discovered?
   4723            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4724            {
   4725              cmdRsp.discComplete = FALSE;
   4726            }
   4727            else
   4728            {
   4729              cmdRsp.discComplete = TRUE;
   4730            }
   4731          
   4732            // pass the command requested
   4733            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4734          
   4735            // store number of commands returned
   4736            cmdRsp.numCmd = j;
   4737          
   4738            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4739                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4740                                                true, pInMsg->hdr.transSeqNum );
   4741          
   4742            zcl_mem_free( cmdRsp.pCmdID );
   4743          
   4744            if ( status == ZSuccess )
   4745            {
   4746              return TRUE;
   4747            }
   4748            else
   4749            {
   4750              return FALSE;
   4751            }
   4752          }
   4753          
   4754          #endif // ZCL_DISCOVER
   4755          
   4756          /*********************************************************************
   4757          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     24   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     42   zclBuildHdr
      2     54   zclFindAttrRec
        0     14   -> zclFindAttrRecsList
      2     14   zclFindAttrRecsList
      0     19   zclFindClusterOption
      0     47   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     60   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     42   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     47   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     24   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     11   zclParseInConfigReportRspCmd
        0     11   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     37   zclProcessInReadCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     32   -> zclGetAuthorizeCB
        0     37   -> zcl_SendReadRsp
      1     41   zclProcessInWriteCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      1     43   zclProcessInWriteUndividedCmd
        0     38   -> osal_mem_alloc
        0     38   -> osal_mem_free
        0     40   -> zclFindAttrRec
        0     38   -> zclGetAttrDataLength
        0     38   -> zclGetAttrDataLengthUsingCB
        0     40   -> zclReadAttrData
        0     42   -> zclReadAttrDataUsingCB
        0     40   -> zclRevertWriteUndividedCmd
        0     40   -> zclWriteAttrData
        0     40   -> zclWriteAttrDataUsingCB
        0     43   -> zcl_SendWriteRsp
      0     58   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     62   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     73   zclRevertWriteUndividedCmd
        0     33   -> osal_memcpy
        0     32   -> zclFindAttrRec
        0     30   -> zclGetAttrDataLength
        0     32   -> zclWriteAttrDataUsingCB
      1     42   zclSerializeData
        0     18   -> osal_buffer_uint32
        0     17   -> osal_memcpy
      0     47   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     58   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     58   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      1     36   zcl_BuildAnalogData
        0     16   -> zclGetAttrDataLength
      0     64   zcl_DeviceOperational
        0     25   -> zclFindAttrRec
        0     25   -> zclReadAttrData
      1     10   zcl_HandleExternal
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption
        0     39   -> zcl_DeviceOperational
        0     44   -> zcl_SendDefaultRspCmd
      0     34   zcl_ReadAttrData
        0     28   -> zclFindAttrRec
        0     28   -> zclReadAttrData
        0     30   -> zclReadAttrDataUsingCB
      1     74   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     33   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     40   zcl_SendConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     40   zcl_SendReadReportCfgRspCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     37   zcl_SendWriteRequest
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     74   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      2      0   zcl_registerForMsg
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       9  ??Subroutine166_0
       6  ??Subroutine167_0
       5  ??Subroutine168_0
       7  ??Subroutine169_0
       1  ??Subroutine170_0
       4  ??Subroutine171_0
       6  ??Subroutine172_0
       4  ??Subroutine173_0
      12  ??Subroutine174_0
       9  ??Subroutine175_0
       9  ??Subroutine176_0
       8  ??Subroutine177_0
       5  ??Subroutine178_0
       7  ??Subroutine179_0
       6  ??Subroutine180_0
       5  ??Subroutine181_0
       8  ??Subroutine182_0
       1  ??Subroutine183_0
       3  ??Subroutine184_0
       4  ??Subroutine185_0
       6  ??Subroutine186_0
      12  ??Subroutine187_0
      36  ??Subroutine188_0
       9  ??Subroutine189_0
      14  ??Subroutine190_0
       3  ??Subroutine191_0
      13  ??Subroutine192_0
       7  ??Subroutine193_0
       9  ??Subroutine194_0
       8  ??Subroutine195_0
       1  ??Subroutine196_0
       5  ??Subroutine197_0
       4  ??Subroutine198_0
       5  ??Subroutine199_0
       6  ??Subroutine200_0
       5  ??Subroutine201_0
       6  ??Subroutine202_0
       6  ??Subroutine203_0
       6  ??Subroutine204_0
       7  ??Subroutine205_0
       6  ??Subroutine206_0
       8  ??Subroutine207_0
       2  ??Subroutine208_0
       8  ??Subroutine209_0
       5  ??Subroutine210_0
       5  ??Subroutine211_0
       1  ??Subroutine212_0
       2  ??Subroutine213_0
       4  ??Subroutine214_0
       9  ??Subroutine215_0
      10  ??Subroutine216_0
       5  ??Subroutine217_0
       6  ??zclAnalogDataType?relay
       6  ??zclAuthorizeWrite?relay
       6  ??zclBuildHdr?relay
       6  ??zclFindAttrRec?relay
       6  ??zclFindAttrRecsList?relay
       6  ??zclFindClusterOption?relay
       6  ??zclGetAttrDataLength?relay
       6  ??zclGetAttrDataLengthUsingCB?relay
       6  ??zclGetAuthorizeCB?relay
       6  ??zclGetClusterOption?relay
       6  ??zclGetDataTypeLength?relay
       6  ??zclGetReadWriteCB?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInConfigReportCmd?relay
       6  ??zclParseInConfigReportRspCmd?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadReportCfgCmd?relay
       6  ??zclParseInReadReportCfgRspCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInReportCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclReadAttrData?relay
       6  ??zclReadAttrDataUsingCB?relay
       6  ??zclRevertWriteUndividedCmd?relay
       6  ??zclSerializeData?relay
       6  ??zclSetSecurityOption?relay
       6  ??zclWriteAttrData?relay
       6  ??zclWriteAttrDataUsingCB?relay
       6  ??zcl_BuildAnalogData?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_HandleExternal?relay
       6  ??zcl_Init?relay
       6  ??zcl_ProcessMessageMSG?relay
       6  ??zcl_ReadAttrData?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendConfigReportCmd?relay
       6  ??zcl_SendConfigReportRspCmd?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadReportCfgCmd?relay
       6  ??zcl_SendReadReportCfgRspCmd?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendReportCmd?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getParsedTransSeqNum?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerAttrList?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerReadWriteCB?relay
       6  ??zcl_registerValidateAttrData?relay
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
       7  ?Subroutine100
       4  ?Subroutine101
      16  ?Subroutine102
       6  ?Subroutine103
      21  ?Subroutine104
       8  ?Subroutine105
      13  ?Subroutine106
       7  ?Subroutine107
       4  ?Subroutine108
      12  ?Subroutine109
       6  ?Subroutine11
      10  ?Subroutine110
       4  ?Subroutine111
      12  ?Subroutine112
      13  ?Subroutine113
      12  ?Subroutine114
      12  ?Subroutine115
      15  ?Subroutine116
      21  ?Subroutine117
      16  ?Subroutine118
       8  ?Subroutine119
       5  ?Subroutine12
      19  ?Subroutine120
      15  ?Subroutine121
      13  ?Subroutine122
      12  ?Subroutine123
       2  ?Subroutine124
       9  ?Subroutine125
       9  ?Subroutine126
      11  ?Subroutine127
       3  ?Subroutine128
      10  ?Subroutine129
      47  ?Subroutine13
       7  ?Subroutine130
       6  ?Subroutine131
      16  ?Subroutine132
       2  ?Subroutine133
       5  ?Subroutine134
       7  ?Subroutine135
      12  ?Subroutine136
       3  ?Subroutine137
       4  ?Subroutine138
      14  ?Subroutine139
       5  ?Subroutine14
       9  ?Subroutine140
      10  ?Subroutine141
      12  ?Subroutine142
       4  ?Subroutine143
       4  ?Subroutine144
       6  ?Subroutine145
       4  ?Subroutine146
      11  ?Subroutine147
       9  ?Subroutine148
       5  ?Subroutine149
      12  ?Subroutine15
       9  ?Subroutine150
       5  ?Subroutine151
      16  ?Subroutine152
      11  ?Subroutine153
       1  ?Subroutine154
       6  ?Subroutine155
       3  ?Subroutine156
       3  ?Subroutine157
       8  ?Subroutine158
       8  ?Subroutine159
      12  ?Subroutine16
      13  ?Subroutine160
       6  ?Subroutine161
       8  ?Subroutine162
       5  ?Subroutine163
       8  ?Subroutine164
       5  ?Subroutine165
       6  ?Subroutine17
       4  ?Subroutine18
      22  ?Subroutine19
       5  ?Subroutine2
      15  ?Subroutine20
      12  ?Subroutine21
      19  ?Subroutine22
      24  ?Subroutine23
      20  ?Subroutine24
      17  ?Subroutine25
      11  ?Subroutine26
       2  ?Subroutine27
       9  ?Subroutine28
      11  ?Subroutine29
       5  ?Subroutine3
       1  ?Subroutine30
       6  ?Subroutine31
      12  ?Subroutine32
       4  ?Subroutine33
      10  ?Subroutine34
       3  ?Subroutine35
      29  ?Subroutine36
      11  ?Subroutine37
      11  ?Subroutine38
       8  ?Subroutine39
       3  ?Subroutine4
      14  ?Subroutine40
       2  ?Subroutine41
       4  ?Subroutine42
       7  ?Subroutine43
      12  ?Subroutine44
      10  ?Subroutine45
       4  ?Subroutine46
       9  ?Subroutine47
      30  ?Subroutine48
       5  ?Subroutine49
       4  ?Subroutine5
       7  ?Subroutine50
       5  ?Subroutine51
       6  ?Subroutine52
      24  ?Subroutine53
      18  ?Subroutine54
       6  ?Subroutine55
      32  ?Subroutine56
       4  ?Subroutine57
       6  ?Subroutine58
      18  ?Subroutine59
       4  ?Subroutine6
       6  ?Subroutine60
       3  ?Subroutine61
      23  ?Subroutine62
      18  ?Subroutine63
      15  ?Subroutine64
       8  ?Subroutine65
       9  ?Subroutine66
      10  ?Subroutine67
       9  ?Subroutine68
      23  ?Subroutine69
       3  ?Subroutine7
       6  ?Subroutine70
      11  ?Subroutine71
       6  ?Subroutine72
      14  ?Subroutine73
      13  ?Subroutine74
      30  ?Subroutine75
      22  ?Subroutine76
       7  ?Subroutine77
      12  ?Subroutine78
       4  ?Subroutine79
       5  ?Subroutine8
       6  ?Subroutine80
      12  ?Subroutine81
       4  ?Subroutine82
       5  ?Subroutine83
      16  ?Subroutine84
      11  ?Subroutine85
      10  ?Subroutine86
      10  ?Subroutine87
       1  ?Subroutine88
       4  ?Subroutine89
       5  ?Subroutine9
       1  ?Subroutine90
      17  ?Subroutine91
       4  ?Subroutine92
      12  ?Subroutine93
      11  ?Subroutine94
       8  ?Subroutine95
       4  ?Subroutine96
       4  ?Subroutine97
       5  ?Subroutine98
      12  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
      60  zclAuthorizeWrite
      88  zclBuildHdr
      92  zclCmdTable
     131  zclFindAttrRec
      37  zclFindAttrRecsList
     103  zclFindClusterOption
      63  zclGetAttrDataLength
      98  zclGetAttrDataLengthUsingCB
      27  zclGetAuthorizeCB
      31  zclGetClusterOption
     166  zclGetDataTypeLength
      29  zclGetReadWriteCB
     199  zclParseHdr
     342  zclParseInConfigReportCmd
     120  zclParseInConfigReportRspCmd
      40  zclParseInDefaultRspCmd
     104  zclParseInReadCmd
      72  zclParseInReadReportCfgCmd
     342  zclParseInReadReportCfgRspCmd
     277  zclParseInReadRspCmd
     144  zclParseInReportCmd
     147  zclParseInWriteCmd
     107  zclParseInWriteRspCmd
     403  zclProcessInReadCmd
     440  zclProcessInWriteCmd
     745  zclProcessInWriteUndividedCmd
     109  zclReadAttrData
      92  zclReadAttrDataUsingCB
     253  zclRevertWriteUndividedCmd
     343  zclSerializeData
      46  zclSetSecurityOption
     154  zclWriteAttrData
     104  zclWriteAttrDataUsingCB
     126  zcl_BuildAnalogData
     123  zcl_DeviceOperational
     174  zcl_HandleExternal
      12  zcl_Init
    1091  zcl_ProcessMessageMSG
     131  zcl_ReadAttrData
       1  zcl_RegisteredMsgTaskID
     429  zcl_SendCommand
     339  zcl_SendConfigReportCmd
     251  zcl_SendConfigReportRspCmd
     136  zcl_SendDefaultRspCmd
     204  zcl_SendRead
     171  zcl_SendReadReportCfgCmd
     367  zcl_SendReadReportCfgRspCmd
     407  zcl_SendReadRsp
     201  zcl_SendReportCmd
     204  zcl_SendWriteRequest
     186  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
       9  zcl_getParsedTransSeqNum
      12  zcl_getRawAFMsg
      83  zcl_registerAttrList
      76  zcl_registerClusterOptionList
      24  zcl_registerForMsg
     105  zcl_registerPlugin
      62  zcl_registerReadWriteCB
      17  zcl_registerValidateAttrData

 
 12 457 bytes in segment BANKED_CODE
    354 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     14 bytes in segment XDATA_Z
 
 12 904 bytes of CODE  memory
     15 bytes of XDATA memory

Errors: none
Warnings: none
