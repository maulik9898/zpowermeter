###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             30/Oct/2015  18:26:20 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.cpp                    #
#    Command line       =  -f C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\..\Tools\f8wRouter.cfg (-DCPU32MHZ  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wConfig.cfg (-DZIGBEEPRO    #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wZCL.cfg                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.cpp -D SECURE=0 -D     #
#                          OSC32K_CRYSTAL_INSTALLED=FALSE -D HAL_KEY=FALSE    #
#                          -D HAL_BOARD_CC2530EB_REV17 -D TC_LINKKEY_JOIN -D  #
#                          NV_INIT -D xNV_RESTORE -D MULTICAST_ENABLED=FALSE  #
#                          -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D          #
#                          FEATURE_SYSTEM_STATS -lC                           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ -lA                     #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ --diag_suppress         #
#                          Pe001,Pa010 -o C:\Users\paolo\Documents\GitHub\zpo #
#                          wermeter\firmware\CC2530DB\RouterEB\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\ -I C:\Users\paolo\Documents\GitHub #
#                          \zpowermeter\firmware\CC2530DB\..\Source\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\ha\ -I                       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\zmain\ -I                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\target\CC2530EB\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\high_level\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\sing #
#                          le_chip\ -I C:\Users\paolo\Documents\GitHub\zpower #
#                          meter\firmware\CC2530DB\..\Components\mt\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\osal\include\ -I         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\saddr\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\sdata\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\af\ -I             #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\nwk\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sapi\ -I           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sec\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sys\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zcl\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zdo\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\ -I                 #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\f8w\ -Ohz --eec++   #
#    List file          =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\zcl.lst                  #
#    Object file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\Obj\zcl.r51                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\paolo\Documents\GitHub\zpowermeter\firmware\Components\stack\zcl\zcl.cpp
      1          
      2          #include "ZComDef.h"
      3          #include "AF.h"
      4          
      5          #include "zcl.h"

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant BufferData::~BufferData()
   \                     `?~BufferData`:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator delete(void *)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FA           MOV     R2,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   FB           MOV     R3,A
   \   00000F   12....       LCALL   `??operator delete?relay`; Banked call to: operator delete(void *)
   \   000012   D083         POP     DPH
   \   000014   D082         POP     DPL
   \   000016   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant bool BufferData::isValid()
   \                     ??isValid:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   49           ORL     A,R1
   \   000011   6004         JZ      ??isValid_1
   \   000013   D2F0         SETB    B.0
   \   000015   8002         SJMP    ??isValid_2
   \                     ??isValid_1:
   \   000017   C2F0         CLR     B.0
   \                     ??isValid_2:
   \   000019   A2F0         MOV     C,B.0
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \   __banked_func __xdata_reentrant ZclWriteRspCmd::~ZclWriteRspCmd()
   \                     `?~ZclWriteRspCmd`:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function operator delete(void *)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FA           MOV     R2,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FB           MOV     R3,A
   \   00000E   12....       LCALL   `??operator delete?relay`; Banked call to: operator delete(void *)
   \   000011   D083         POP     DPH
   \   000013   D082         POP     DPL
   \   000015   02....       LJMP    ?BRET
      6          #include "zcl_general.h"
      7          
      8          #if defined ( INTER_PAN )
      9            #include "stub_aps.h"
     10          #endif
     11          
     12          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     13          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     14          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     15          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     16          
     17          /*** Attribute Access Control ***/
     18          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     19          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     20          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     21          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     22          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     23          
     24          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     25          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     26          
     27          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     28                                                  (zclHdr).fc.manuSpecific == 0          && \
     29                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     30          
     31          // Commands that have corresponding responses
     32          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     33                                                  (cmd) == ZCL_CMD_WRITE                  || \
     34                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     35                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     36                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     37                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     38                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     39                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     40                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     41                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     42          
     43          /*********************************************************************
     44           * CONSTANTS
     45           */
     46          
     47          /*********************************************************************
     48           * TYPEDEFS
     49           */
     50          typedef struct zclLibPlugin
     51          {
     52            struct zclLibPlugin *next;
     53            uint16              startClusterID;    // starting cluster ID
     54            uint16              endClusterID;      // ending cluster ID
     55            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
     56          } zclLibPlugin_t;
     57          
     58          // Command record list
     59          typedef struct zclCmdRecsList
     60          {
     61            struct zclCmdRecsList *pNext;
     62            uint8                 endpoint;
     63            uint8                 numCommands;
     64            const zclCommandRec_t __code *pCmdRecs;
     65          } zclCmdRecsList_t;
     66          
     67          
     68          
     69          // Cluster option list item
     70          typedef struct zclClusterOptionList
     71          {
     72            struct zclClusterOptionList *next;
     73            uint8                       endpoint;   // Used to link it into the endpoint descriptor
     74            uint8                       numOptions; // Number of the following records
     75            zclOptionRec_t              *options;   // option records
     76          } zclClusterOptionList;
     77          
     78          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
     79          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
     80          
     81          typedef struct
     82          {
     83            zclParseInProfileCmd_t   pfnParseInProfile;
     84            zclProcessInProfileCmd_t pfnProcessInProfile;
     85          } zclCmdItems_t;
     86          
     87          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     88          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     89          
     90          // The task Id of the Application where the unprocessed Foundation Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
     91          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
     92          
     93          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     94          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     95          
     96          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     97          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     98          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     99          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    100          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    101          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    102          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    103          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    104          
    105          #if defined ( ZCL_DISCOVER )
    106            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    107          #endif
    108          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    109          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    110          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    111          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    112          
    113          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    114          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    115          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    116          
    117          #if defined ( ZCL_DISCOVER )
    118            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    119          #endif
    120          
    121          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    122          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    123          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    124          
    125          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    126          
    127          ZStatus_t zclReadAttrData( uint8 *pAttrData, struct zclAttrRec_t *pAttr, uint16 *pDataLen );
    128          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, struct zclAttrRec_t *pAttr );
    129          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    130          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    131          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,  struct zclAttrRec_t *pAttr, ZclWriteRec *pWriteRec );
    132          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, struct zclAttrRec_t *pAttr );
    133          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    134          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    135          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    136          
    137          #ifdef ZCL_REPORT
    138          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    139          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    140          #endif // ZCL_REPORT
    141          
    142          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    143          
    144          #ifdef ZCL_DISCOVER
    145          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    146          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    147          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    148          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    149          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    150          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    151          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    152          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    153          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    154          #endif // ZCL_DISCOVER
    155          
    156          /*********************************************************************
    157           * Parse Profile Command Function Table
    158           */
    159          

   \                                 In  segment CODE_C, align 1
    160          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zcl_HandleExternal?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zcl_HandleExternal?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   ....         DW ??zclParseInConfigReportCmd?relay
   \   00001A   ....         DW ??zcl_HandleExternal?relay
   \   00001C   ....         DW ??zclParseInConfigReportRspCmd?relay
   \   00001E   ....         DW ??zcl_HandleExternal?relay
   \   000020   ....         DW ??zclParseInReadReportCfgCmd?relay
   \   000022   ....         DW ??zcl_HandleExternal?relay
   \   000024   ....         DW ??zclParseInReadReportCfgRspCmd?relay
   \   000026   ....         DW ??zcl_HandleExternal?relay
   \   000028   ....         DW ??zclParseInReportCmd?relay
   \   00002A   ....         DW ??zcl_HandleExternal?relay
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zcl_HandleExternal?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    161          {
    162            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    163            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    164          
    165            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    166            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    167            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    168            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    169          
    170          #ifdef ZCL_REPORT
    171            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    172            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    173            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    174            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    175            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    176          #else
    177            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    178            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    179            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    180            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    181            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    182          #endif // ZCL_REPORT
    183          
    184            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    185          
    186          #ifdef ZCL_DISCOVER
    187            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    188            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    189            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    190            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    191            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    192            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    193            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    194            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    195            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    196            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    197            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    198          #else
    199            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    200            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    201            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    202            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    203            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    204            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    205            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    206            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    207            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    208            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    209            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    210          #endif // ZCL_DISCOVER
    211          };
    212          
    213          /*********************************************************************
    214           * PUBLIC FUNCTIONS
    215           *********************************************************************/
    216          
    217          /*********************************************************************
    218           * @fn          zcl_Init
    219           *
    220           * @brief       Initialization function for the zcl layer.
    221           *
    222           * @param       task_id - ZCL task id
    223           *
    224           * @return      none
    225           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    226          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    227          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    228            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    229          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    230          /*********************************************************************
    231           * @fn          zcl_event_loop
    232           *
    233           * @brief       Event Loop Processor for zcl.
    234           *
    235           * @param       task_id - task id
    236           * @param       events - event bitmap
    237           *
    238           * @return      unprocessed events
    239           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    240          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    241          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    242            uint8 *msgPtr;
    243          
    244            (void)task_id;  // Intentionally unreferenced parameter
    245          
    246            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    247            {
    248              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    249              while ( msgPtr != NULL )
    250              {
    251                uint8 dealloc = TRUE;
    252          
    253                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    254                {
    255                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??zcl_ProcessMessageMSG?relay; Banked call to: zcl_ProcessMessageMSG
    256                }
    257                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    258                {
    259                  // send it to another task to process.
    260                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    261                  dealloc = FALSE;
    262                }
    263          
    264                // Release the memory
    265                if ( dealloc )
    266                {
    267                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    268                }
    269          
    270                // Next
    271                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_msg_receive?relay; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    272              }
    273          
    274              // return unprocessed events
    275              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0
   \   00004F   E5..         MOV     A,?V1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    276            }
    277          
    278            // Discard unknown events
    279            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    280          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    281          /*********************************************************************
    282           * @fn      zcl_registerForMsg
    283           *
    284           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    285           *          messages that aren't processed to one task (if a task is
    286           *          registered).
    287           *
    288           * @param   taskId - task Id of the Application where commands will be sent to
    289           *
    290           * @return  TRUE if task registeration successful, FALSE otherwise
    291           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    292          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    293          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    294            // Allow only the first task
    295            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    296            {
    297              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    298          
    299              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    300            }
    301          
    302            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    303          }
    304          /*********************************************************************
    305           * @fn      zcl_HandleExternal
    306           *
    307           * @brief
    308           *
    309           * @param   pInMsg - incoming message to process
    310           *
    311           * @return  TRUE
    312           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    313          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    314          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    315            zclIncomingMsg_t *pCmd;
    316          
    317            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    318            {
    319              return ( TRUE );
    320            }
    321          
    322            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_msg_allocate?relay; Banked call to: osal_msg_allocate
    323            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    324            {
    325              // fill in the message
    326              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   7434         MOV     A,#0x34
   \   000027   12....       LCALL   ??Subroutine148_0 & 0xFFFF
    327              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_288:
   \   00002A   A3           INC     DPTR
   \   00002B   EA           MOV     A,R2
   \   00002C   2402         ADD     A,#0x2
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   3B           ADDC    A,R3
   \   000031   FD           MOV     R5,A
   \   000032   7406         MOV     A,#0x6
   \   000034   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    328              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00003E   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   12....       LCALL   ?Subroutine37 & 0xFFFF
    329              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_36:
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   EA           MOV     A,R2
   \   000057   240A         ADD     A,#0xa
   \   000059   FC           MOV     R4,A
   \   00005A   E4           CLR     A
   \   00005B   3B           ADDC    A,R3
   \   00005C   FD           MOV     R5,A
   \   00005D   740C         MOV     A,#0xc
   \   00005F   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    330              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000062   8E82         MOV     DPL,R6
   \   000064   8F83         MOV     DPH,R7
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F8           MOV     R0,A
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   C8           XCH     A,R0
   \   00006B   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   00006E   38           ADDC    A,R0
   \   00006F   F583         MOV     DPH,A
   \   000071   E0           MOVX    A,@DPTR
   \   000072   C0E0         PUSH    A
   \   000074   EA           MOV     A,R2
   \   000075   2416         ADD     A,#0x16
   \   000077   F582         MOV     DPL,A
   \   000079   E4           CLR     A
   \   00007A   3B           ADDC    A,R3
   \   00007B   F583         MOV     DPH,A
   \   00007D   D0E0         POP     A
   \   00007F   F0           MOVX    @DPTR,A
    331              pCmd->attrCmd   = pInMsg->attrCmd;
   \   000080   EE           MOV     A,R6
   \   000081   240C         ADD     A,#0xc
   \   000083   F8           MOV     R0,A
   \   000084   E4           CLR     A
   \   000085   3F           ADDC    A,R7
   \   000086   F9           MOV     R1,A
   \   000087   8882         MOV     DPL,R0
   \   000089   8983         MOV     DPH,R1
   \   00008B   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   00008E   EA           MOV     A,R2
   \   00008F   2417         ADD     A,#0x17
   \   000091   F582         MOV     DPL,A
   \   000093   E4           CLR     A
   \   000094   3B           ADDC    A,R3
   \   000095   F583         MOV     DPH,A
   \   000097   12....       LCALL   ?Subroutine37 & 0xFFFF
    332          
    333              // Application will free the attrCmd buffer
    334              pInMsg->attrCmd = NULL;
   \                     ??CrossCallReturnLabel_37:
   \   00009A   E4           CLR     A
   \   00009B   F0           MOVX    @DPTR,A
   \   00009C   A3           INC     DPTR
   \   00009D   F0           MOVX    @DPTR,A
    335          
    336              /* send message through task message */
    337              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   00009E                ; Setup parameters for call to function osal_msg_send
   \   00009E   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   F9           MOV     R1,A
   \   0000A3   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
    338            }
    339          
    340            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000A6   7901         MOV     R1,#0x1
   \   0000A8   02....       LJMP    ??Subroutine152_0 & 0xFFFF
    341          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   EC           MOV     A,R4
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   ED           MOV     A,R5
   \   000004   F0           MOVX    @DPTR,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine145_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine148_0:
   \   000000   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine152_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine158_0:
   \   000000   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   22           RET
    342          
    343          
    344          /*********************************************************************
    345           * @fn          zcl_getRawAFMsg
    346           *
    347           * @brief       Call to get original unprocessed AF message
    348           *              (not parsed by ZCL).
    349           *
    350           *   NOTE:  This function can only be called during a ZCL callback function
    351           *          and the calling function must NOT change any data in the message.
    352           *
    353           * @param       none
    354           *
    355           * @return      pointer to original AF message, NULL if not processing
    356           *              AF message.
    357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    358          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    359          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    360            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   00000A   02....       LJMP    ?Subroutine0 & 0xFFFF
    361          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine144_0:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    362          
    363          /*********************************************************************
    364           * @fn          zcl_getParsedTransSeqNum
    365           *
    366           * @brief       Call to the get the transaction sequence number from 
    367           *              the incoming message.
    368           *
    369           *   NOTE:  This function can only be called during a ZCL callback function
    370           *          and the calling function must NOT change any data in the message.
    371           *
    372           * @param       none
    373           *
    374           * @return      transaction sequence number.
    375           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    376          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    377          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    378            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF
    379          }
    380          
    381          /*********************************************************************
    382           * @fn          zcl_registerPlugin
    383           *
    384           * @brief       Add a Cluster Library handler
    385           *
    386           * @param       startClusterID - starting cluster ID
    387           * @param       endClusterID - ending cluster ID
    388           * @param       pfnHdlr - function pointer to incoming message handler
    389           *
    390           * @return      ZSuccess if OK
    391           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    392          ZStatus_t zcl_registerPlugin( uint16 startClusterID, uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr ){
   \                     zcl_registerPlugin:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    393            zclLibPlugin_t *pNewItem;
    394            zclLibPlugin_t *pLoop;
    395          
    396            // Fill in the new profile list
    397            pNewItem = (zclLibPlugin_t *)zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    398            if ( pNewItem == NULL ){
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    399              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8036         SJMP    ??zcl_registerPlugin_1
    400            }
    401          
    402            // Fill in the plugin record.
    403            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   12....       LCALL   ?Subroutine25 & 0xFFFF
    404            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_20:
   \   000027   12....       LCALL   ?Subroutine22 & 0xFFFF
    405            pNewItem->endClusterID = endClusterID;
    406            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_14:
   \   00002A   740C         MOV     A,#0xc
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine38 & 0xFFFF
    407          
    408            // Find spot in list
    409            if (  plugins == NULL )
   \                     ??CrossCallReturnLabel_420:
   \   000038   90....       MOV     DPTR,#plugins
   \   00003B   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   00003E   90....       MOV     DPTR,#plugins
   \   000041   6012         JZ      ??zcl_registerPlugin_2
    410            {
    411              plugins = pNewItem;
    412            }
    413            else
    414            {
    415              // Look for end of list
    416              pLoop = plugins;
   \   000043   E0           MOVX    A,@DPTR
   \   000044   FC           MOV     R4,A
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   8003         SJMP    ??zcl_registerPlugin_3
    417              while ( pLoop->next != NULL )
    418              {
    419                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_4:
   \   000049   EA           MOV     A,R2
   \   00004A   FC           MOV     R4,A
   \   00004B   EB           MOV     A,R3
    420              }
   \                     ??zcl_registerPlugin_3:
   \   00004C   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00004F   70F8         JNZ     ??zcl_registerPlugin_4
    421          
    422              // Put new item at end of list
    423              pLoop->next = pNewItem;
   \   000051   8C82         MOV     DPL,R4
   \   000053   8D83         MOV     DPH,R5
    424            }
   \                     ??zcl_registerPlugin_2:
   \   000055   12....       LCALL   ??Subroutine133_0 & 0xFFFF
    425          
    426            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_205:
   \   000058   7900         MOV     R1,#0x0
   \                     ??zcl_registerPlugin_1:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    427          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   A3           INC     DPTR
   \   000001   E5..         MOV     A,?V1
   \   000003   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   EE           MOV     A,R6
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   EF           MOV     A,R7
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine134_0
   \   000005                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine168_0
   \   000001                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    428          
    429          #ifdef ZCL_DISCOVER
    430          /*********************************************************************
    431           * @fn          zcl_registerCmdList
    432           *
    433           * @brief       Register a Command List with ZCL Foundation
    434           *
    435           * @param       endpoint - endpoint the attribute list belongs to
    436           * @param       newCmdList - array of command records
    437           *
    438           * @return      ZSuccess if OK
    439           */
    440          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    441          {
    442            zclCmdRecsList_t *pNewItem;
    443            zclCmdRecsList_t *pLoop;
    444          
    445            // Fill in the new profile list
    446            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    447            if ( pNewItem == NULL )
    448            {
    449              return (ZMemError);
    450            }
    451          
    452            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    453            pNewItem->endpoint = endpoint;
    454            pNewItem->numCommands = cmdListSize;
    455            pNewItem->pCmdRecs = newCmdList;
    456          
    457            // Find spot in list
    458            if ( gpCmdList == NULL )
    459            {
    460              gpCmdList = pNewItem;
    461            }
    462            else
    463            {
    464              // Look for end of list
    465              pLoop = gpCmdList;
    466              while ( pLoop->pNext != NULL )
    467              {
    468                pLoop = pLoop->pNext;
    469              }
    470          
    471              // Put new item at end of list
    472              pLoop->pNext = pNewItem;
    473            }
    474          
    475            return ( ZSuccess );
    476          }
    477          #endif  // ZCL_DISCOVER
    478          
    479          
    480          /*********************************************************************
    481           * @fn          zcl_registerClusterOptionList
    482           *
    483           * @brief       Register a Cluster Option List with ZCL Foundation
    484           *
    485           * @param       endpoint - endpoint the option list belongs to
    486           * @param       numOption - number of options in list
    487           * @param       optionList - array of cluster option records.
    488           *
    489           *              NOTE: This API should be called to enable 'Application
    490           *                    Link Key' security and/or 'APS ACK' for a specific
    491           *                    Cluster. The 'Application Link Key' is discarded
    492           *                    if security isn't enabled on the device.
    493           *                    The default behavior is 'Network Key' when security
    494           *                    is enabled and no 'APS ACK' for the ZCL messages.
    495           *
    496           * @return      ZSuccess if OK
    497           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    498          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    499          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    500            zclClusterOptionList *pNewItem;
    501            zclClusterOptionList *pLoop;
    502          
    503            // Fill in the new profile list
    504            pNewItem = (zclClusterOptionList *)zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    505            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    506            {
    507              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   802E         SJMP    ??zcl_registerClusterOptionList_1
    508            }
    509          
    510            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine25 & 0xFFFF
    511            pNewItem->endpoint = endpoint;
    512            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_21:
   \   000027   8882         MOV     DPL,R0
   \   000029   8983         MOV     DPH,R1
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   12....       LCALL   ?Subroutine22 & 0xFFFF
    513            pNewItem->options = optionList;
    514          
    515            // Find spot in list
    516            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_15:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000036   90....       MOV     DPTR,#clusterOptionList
   \   000039   6012         JZ      ??zcl_registerClusterOptionList_2
    517            {
    518              clusterOptionList = pNewItem;
    519            }
    520            else
    521            {
    522              // Look for end of list
    523              pLoop = clusterOptionList;
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FC           MOV     R4,A
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   8003         SJMP    ??zcl_registerClusterOptionList_3
    524              while ( pLoop->next != NULL )
    525              {
    526                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_4:
   \   000041   EA           MOV     A,R2
   \   000042   FC           MOV     R4,A
   \   000043   EB           MOV     A,R3
    527              }
   \                     ??zcl_registerClusterOptionList_3:
   \   000044   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000047   70F8         JNZ     ??zcl_registerClusterOptionList_4
    528          
    529              // Put new item at end of list
    530              pLoop->next = pNewItem;
   \   000049   8C82         MOV     DPL,R4
   \   00004B   8D83         MOV     DPH,R5
    531            }
   \                     ??zcl_registerClusterOptionList_2:
   \   00004D   12....       LCALL   ??Subroutine133_0 & 0xFFFF
    532          
    533            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_206:
   \   000050   7900         MOV     R1,#0x0
   \                     ??zcl_registerClusterOptionList_1:
   \   000052   02....       LJMP    ?Subroutine1 & 0xFFFF
    534          }
    535          
    536          /*********************************************************************
    537           * @fn          zcl_registerValidateAttrData
    538           *
    539           * @brief       Add a validation function for attribute data
    540           *
    541           * @param       pfnValidateAttrData - function pointer to validate routine
    542           *
    543           * @return      ZSuccess if OK
    544           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    545          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    546          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    547            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   12....       LCALL   ??Subroutine168_0 & 0xFFFF
    548          
    549            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_417:
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   02....       LJMP    ?Subroutine0 & 0xFFFF
    550          }
    551          
    552          
    553          /*********************************************************************
    554           * @fn      zcl_DeviceOperational
    555           *
    556           * @brief   Used to see whether or not the device can send or respond
    557           *          to application level commands.
    558           *
    559           * @param   srcEP - source endpoint
    560           * @param   clusterID - cluster ID
    561           * @param   frameType - command type
    562           * @param   cmd - command ID
    563           *
    564           * @return  TRUE if device is operational, FALSE otherwise
    565           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    566          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     ??zcl_DeviceOperational:
    567                                              uint8 frameType, uint8 cmd, uint16 profileID )
    568          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    569            struct zclAttrRec_t attrRec;
    570            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    571          
    572            (void)profileID;  // Intentionally unreferenced parameter
    573          
    574            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    575            // cannot send or respond to application level commands, other than commands
    576            // to read or write attributes. Note that the Identify cluster cannot be
    577            // disabled, and remains functional regardless of this setting.
    578            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_1
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_2
    579            {
    580              return ( TRUE );
    581            }
    582          
    583            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_1:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_2
    584            {
    585              return ( TRUE );
    586            }
    587          
    588            // Is device enabled?
    589            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC, ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_3
    590            {
    591          #ifdef ZCL_READ
    592              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    593          #endif
    594            }
    595          
    596            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_3:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_2:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_5
   \                     ??zcl_DeviceOperational_4:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_5:
   \   000076   740B         MOV     A,#0xb
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B                REQUIRE ?Subroutine1
   \   00007B                ; // Fall through to label ?Subroutine1
    597          }
    598          
    599          /*********************************************************************
    600           * @fn      zcl_SendCommand
    601           *
    602           * @brief   Used to send Profile and Cluster Specific Command messages.
    603           *
    604           *          NOTE: The calling application is responsible for incrementing
    605           *                the Sequence Number.
    606           *
    607           * @param   srcEp - source endpoint
    608           * @param   destAddr - destination address
    609           * @param   clusterID - cluster ID
    610           * @param   cmd - command ID
    611           * @param   specific - whether the command is Cluster Specific
    612           * @param   direction - client/server direction of the command
    613           * @param   disableDefaultRsp - disable Default Response command
    614           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    615           * @param   seqNumber - identification number for the transaction
    616           * @param   cmdFormatLen - length of the command to be sent
    617           * @param   cmdFormat - command to be sent
    618           *
    619           * @return  ZSuccess if OK
    620           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    621          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,  uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,  uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum, uint16 cmdFormatLen, uint8 *cmdFormat ){
   \                     zcl_SendCommand:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V2,R4
   \   000012   8D..         MOV     ?V3,R5
    622            endPointDesc_t *epDesc;
    623            zclFrameHdr_t hdr;
    624            uint8 *msgBuf;
    625            uint16 msgLen;
    626            uint8 *pBuf;
    627            uint8 options;
    628            ZStatus_t status;
    629          
    630            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    631            if ( epDesc == NULL ){
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    632              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    633            }
    634          
    635          #if defined ( INTER_PAN )
    636            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) ) {
    637              options = AF_TX_OPTIONS_NONE;
    638            } else
    639          #endif
    640            {
    641              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption(uint8, uint16)
   \   000025   AA..         MOV     R2,?V2
   \   000027   AB..         MOV     R3,?V3
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption(uint8, uint16)
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    642          
    643              // The cluster might not have been defined to use security but if this messageis in response to another message that was using APS security this message will be sent with APS security
    644              if ( !( options & AF_EN_SECURITY ) ) {
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   4013         JC      ??zcl_SendCommand_2
    645                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine153_0 & 0xFFFF
    646          
    647                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) ) {
   \                     ??CrossCallReturnLabel_304:
   \   00003B   600B         JZ      ??zcl_SendCommand_2
   \   00003D   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   000040   7006         JNZ     ??zcl_SendCommand_2
    648                  options |= AF_EN_SECURITY;
   \   000042   E5..         MOV     A,?V7
   \   000044   D2E6         SETB    0xE0 /* A   */.6
   \   000046   F5..         MOV     ?V7,A
    649                }
    650              }
    651            }
    652          
    653            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000048                ; Setup parameters for call to function osal_memset
   \   000048   7C06         MOV     R4,#0x6
   \   00004A   7D00         MOV     R5,#0x0
   \   00004C   7900         MOV     R1,#0x0
   \   00004E   AA..         MOV     R2,?XSP + 0
   \   000050   AB..         MOV     R3,?XSP + 1
   \   000052   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    654          
    655            // Not Profile wide command (like READ, WRITE)
    656            if ( specific ){
   \   000055   741F         MOV     A,#0x1f
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   00005D   6005         JZ      ??zcl_SendCommand_3
    657              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   00005F   12....       LCALL   ?Subroutine56 & 0xFFFF
    658            } else{
   \                     ??CrossCallReturnLabel_74:
   \   000062   8003         SJMP    ??zcl_SendCommand_4
    659              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   000064   E0           MOVX    A,@DPTR
   \   000065   54FC         ANL     A,#0xfc
    660            }
   \                     ??zcl_SendCommand_4:
   \   000067   12....       LCALL   ?Subroutine20 & 0xFFFF
    661          
    662            if ( ( epDesc->simpleDesc == NULL ) ||( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )  {
   \                     ??CrossCallReturnLabel_10:
   \   00006A   602B         JZ      ??zcl_SendCommand_5
   \   00006C   741E         MOV     A,#0x1e
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E0           MOVX    A,@DPTR
   \   000072   FE           MOV     R6,A
   \   000073                ; Setup parameters for call to function zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   A3           INC     DPTR
   \   000078   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00007B   EE           MOV     A,R6
   \   00007C   FD           MOV     R5,A
   \   00007D   7402         MOV     A,#0x2
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   E0           MOVX    A,@DPTR
   \   000083   5403         ANL     A,#0x3
   \   000085   FC           MOV     R4,A
   \   000086   AA..         MOV     R2,?V2
   \   000088   AB..         MOV     R3,?V3
   \   00008A   A9..         MOV     R1,?V10
   \   00008C   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   \   000094   E9           MOV     A,R1
   \   000095   7005         JNZ     ??zcl_SendCommand_6
    663              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   000097   7901         MOV     R1,#0x1
   \   000099   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    664            }
   \                     ??zcl_SendCommand_6:
   \   00009C   7422         MOV     A,#0x22
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine153_0 & 0xFFFF
    665          
    666            // Fill in the Maufacturer Code
    667            if ( manuCode != 0 ) {
   \                     ??CrossCallReturnLabel_305:
   \   0000A4   6012         JZ      ??CrossCallReturnLabel_207
    668              hdr.fc.manuSpecific = 1;
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   4404         ORL     A,#0x4
   \   0000AF   F0           MOVX    @DPTR,A
    669              hdr.manuCode = manuCode;
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL   ??Subroutine133_0 & 0xFFFF
    670            }
    671          
    672            // Set the Command Direction
    673            if ( direction ) {
   \                     ??CrossCallReturnLabel_207:
   \   0000B8   7420         MOV     A,#0x20
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   0000C0   6005         JZ      ??zcl_SendCommand_7
    674              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   4408         ORL     A,#0x8
   \   0000C5   8003         SJMP    ??zcl_SendCommand_8
    675            } else {
    676              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000CA   F0           MOVX    @DPTR,A
    677            }
    678          
    679            // Set the Disable Default Response field
    680            if ( disableDefaultRsp ) {
   \   0000CB   7421         MOV     A,#0x21
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   0000D3   6005         JZ      ??zcl_SendCommand_9
    681              hdr.fc.disableDefaultRsp = 1;
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   4410         ORL     A,#0x10
   \   0000D8   8003         SJMP    ??zcl_SendCommand_10
    682            } else {
    683              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000DD   F0           MOVX    @DPTR,A
    684            }
    685          
    686            // Fill in the Transaction Sequence Number
    687            hdr.transSeqNum = seqNum;
   \   0000DE   7424         MOV     A,#0x24
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   C0E0         PUSH    A
   \   0000E6   7404         MOV     A,#0x4
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   D0E0         POP     A
   \   0000ED   F0           MOVX    @DPTR,A
    688          
    689            // Fill in the command
    690            hdr.commandID = cmd;
   \   0000EE   7405         MOV     A,#0x5
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   EE           MOV     A,R6
   \   0000F4   F0           MOVX    @DPTR,A
   \   0000F5   7425         MOV     A,#0x25
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   12....       LCALL   ??Subroutine161_0 & 0xFFFF
    691          
    692            // calculate the needed buffer size
    693            msgLen = zclCalcHdrSize( &hdr );
    694            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_359:
   \   0000FD                ; Setup parameters for call to function zclCalcHdrSize(zclFrameHdr_t *)
   \   0000FD   AA..         MOV     R2,?XSP + 0
   \   0000FF   AB..         MOV     R3,?XSP + 1
   \   000101   12....       LCALL   ??zclCalcHdrSize?relay; Banked call to: zclCalcHdrSize(zclFrameHdr_t *)
   \   000104   E9           MOV     A,R1
   \   000105   2E           ADD     A,R6
   \   000106   F5..         MOV     ?V0,A
   \   000108   E4           CLR     A
   \   000109   3F           ADDC    A,R7
   \   00010A   F5..         MOV     ?V1,A
    695          
    696            // Allocate the buffer needed
    697            msgBuf = (unsigned char *)zcl_mem_alloc( msgLen );
   \   00010C                ; Setup parameters for call to function osal_mem_alloc
   \   00010C   AA..         MOV     R2,?V0
   \   00010E   FB           MOV     R3,A
   \   00010F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000112   8A..         MOV     ?V8,R2
   \   000114   8B..         MOV     ?V9,R3
    698            if ( msgBuf != NULL ) {
   \   000116   EA           MOV     A,R2
   \   000117   45..         ORL     A,?V9
   \   000119   6062         JZ      ??zcl_SendCommand_11
    699              // Fill in the ZCL Header
    700              pBuf = zclBuildHdr( &hdr, msgBuf );
    701          
    702              // Fill in the command frame
    703              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   00011B                ; Setup parameters for call to function osal_memcpy
   \   00011B   7427         MOV     A,#0x27
   \   00011D   12....       LCALL   ?XSTACK_DISP0_8
   \   000120   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000123   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000126                ; Setup parameters for call to function zclBuildHdr(zclFrameHdr_t *, unsigned char *)
   \   000126   AC..         MOV     R4,?V8
   \   000128   AD..         MOV     R5,?V9
   \   00012A   7403         MOV     A,#0x3
   \   00012C   12....       LCALL   ?XSTACK_DISP101_8
   \   00012F   12....       LCALL   ??zclBuildHdr?relay  ; Banked call to: zclBuildHdr(zclFrameHdr_t *, unsigned char *)
   \   000132   EE           MOV     A,R6
   \   000133   FC           MOV     R4,A
   \   000134   EF           MOV     A,R7
   \   000135   FD           MOV     R5,A
   \   000136   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000139   7403         MOV     A,#0x3
   \   00013B   12....       LCALL   ?DEALLOC_XSTACK8
    704          
    705              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,  &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   00013E                ; Setup parameters for call to function AF_DataRequest
   \   00013E   75..1E       MOV     ?V4,#0x1e
   \   000141   78..         MOV     R0,#?V4
   \   000143   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000146   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000149   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   00014C   78..         MOV     R0,#?V4
   \   00014E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000151   78..         MOV     R0,#?V8
   \   000153   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000156   78..         MOV     R0,#?V0
   \   000158   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015B   78..         MOV     R0,#?V2
   \   00015D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000160   A9..         MOV     R1,?V7
   \   000162   AC..         MOV     R4,?V12
   \   000164   AD..         MOV     R5,?V13
   \   000166   AA..         MOV     R2,?V14
   \   000168   AB..         MOV     R3,?V15
   \   00016A   12....       LCALL   ??AF_DataRequest?relay; Banked call to: AF_DataRequest
   \   00016D   7409         MOV     A,#0x9
   \   00016F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000172   E9           MOV     A,R1
   \   000173   FE           MOV     R6,A
    706              zcl_mem_free ( msgBuf );
   \   000174                ; Setup parameters for call to function osal_mem_free
   \   000174   AA..         MOV     R2,?V8
   \   000176   AB..         MOV     R3,?V9
   \   000178   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00017B   8002         SJMP    ??zcl_SendCommand_12
    707            }  else  {
    708              status = ZMemError;
   \                     ??zcl_SendCommand_11:
   \   00017D   7E10         MOV     R6,#0x10
    709            }
    710          
    711            return status;
   \                     ??zcl_SendCommand_12:
   \   00017F   EE           MOV     A,R6
   \   000180   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   000181   02....       LJMP    ?Subroutine3 & 0xFFFF
    712          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   E8           MOV     A,R0
   \   000001   2419         ADD     A,#0x19
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   39           ADDC    A,R1
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   6401         XRL     A,#0x1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   54FC         ANL     A,#0xfc
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   4401         ORL     A,#0x1
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   E9           MOV     A,R1
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   00000C   E8           MOV     A,R0
   \   00000D   49           ORL     A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine153_0:
   \   000000   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine161_0:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine163_0
   \   000001                ; // Fall through to label ??Subroutine163_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine163_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7406         MOV     A,#0x6
   \   000002                REQUIRE ??Subroutine169_0
   \   000002                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine170_0
   \   000003                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   7F10         MOV     R7,#0x10
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    713          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    714          ZStatus_t zclSendCommand( uint8 srcEP, afAddrType_t *destAddr,  uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,  uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum, BufferData & bufferData){
   \                     zclSendCommand:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    715            endPointDesc_t *epDesc;
    716            zclFrameHdr_t hdr;
    717            uint8 *msgBuf;
    718            uint16 msgLen;
    719            uint8 *pBuf;
    720            uint8 options;
    721            ZStatus_t status;
    722          
    723            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    724            if ( epDesc == NULL ){
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zclSendCommand_0
    725              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zclSendCommand_1 & 0xFFFF
    726            }
    727          
    728          #if defined ( INTER_PAN )
    729            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) ) {
    730              options = AF_TX_OPTIONS_NONE;
    731            } else
    732          #endif
    733            {
    734              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zclSendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption(uint8, uint16)
   \   000025   AA..         MOV     R2,?V0
   \   000027   AB..         MOV     R3,?V1
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption(uint8, uint16)
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    735          
    736              // The cluster might not have been defined to use security but if this messageis in response to another message that was using APS security this message will be sent with APS security
    737              if ( !( options & AF_EN_SECURITY ) ) {
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   4013         JC      ??zclSendCommand_2
    738                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine153_0 & 0xFFFF
    739          
    740                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) ) {
   \                     ??CrossCallReturnLabel_306:
   \   00003B   600B         JZ      ??zclSendCommand_2
   \   00003D   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000040   7006         JNZ     ??zclSendCommand_2
    741                  options |= AF_EN_SECURITY;
   \   000042   E5..         MOV     A,?V7
   \   000044   D2E6         SETB    0xE0 /* A   */.6
   \   000046   F5..         MOV     ?V7,A
    742                }
    743              }
    744            }
    745          
    746            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zclSendCommand_2:
   \   000048                ; Setup parameters for call to function osal_memset
   \   000048   7C06         MOV     R4,#0x6
   \   00004A   7D00         MOV     R5,#0x0
   \   00004C   7900         MOV     R1,#0x0
   \   00004E   AA..         MOV     R2,?XSP + 0
   \   000050   AB..         MOV     R3,?XSP + 1
   \   000052   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    747          
    748            // Not Profile wide command (like READ, WRITE)
    749            if ( specific ){
   \   000055   741F         MOV     A,#0x1f
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   00005D   6005         JZ      ??zclSendCommand_3
    750              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   00005F   12....       LCALL   ?Subroutine56 & 0xFFFF
    751            } else{
   \                     ??CrossCallReturnLabel_75:
   \   000062   8003         SJMP    ??zclSendCommand_4
    752              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zclSendCommand_3:
   \   000064   E0           MOVX    A,@DPTR
   \   000065   54FC         ANL     A,#0xfc
    753            }
   \                     ??zclSendCommand_4:
   \   000067   12....       LCALL   ?Subroutine20 & 0xFFFF
    754          
    755            if ( ( epDesc->simpleDesc == NULL ) ||( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type, cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )  {
   \                     ??CrossCallReturnLabel_11:
   \   00006A   602B         JZ      ??zclSendCommand_5
   \   00006C   741E         MOV     A,#0x1e
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   E0           MOVX    A,@DPTR
   \   000072   FE           MOV     R6,A
   \   000073                ; Setup parameters for call to function zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   A3           INC     DPTR
   \   000078   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00007B   EE           MOV     A,R6
   \   00007C   FD           MOV     R5,A
   \   00007D   7402         MOV     A,#0x2
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   E0           MOVX    A,@DPTR
   \   000083   5403         ANL     A,#0x3
   \   000085   FC           MOV     R4,A
   \   000086   AA..         MOV     R2,?V0
   \   000088   AB..         MOV     R3,?V1
   \   00008A   A9..         MOV     R1,?V10
   \   00008C   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?DEALLOC_XSTACK8
   \   000094   E9           MOV     A,R1
   \   000095   7005         JNZ     ??zclSendCommand_6
    756              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zclSendCommand_5:
   \   000097   7901         MOV     R1,#0x1
   \   000099   02....       LJMP    ??zclSendCommand_1 & 0xFFFF
    757            }
   \                     ??zclSendCommand_6:
   \   00009C   7422         MOV     A,#0x22
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine153_0 & 0xFFFF
    758          
    759            // Fill in the Maufacturer Code
    760            if ( manuCode != 0 ) {
   \                     ??CrossCallReturnLabel_307:
   \   0000A4   6012         JZ      ??CrossCallReturnLabel_208
    761              hdr.fc.manuSpecific = 1;
   \   0000A6   85..82       MOV     DPL,?XSP + 0
   \   0000A9   85..83       MOV     DPH,?XSP + 1
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   4404         ORL     A,#0x4
   \   0000AF   F0           MOVX    @DPTR,A
    762              hdr.manuCode = manuCode;
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   12....       LCALL   ??Subroutine133_0 & 0xFFFF
    763            }
    764          
    765            // Set the Command Direction
    766            if ( direction ) {
   \                     ??CrossCallReturnLabel_208:
   \   0000B8   7420         MOV     A,#0x20
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000C0   6005         JZ      ??zclSendCommand_7
    767              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   4408         ORL     A,#0x8
   \   0000C5   8003         SJMP    ??zclSendCommand_8
    768            } else {
    769              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclSendCommand_7:
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   54F7         ANL     A,#0xf7
   \                     ??zclSendCommand_8:
   \   0000CA   F0           MOVX    @DPTR,A
    770            }
    771          
    772            // Set the Disable Default Response field
    773            if ( disableDefaultRsp ) {
   \   0000CB   7421         MOV     A,#0x21
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   0000D3   6005         JZ      ??zclSendCommand_9
    774              hdr.fc.disableDefaultRsp = 1;
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   4410         ORL     A,#0x10
   \   0000D8   8003         SJMP    ??zclSendCommand_10
    775            } else {
    776              hdr.fc.disableDefaultRsp = 0;
   \                     ??zclSendCommand_9:
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   54EF         ANL     A,#0xef
   \                     ??zclSendCommand_10:
   \   0000DD   F0           MOVX    @DPTR,A
    777            }
    778          
    779            // Fill in the Transaction Sequence Number
    780            hdr.transSeqNum = seqNum;
   \   0000DE   7424         MOV     A,#0x24
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   C0E0         PUSH    A
   \   0000E6   7404         MOV     A,#0x4
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   D0E0         POP     A
   \   0000ED   F0           MOVX    @DPTR,A
    781          
    782            // Fill in the command
    783            hdr.commandID = cmd;
   \   0000EE   7405         MOV     A,#0x5
   \   0000F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F3   EE           MOV     A,R6
   \   0000F4   F0           MOVX    @DPTR,A
    784          
    785            // calculate the needed buffer size
    786            msgLen = zclCalcHdrSize( &hdr );
   \   0000F5                ; Setup parameters for call to function zclCalcHdrSize(zclFrameHdr_t *)
   \   0000F5   AA..         MOV     R2,?XSP + 0
   \   0000F7   AB..         MOV     R3,?XSP + 1
   \   0000F9   12....       LCALL   ??zclCalcHdrSize?relay; Banked call to: zclCalcHdrSize(zclFrameHdr_t *)
   \   0000FC   7425         MOV     A,#0x25
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   12....       LCALL   ?Subroutine72 & 0xFFFF
    787            msgLen += bufferData.dataLen;
   \                     ??CrossCallReturnLabel_106:
   \   000104   29           ADD     A,R1
   \   000105   FE           MOV     R6,A
   \   000106   A3           INC     DPTR
   \   000107   E0           MOVX    A,@DPTR
   \   000108   3400         ADDC    A,#0x0
   \   00010A   FF           MOV     R7,A
    788          
    789            // Allocate the buffer needed
    790            msgBuf = (unsigned char *)zcl_mem_alloc( msgLen );
   \   00010B                ; Setup parameters for call to function osal_mem_alloc
   \   00010B   EE           MOV     A,R6
   \   00010C   FA           MOV     R2,A
   \   00010D   EF           MOV     A,R7
   \   00010E   FB           MOV     R3,A
   \   00010F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000112   8A..         MOV     ?V2,R2
   \   000114   8B..         MOV     ?V3,R3
    791            if ( msgBuf != NULL ) {
   \   000116   EA           MOV     A,R2
   \   000117   45..         ORL     A,?V3
   \   000119   606D         JZ      ??zclSendCommand_11
    792              // Fill in the ZCL Header
    793              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   00011B                ; Setup parameters for call to function zclBuildHdr(zclFrameHdr_t *, unsigned char *)
   \   00011B   AC..         MOV     R4,?V2
   \   00011D   AD..         MOV     R5,?V3
   \   00011F   AA..         MOV     R2,?XSP + 0
   \   000121   AB..         MOV     R3,?XSP + 1
   \   000123   12....       LCALL   ??zclBuildHdr?relay  ; Banked call to: zclBuildHdr(zclFrameHdr_t *, unsigned char *)
    794          
    795              // Fill in the command frame
    796              zcl_memcpy( pBuf, bufferData.data, bufferData.dataLen );
   \   000126                ; Setup parameters for call to function osal_memcpy
   \   000126   85..82       MOV     DPL,?V8
   \   000129   85..83       MOV     DPH,?V9
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   85..82       MOV     DPL,?V8
   \   000137   85..83       MOV     DPH,?V9
   \   00013A   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   00013D   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000140   7403         MOV     A,#0x3
   \   000142   12....       LCALL   ?DEALLOC_XSTACK8
    797          
    798              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,  &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000145                ; Setup parameters for call to function AF_DataRequest
   \   000145   75..1E       MOV     ?V4,#0x1e
   \   000148   78..         MOV     R0,#?V4
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014D   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000150   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000153   78..         MOV     R0,#?V4
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000158   78..         MOV     R0,#?V2
   \   00015A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00015D   8E..         MOV     ?V4,R6
   \   00015F   8F..         MOV     ?V5,R7
   \   000161   78..         MOV     R0,#?V4
   \   000163   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000166   78..         MOV     R0,#?V0
   \   000168   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00016B   A9..         MOV     R1,?V7
   \   00016D   AC..         MOV     R4,?V12
   \   00016F   AD..         MOV     R5,?V13
   \   000171   AA..         MOV     R2,?V14
   \   000173   AB..         MOV     R3,?V15
   \   000175   12....       LCALL   ??AF_DataRequest?relay; Banked call to: AF_DataRequest
   \   000178   7409         MOV     A,#0x9
   \   00017A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00017D   E9           MOV     A,R1
   \   00017E   FE           MOV     R6,A
    799              zcl_mem_free ( msgBuf );
   \   00017F                ; Setup parameters for call to function osal_mem_free
   \   00017F   AA..         MOV     R2,?V2
   \   000181   AB..         MOV     R3,?V3
   \   000183   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000186   8002         SJMP    ??zclSendCommand_12
    800            }  else  {
    801              status = ZMemError;
   \                     ??zclSendCommand_11:
   \   000188   7E10         MOV     R6,#0x10
    802            }
    803          
    804            return status;
   \                     ??zclSendCommand_12:
   \   00018A   EE           MOV     A,R6
   \   00018B   F9           MOV     R1,A
   \                     ??zclSendCommand_1:
   \   00018C   02....       LJMP    ?Subroutine3 & 0xFFFF
    805          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007                ; Setup parameters for call to function osal_mem_alloc
   \   000007   85..82       MOV     DPL,?V8
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET
    806          
    807          #ifdef ZCL_READ
    808          /*********************************************************************
    809           * @fn      zcl_SendRead
    810           *
    811           * @brief   Send a Read command
    812           *
    813           * @param   srcEP - Application's endpoint
    814           * @param   dstAddr - destination address
    815           * @param   clusterID - cluster ID
    816           * @param   readCmd - read command to be sent
    817           * @param   direction - direction of the command
    818           * @param   seqNum - transaction sequence number
    819           *
    820           * @return  ZSuccess if OK
    821           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    822          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,  uint16 clusterID, zclReadCmd_t *readCmd,    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum){
   \                     zcl_SendRead:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    823          	ZStatus_t status;
    824          
    825          	BufferData buf = readCmd->getBufferFromAttribute();
   \   000014                ; Setup parameters for call to function zclReadCmd_t::getBufferFromAttribute()
   \   000014   AC..         MOV     R4,?XSP + 0
   \   000016   AD..         MOV     R5,?XSP + 1
   \   000018   7412         MOV     A,#0x12
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000020   12....       LCALL   ??getBufferFromAttribute?relay; Banked call to: zclReadCmd_t::getBufferFromAttribute()
    826          	if ( buf.isValid() ) {
   \   000023                ; Setup parameters for call to function BufferData::isValid()
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   ??isValid?relay      ; Banked call to: BufferData::isValid()
   \   00002A   505B         JNC     ??zcl_SendRead_0
    827          		status = zclSendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE, direction, disableDefaultRsp, 0, seqNum, buf );
   \   00002C                ; Setup parameters for call to function zclSendCommand
   \   00002C   A8..         MOV     R0,?XSP + 0
   \   00002E   A9..         MOV     R1,?XSP + 1
   \   000030   88..         MOV     ?V4,R0
   \   000032   89..         MOV     ?V5,R1
   \   000034   78..         MOV     R0,#?V4
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7418         MOV     A,#0x18
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   12....       LCALL   ?Subroutine42 & 0xFFFF
    828          	} else {
   \                     ??CrossCallReturnLabel_40:
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000044   E4           CLR     A
   \   000045   F5..         MOV     ?V4,A
   \   000047   F5..         MOV     ?V5,A
   \   000049   78..         MOV     R0,#?V4
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741A         MOV     A,#0x1a
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   741A         MOV     A,#0x1a
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000064   75..00       MOV     ?V3,#0x0
   \   000067   78..         MOV     R0,#?V3
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006C   78..         MOV     R0,#?V3
   \   00006E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000071   AC..         MOV     R4,?V0
   \   000073   AD..         MOV     R5,?V1
   \   000075   EE           MOV     A,R6
   \   000076   FA           MOV     R2,A
   \   000077   EF           MOV     A,R7
   \   000078   FB           MOV     R3,A
   \   000079   A9..         MOV     R1,?V2
   \   00007B   12....       LCALL   ??zclSendCommand?relay; Banked call to: zclSendCommand
   \   00007E   7409         MOV     A,#0x9
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   \   000083   E9           MOV     A,R1
   \   000084   FE           MOV     R6,A
   \   000085   8002         SJMP    ??zcl_SendRead_1
    829          		status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   000087   7E10         MOV     R6,#0x10
    830          	}
    831          
    832          	return status;
   \                     ??zcl_SendRead_1:
   \   000089                ; Setup parameters for call to function BufferData::~BufferData()
   \   000089   02....       LJMP    ?Subroutine4 & 0xFFFF
    833          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   AA..         MOV     R2,?XSP + 0
   \   000002   AB..         MOV     R3,?XSP + 1
   \   000004   12....       LCALL   `?~BufferData?relay` ; Banked call to: BufferData::~BufferData()
   \   000007   EE           MOV     A,R6
   \   000008   F9           MOV     R1,A
   \   000009   7404         MOV     A,#0x4
   \   00000B                REQUIRE ??Subroutine135_0
   \   00000B                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F06         MOV     R7,#0x6
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET
    834          
    835          /*********************************************************************
    836           * @fn      zcl_SendReadRsp
    837           *
    838           * @brief   Send a Read Response command.
    839           *
    840           * @param   srcEP - Application's endpoint
    841           * @param   dstAddr - destination address
    842           * @param   clusterID - cluster ID
    843           * @param   readRspCmd - read response command to be sent
    844           * @param   direction - direction of the command
    845           * @param   seqNum - transaction sequence number
    846           *
    847           * @return  ZSuccess if OK
    848           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    849          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    850                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    851                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    852          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
    853            uint8 *buf;
    854            uint16 len = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
    855            ZStatus_t status;
    856            uint8 i;
    857          
    858            // calculate the size of the command
    859            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   00001D   8047         SJMP    ??zcl_SendReadRsp_0
    860            {
    861              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   00001F   E5..         MOV     A,?V2
   \   000021   75F006       MOV     B,#0x6
   \   000024   A4           MUL     AB
   \   000025   F8           MOV     R0,A
   \   000026   A9F0         MOV     R1,B
   \   000028   E5..         MOV     A,?V4
   \   00002A   28           ADD     A,R0
   \   00002B   F582         MOV     DPL,A
   \   00002D   E5..         MOV     A,?V5
   \   00002F   12....       LCALL   ?Subroutine98 & 0xFFFF
    862          
    863              len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_167:
   \   000032   2403         ADD     A,#0x3
   \   000034   FE           MOV     R6,A
   \   000035   E4           CLR     A
   \   000036   3F           ADDC    A,R7
   \   000037   FF           MOV     R7,A
    864          
    865              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   7027         JNZ     ??zcl_SendReadRsp_2
    866              {
    867                len++; // Attribute Data Type length
   \   00003D   0E           INC     R6
   \   00003E   EE           MOV     A,R6
   \   00003F   7001         JNZ     ??zcl_SendReadRsp_3
   \   000041   0F           INC     R7
    868          
    869                // Attribute Data length
    870                if ( statusRec->data != NULL ) {
   \                     ??zcl_SendReadRsp_3:
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00004D   6015         JZ      ??zcl_SendReadRsp_2
    871                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   \   00004F                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004F   8882         MOV     DPL,R0
   \   000051   8983         MOV     DPH,R1
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005B   8B..         MOV     ?V1,R3
   \   00005D   EE           MOV     A,R6
   \   00005E   2A           ADD     A,R2
   \   00005F   FE           MOV     R6,A
   \   000060   EF           MOV     A,R7
   \   000061   35..         ADDC    A,?V1
   \   000063   FF           MOV     R7,A
    872                }
    873              }
    874            }
   \                     ??zcl_SendReadRsp_2:
   \   000064   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000066   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   000069   40B4         JC      ??zcl_SendReadRsp_1
    875          
    876            buf = (unsigned char *)zcl_mem_alloc( len );
   \   00006B                ; Setup parameters for call to function osal_mem_alloc
   \   00006B   EE           MOV     A,R6
   \   00006C   FA           MOV     R2,A
   \   00006D   EF           MOV     A,R7
   \   00006E   FB           MOV     R3,A
   \   00006F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000072   8A..         MOV     ?V0,R2
   \   000074   8B..         MOV     ?V1,R3
    877            if ( buf != NULL )
   \   000076   EA           MOV     A,R2
   \   000077   45..         ORL     A,?V1
   \   000079   7003         JNZ     $+5
   \   00007B   02....       LJMP    ??zcl_SendReadRsp_4 & 0xFFFF
    878            {
    879              // Load the buffer - serially
    880              uint8 *pBuf = buf;
   \   00007E   AC..         MOV     R4,?V0
   \   000080   AD..         MOV     R5,?V1
    881          
    882              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000082   75..00       MOV     ?V2,#0x0
   \   000085   8047         SJMP    ??zcl_SendReadRsp_5
    883              {
    884                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_6:
   \   000087   E5..         MOV     A,?V2
   \   000089   75F006       MOV     B,#0x6
   \   00008C   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   00008F   AA82         MOV     R2,DPL
   \   000091   AB83         MOV     R3,DPH
    885          
    886                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000093   12....       LCALL   ?Subroutine26 & 0xFFFF
    887                *pBuf++ = HI_UINT16( statusRec->attrID );
   \                     ??CrossCallReturnLabel_22:
   \   000096   12....       LCALL   ??Subroutine143_0 & 0xFFFF
    888                *pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_247:
   \   000099   EA           MOV     A,R2
   \   00009A   2402         ADD     A,#0x2
   \   00009C   F8           MOV     R0,A
   \   00009D   12....       LCALL   ?Subroutine30 & 0xFFFF
    889          
    890                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_250:
   \   0000A0   8882         MOV     DPL,R0
   \   0000A2   8983         MOV     DPH,R1
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   7025         JNZ     ??zcl_SendReadRsp_7
    891                {
    892                  *pBuf++ = statusRec->dataType;
   \   0000A7   EA           MOV     A,R2
   \   0000A8   2403         ADD     A,#0x3
   \   0000AA   08           INC     R0
   \   0000AB   12....       LCALL   ?Subroutine30 & 0xFFFF
    893          
    894                  if ( statusRec->data != NULL )
   \                     ??CrossCallReturnLabel_251:
   \   0000AE   8A82         MOV     DPL,R2
   \   0000B0   8B83         MOV     DPH,R3
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   0000B9   6011         JZ      ??zcl_SendReadRsp_7
    895                  {
    896                    // Copy attribute data to the buffer to be sent out
    897                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   \   0000BB                ; Setup parameters for call to function zclSerializeData
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   8983         MOV     DPH,R1
   \   0000BF   E0           MOVX    A,@DPTR
   \   0000C0   F9           MOV     R1,A
   \   0000C1   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000C4   8A..         MOV     ?V10,R2
   \   0000C6   8B..         MOV     ?V11,R3
   \   0000C8   AC..         MOV     R4,?V10
   \   0000CA   AD..         MOV     R5,?V11
    898                  }
    899                }
    900              } // for loop
   \                     ??zcl_SendReadRsp_7:
   \   0000CC   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_5:
   \   0000CE   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   0000D1   40B4         JC      ??zcl_SendReadRsp_6
    901          
    902              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
    903                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   0000D3                ; Setup parameters for call to function zcl_SendCommand
   \   0000D3   78..         MOV     R0,#?V0
   \   0000D5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D8   8E..         MOV     ?V4,R6
   \   0000DA   8F..         MOV     ?V5,R7
   \   0000DC   78..         MOV     R0,#?V4
   \   0000DE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E1   741C         MOV     A,#0x1c
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   0000E9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000EC   E4           CLR     A
   \   0000ED   F5..         MOV     ?V4,A
   \   0000EF   F5..         MOV     ?V5,A
   \   0000F1   78..         MOV     R0,#?V4
   \   0000F3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F6   741E         MOV     A,#0x1e
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   0000FE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000101   741E         MOV     A,#0x1e
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000109   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00010C   75..00       MOV     ?V2,#0x0
   \   00010F   78..         MOV     R0,#?V2
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000114   75..01       MOV     ?V2,#0x1
   \   000117   78..         MOV     R0,#?V2
   \   000119   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00011C   AC..         MOV     R4,?V6
   \   00011E   AD..         MOV     R5,?V7
   \   000120   AA..         MOV     R2,?V8
   \   000122   AB..         MOV     R3,?V9
   \   000124   A9..         MOV     R1,?V3
   \   000126   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000129   740B         MOV     A,#0xb
   \   00012B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012E   E9           MOV     A,R1
   \   00012F   FE           MOV     R6,A
    904              zcl_mem_free( buf );
   \   000130                ; Setup parameters for call to function osal_mem_free
   \   000130   AA..         MOV     R2,?V0
   \   000132   AB..         MOV     R3,?V1
   \   000134   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000137   8002         SJMP    ??zcl_SendReadRsp_8
    905            }
    906            else
    907            {
    908              status = ZMemError;
   \                     ??zcl_SendReadRsp_4:
   \   000139   7E10         MOV     R6,#0x10
    909            }
    910          
    911            return ( status );
   \                     ??zcl_SendReadRsp_8:
   \   00013B   02....       LJMP    ?Subroutine9 & 0xFFFF
    912          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine138_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   EE           MOV     A,R6
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V4
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V5
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E4           CLR     A
   \   000001   3B           ADDC    A,R3
   \   000002   F9           MOV     R1,A
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007                REQUIRE ??Subroutine143_0
   \   000007                ; // Fall through to label ??Subroutine143_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine143_0:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000003   0C           INC     R4
   \   000004   AD83         MOV     R5,DPH
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   12....       LCALL   ?Subroutine107 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine159_0
   \   000006                ; // Fall through to label ??Subroutine159_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine159_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET
    913          #endif // ZCL_READ
    914          
    915          #ifdef ZCL_WRITE
    916          /*********************************************************************
    917           * @fn      sendWriteRequest
    918           *
    919           * @brief   Send a Write command
    920           *
    921           * @param   dstAddr - destination address
    922           * @param   clusterID - cluster ID
    923           * @param   writeCmd - write command to be sent
    924           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    925           * @param   direction - direction of the command
    926           * @param   seqNum - transaction sequence number
    927           *
    928           * @return  ZSuccess if OK
    929           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    930          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, ZclWriteCmd *writeCmd, uint8 cmd, uint8 direction,  uint8 disableDefaultRsp, uint8 seqNum ) {
   \                     zcl_SendWriteRequest:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    931          	ZStatus_t status;
    932          
    933          	BufferData bufferData = writeCmd->getBufferFromAttribute();
   \   000014                ; Setup parameters for call to function ZclWriteCmd::getBufferFromAttribute()
   \   000014   AC..         MOV     R4,?XSP + 0
   \   000016   AD..         MOV     R5,?XSP + 1
   \   000018   7412         MOV     A,#0x12
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000020   12....       LCALL   ??getBufferFromAttribute?relay_1; Banked call to: ZclWriteCmd::getBufferFromAttribute()
    934          	if (bufferData.isValid()){
   \   000023                ; Setup parameters for call to function BufferData::isValid()
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   ??isValid?relay      ; Banked call to: BufferData::isValid()
   \   00002A   5061         JNC     ??zcl_SendWriteRequest_0
    935              	status = zclSendCommand( srcEP, dstAddr, clusterID, cmd, FALSE, direction, disableDefaultRsp, 0, seqNum, bufferData );
   \   00002C                ; Setup parameters for call to function zclSendCommand
   \   00002C   A8..         MOV     R0,?XSP + 0
   \   00002E   A9..         MOV     R1,?XSP + 1
   \   000030   88..         MOV     ?V4,R0
   \   000032   89..         MOV     ?V5,R1
   \   000034   78..         MOV     R0,#?V4
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7419         MOV     A,#0x19
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   12....       LCALL   ?Subroutine42 & 0xFFFF
    936          	} else{
   \                     ??CrossCallReturnLabel_43:
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000044   E4           CLR     A
   \   000045   F5..         MOV     ?V4,A
   \   000047   F5..         MOV     ?V5,A
   \   000049   78..         MOV     R0,#?V4
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741B         MOV     A,#0x1b
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   741B         MOV     A,#0x1b
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000064   75..00       MOV     ?V3,#0x0
   \   000067   78..         MOV     R0,#?V3
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006C   741C         MOV     A,#0x1c
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   AC..         MOV     R4,?V0
   \   000079   AD..         MOV     R5,?V1
   \   00007B   EE           MOV     A,R6
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   FB           MOV     R3,A
   \   00007F   A9..         MOV     R1,?V2
   \   000081   12....       LCALL   ??zclSendCommand?relay; Banked call to: zclSendCommand
   \   000084   7409         MOV     A,#0x9
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   FE           MOV     R6,A
   \   00008B   8002         SJMP    ??zcl_SendWriteRequest_1
    937          		status = ZMemError;
   \                     ??zcl_SendWriteRequest_0:
   \   00008D   7E10         MOV     R6,#0x10
    938           	}
    939          	return status;
   \                     ??zcl_SendWriteRequest_1:
   \   00008F                ; Setup parameters for call to function BufferData::~BufferData()
   \   00008F   02....       LJMP    ?Subroutine4 & 0xFFFF
    940          }
    941          
    942          /*********************************************************************
    943           * @fn      zcl_SendWriteRsp
    944           *
    945           * @brief   Send a Write Response command
    946           *
    947           * @param   dstAddr - destination address
    948           * @param   clusterID - cluster ID
    949           * @param   wrtieRspCmd - write response command to be sent
    950           * @param   direction - direction of the command
    951           * @param   seqNum - transaction sequence number
    952           *
    953           * @return  ZSuccess if OK
    954           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    955          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID, ZclWriteRspCmd *writeRspCmd, uint8 direction, uint8 disableDefaultRsp, uint8 seqNum ){
   \                     zcl_SendWriteRsp:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   EA           MOV     A,R2
   \   00000D   FE           MOV     R6,A
   \   00000E   EB           MOV     A,R3
   \   00000F   FF           MOV     R7,A
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
    956          	ZStatus_t status;
    957          
    958          	BufferData buffer = writeRspCmd->getBufferData();
   \   000014                ; Setup parameters for call to function ZclWriteRspCmd::getBufferData()
   \   000014   AC..         MOV     R4,?XSP + 0
   \   000016   AD..         MOV     R5,?XSP + 1
   \   000018   7412         MOV     A,#0x12
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000020   12....       LCALL   ??getBufferData?relay; Banked call to: ZclWriteRspCmd::getBufferData()
    959          	if (buffer.isValid()){
   \   000023                ; Setup parameters for call to function BufferData::isValid()
   \   000023   AA..         MOV     R2,?XSP + 0
   \   000025   AB..         MOV     R3,?XSP + 1
   \   000027   12....       LCALL   ??isValid?relay      ; Banked call to: BufferData::isValid()
   \   00002A   505E         JNC     ??zcl_SendWriteRsp_0
    960          	    status = zclSendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE, direction, disableDefaultRsp, 0, seqNum,buffer );
   \   00002C                ; Setup parameters for call to function zclSendCommand
   \   00002C   A8..         MOV     R0,?XSP + 0
   \   00002E   A9..         MOV     R1,?XSP + 1
   \   000030   88..         MOV     ?V4,R0
   \   000032   89..         MOV     ?V5,R1
   \   000034   78..         MOV     R0,#?V4
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7418         MOV     A,#0x18
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   12....       LCALL   ?Subroutine42 & 0xFFFF
    961          	} else{
   \                     ??CrossCallReturnLabel_47:
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000044   E4           CLR     A
   \   000045   F5..         MOV     ?V4,A
   \   000047   F5..         MOV     ?V5,A
   \   000049   78..         MOV     R0,#?V4
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741A         MOV     A,#0x1a
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   741A         MOV     A,#0x1a
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000064   75..00       MOV     ?V3,#0x0
   \   000067   78..         MOV     R0,#?V3
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006C   75..04       MOV     ?V3,#0x4
   \   00006F   78..         MOV     R0,#?V3
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000074   AC..         MOV     R4,?V0
   \   000076   AD..         MOV     R5,?V1
   \   000078   EE           MOV     A,R6
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   FB           MOV     R3,A
   \   00007C   A9..         MOV     R1,?V2
   \   00007E   12....       LCALL   ??zclSendCommand?relay; Banked call to: zclSendCommand
   \   000081   7409         MOV     A,#0x9
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   E9           MOV     A,R1
   \   000087   FE           MOV     R6,A
   \   000088   8002         SJMP    ??zcl_SendWriteRsp_1
    962              	status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   00008A   7E10         MOV     R6,#0x10
    963            	}
    964          
    965          	return status;
   \                     ??zcl_SendWriteRsp_1:
   \   00008C                ; Setup parameters for call to function BufferData::~BufferData()
   \   00008C                REQUIRE ?Subroutine4
   \   00008C                ; // Fall through to label ?Subroutine4
    966          }
    967          #endif // ZCL_WRITE
    968          
    969          #ifdef ZCL_REPORT
    970          /*********************************************************************
    971           * @fn      zcl_SendConfigReportCmd
    972           *
    973           * @brief   Send a Configure Reporting command
    974           *
    975           * @param   dstAddr - destination address
    976           * @param   clusterID - cluster ID
    977           * @param   cfgReportCmd - configure reporting command to be sent
    978           * @param   direction - direction of the command
    979           * @param   seqNum - transaction sequence number
    980           *
    981           * @return  ZSuccess if OK
    982           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    983          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
    984                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
    985                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    986          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
    987            uint8 *buf;
    988            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
    989            ZStatus_t status;
    990            uint8 i;
    991          
    992            // Find out the data length
    993            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00001D   8009         SJMP    ??zcl_SendConfigReportCmd_0
    994            {
    995              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
    996          
    997              dataLen += 1 + 2; // Direction + Attribute ID
    998          
    999              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1000              {
   1001                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1002          
   1003                // Find out the size of the Reportable Change field (for Analog data types)
   1004                if ( zclAnalogDataType( reportRec->dataType ) )
   1005                {
   1006                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1007                }
   1008              }
   1009              else
   1010              {
   1011                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1012              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   000028   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   00002B   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00C       MOV     B,#0xc
   \   000032   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   00003F   EE           MOV     A,R6
   \   000040   2405         ADD     A,#0x5
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E582         MOV     A,DPL
   \   000048   2403         ADD     A,#0x3
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   E4           CLR     A
   \   00004D   3583         ADDC    A,DPH
   \   00004F   F5..         MOV     ?V3,A
   \   000051                ; Setup parameters for call to function zclAnalogDataType
   \   000051   85..82       MOV     DPL,?V2
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005B   E9           MOV     A,R1
   \   00005C   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   00005E                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005E   85..82       MOV     DPL,?V2
   \   000061   85..83       MOV     DPH,?V3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000069   EE           MOV     A,R6
   \   00006A   29           ADD     A,R1
   \   00006B   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1013            }
   1014          
   1015            buf = (unsigned char *)zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   00006D                ; Setup parameters for call to function osal_mem_alloc
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000074   8A..         MOV     ?V2,R2
   \   000076   8B..         MOV     ?V3,R3
   1016            if ( buf != NULL )
   \   000078   EA           MOV     A,R2
   \   000079   45..         ORL     A,?V3
   \   00007B   7003         JNZ     $+5
   \   00007D   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1017            {
   1018              // Load the buffer - serially
   1019              uint8 *pBuf = buf;
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   1020          
   1021              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000084   75..00       MOV     ?V0,#0x0
   \   000087   8009         SJMP    ??zcl_SendConfigReportCmd_6
   1022              {
   1023                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1024          
   1025                *pBuf++ = reportRec->direction;
   1026                *pBuf++ = LO_UINT16( reportRec->attrID );
   1027                *pBuf++ = HI_UINT16( reportRec->attrID );
   1028          
   1029                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1030                {
   1031                  *pBuf++ = reportRec->dataType;
   1032                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1033                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1034                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1035                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1036          
   1037                  if ( zclAnalogDataType( reportRec->dataType ) )
   1038                  {
   1039                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1040                  }
   1041                }
   1042                else
   1043                {
   1044                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   000089   E5..         MOV     A,?V4
   \   00008B   2408         ADD     A,#0x8
   \   00008D   12....       LCALL   ?Subroutine18 & 0xFFFF
   1045                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1046                }
   \                     ??CrossCallReturnLabel_8:
   \   000090   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   000092   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000095   5052         JNC     ??zcl_SendConfigReportCmd_8
   \   000097   E5..         MOV     A,?V0
   \   000099   75F00C       MOV     B,#0xc
   \   00009C   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   00009F   A882         MOV     R0,DPL
   \   0000A1   A983         MOV     R1,DPH
   \   0000A3   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000A6   A3           INC     DPTR
   \   0000A7   A882         MOV     R0,DPL
   \   0000A9   A983         MOV     R1,DPH
   \   0000AB   85..82       MOV     DPL,?V4
   \   0000AE   85..83       MOV     DPH,?V5
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   70D5         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000B4   E5..         MOV     A,?V4
   \   0000B6   2403         ADD     A,#0x3
   \   0000B8   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   0000BB   2404         ADD     A,#0x4
   \   0000BD   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000C0   2406         ADD     A,#0x6
   \   0000C2   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   0000C5   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000C8   E9           MOV     A,R1
   \   0000C9   60C5         JZ      ??CrossCallReturnLabel_8
   \   0000CB                ; Setup parameters for call to function zclSerializeData
   \   0000CB   AC..         MOV     R4,?V6
   \   0000CD   AD..         MOV     R5,?V7
   \   0000CF   85..82       MOV     DPL,?V4
   \   0000D2   85..83       MOV     DPH,?V5
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   12....       LCALL   ?Subroutine49 & 0xFFFF
   1047              } // for loop
   \                     ??CrossCallReturnLabel_226:
   \   0000E0   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000E3   8A..         MOV     ?V6,R2
   \   0000E5   8B..         MOV     ?V7,R3
   \   0000E7   80A7         SJMP    ??CrossCallReturnLabel_8
   1048          
   1049              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1050                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_8:
   \   0000E9                ; Setup parameters for call to function zcl_SendCommand
   \   0000E9   78..         MOV     R0,#?V2
   \   0000EB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EE   8E..         MOV     ?V4,R6
   \   0000F0   8F..         MOV     ?V5,R7
   \   0000F2   78..         MOV     R0,#?V4
   \   0000F4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F7   7420         MOV     A,#0x20
   \   0000F9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FC   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   0000FF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000102   E4           CLR     A
   \   000103   F5..         MOV     ?V4,A
   \   000105   F5..         MOV     ?V5,A
   \   000107   78..         MOV     R0,#?V4
   \   000109   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010C   7422         MOV     A,#0x22
   \   00010E   12....       LCALL   ?XSTACK_DISP0_8
   \   000111   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000117   7422         MOV     A,#0x22
   \   000119   12....       LCALL   ?XSTACK_DISP0_8
   \   00011C   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000122   75..00       MOV     ?V0,#0x0
   \   000125   78..         MOV     R0,#?V0
   \   000127   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012A   75..06       MOV     ?V0,#0x6
   \   00012D   78..         MOV     R0,#?V0
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000132   AC..         MOV     R4,?V12
   \   000134   AD..         MOV     R5,?V13
   \   000136   AA..         MOV     R2,?V14
   \   000138   AB..         MOV     R3,?V15
   \   00013A   A9..         MOV     R1,?V1
   \   00013C   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00013F   740B         MOV     A,#0xb
   \   000141   12....       LCALL   ?DEALLOC_XSTACK8
   \   000144   E9           MOV     A,R1
   \   000145   FE           MOV     R6,A
   1051              zcl_mem_free( buf );
   \   000146                ; Setup parameters for call to function osal_mem_free
   \   000146   AA..         MOV     R2,?V2
   \   000148   AB..         MOV     R3,?V3
   \   00014A   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00014D   8002         SJMP    ??zcl_SendConfigReportCmd_9
   1052            }
   1053            else
   1054            {
   1055              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   00014F   7E10         MOV     R6,#0x10
   1056            }
   1057          
   1058            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   000151                REQUIRE ?Subroutine10
   \   000151                ; // Fall through to label ?Subroutine10
   1059          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine170_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine136_0
   \   000002                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_404:
   \   000003   85..82       MOV     DPL,?V10
   \   000006   85..83       MOV     DPH,?V11
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine139_0
   \   000005                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000003                REQUIRE ??Subroutine140_0
   \   000003                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   12....       LCALL   ??Subroutine142_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F8           MOV     R0,A
   \   000008   E5..         MOV     A,?V0
   \   00000A   C3           CLR     C
   \   00000B   98           SUBB    A,R0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   F5..         MOV     ?V10,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V5
   \   000005   F5..         MOV     ?V11,A
   \   000007   85..82       MOV     DPL,?V10
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   00000F   88..         MOV     ?V6,R0
   \   000011   89..         MOV     ?V7,R1
   \   000013   E5..         MOV     A,?V4
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   00000C   85..82       MOV     DPL,?V4
   \   00000F   85..83       MOV     DPH,?V5
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   FA           MOV     R2,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   FB           MOV     R3,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   00000C   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   00000F   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000003   E5..         MOV     A,?V4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine141_0
   \   000009                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000003                REQUIRE ??Subroutine142_0
   \   000003                ; // Fall through to label ??Subroutine142_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine142_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   8582..       MOV     ?V6,DPL
   \   000005   8583..       MOV     ?V7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003   85..82       MOV     DPL,?V10
   \   000006   85..83       MOV     DPH,?V11
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine147_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET
   1060          
   1061          /*********************************************************************
   1062           * @fn      zcl_SendConfigReportRspCmd
   1063           *
   1064           * @brief   Send a Configure Reporting Response command
   1065           *
   1066           * @param   dstAddr - destination address
   1067           * @param   clusterID - cluster ID
   1068           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1069           * @param   direction - direction of the command
   1070           * @param   seqNum - transaction sequence number
   1071           *
   1072           * @return  ZSuccess if OK
   1073           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1074          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1075                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1076                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1077          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine75 & 0xFFFF
   1078            uint16 dataLen;
   1079            uint8 *buf;
   1080            ZStatus_t status;
   1081          
   1082            // Atrribute list (Status, Direction and Attribute ID)
   1083            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_114:
   \   000017   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   85....       MOV     ?V6,?V0
   \   000020   85....       MOV     ?V7,?V1
   1084          
   1085            buf = (unsigned char *)zcl_mem_alloc( dataLen );
   \   000023                ; Setup parameters for call to function osal_mem_alloc
   \   000023   AA..         MOV     R2,?V6
   \   000025   AB..         MOV     R3,?V7
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   1086            if ( buf != NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1087            {
   1088              // Load the buffer - serially
   1089              uint8 *pBuf = buf;
   1090              uint8 i;
   1091          
   1092              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000036   7C00         MOV     R4,#0x0
   \   000038   8042         SJMP    ??zcl_SendConfigReportRspCmd_1
   1093              {
   1094                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   00003A   8C..         MOV     ?V10,R4
   \   00003C   75..00       MOV     ?V11,#0x0
   \   00003F   7402         MOV     A,#0x2
   \   000041   78..         MOV     R0,#?V10
   \   000043   12....       LCALL   ?S_SHL
   \   000046   E5..         MOV     A,?V4
   \   000048   25..         ADD     A,?V10
   \   00004A   F8           MOV     R0,A
   \   00004B   E5..         MOV     A,?V5
   \   00004D   35..         ADDC    A,?V11
   \   00004F   F9           MOV     R1,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   AA82         MOV     R2,DPL
   \   00005C   AB83         MOV     R3,DPH
   1095                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   00005E   8882         MOV     DPL,R0
   \   000060   8983         MOV     DPH,R1
   \   000062   A3           INC     DPTR
   \   000063   12....       LCALL   ?Subroutine61 & 0xFFFF
   1096                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_229:
   \   000066   E8           MOV     A,R0
   \   000067   2403         ADD     A,#0x3
   \   000069   F8           MOV     R0,A
   \   00006A   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   00006C   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00006D   8882         MOV     DPL,R0
   \   00006F   8983         MOV     DPH,R1
   \   000071   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   1097                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_228:
   \   000074   8882         MOV     DPL,R0
   \   000076   8983         MOV     DPH,R1
   \   000078   12....       LCALL   ?Subroutine61 & 0xFFFF
   1098              }
   \                     ??CrossCallReturnLabel_230:
   \   00007B   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007C   85..82       MOV     DPL,?V4
   \   00007F   85..83       MOV     DPH,?V5
   \   000082   E0           MOVX    A,@DPTR
   \   000083   F8           MOV     R0,A
   \   000084   EC           MOV     A,R4
   \   000085   C3           CLR     C
   \   000086   98           SUBB    A,R0
   \   000087   40B1         JC      ??zcl_SendConfigReportRspCmd_2
   1099          
   1100              // If there's only a single status record and its status field is set to
   1101              // SUCCESS then omit the attribute ID field.
   1102              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000089   7401         MOV     A,#0x1
   \   00008B   68           XRL     A,R0
   \   00008C   700A         JNZ     ??zcl_SendConfigReportRspCmd_4
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   7006         JNZ     ??zcl_SendConfigReportRspCmd_4
   1103              {
   1104                dataLen = 1;
   \   000092   75..01       MOV     ?V6,#0x1
   \   000095   75..00       MOV     ?V7,#0x0
   1105              }
   1106          
   1107              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1108                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1109                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   000098                ; Setup parameters for call to function zcl_SendCommand
   \   000098   78..         MOV     R0,#?V0
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009D   78..         MOV     R0,#?V6
   \   00009F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A2   741C         MOV     A,#0x1c
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AD   E4           CLR     A
   \   0000AE   F5..         MOV     ?V4,A
   \   0000B0   F5..         MOV     ?V5,A
   \   0000B2   78..         MOV     R0,#?V4
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   741E         MOV     A,#0x1e
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   0000BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C2   741E         MOV     A,#0x1e
   \   0000C4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C7   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000CA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CD   75..00       MOV     ?V3,#0x0
   \   0000D0   78..         MOV     R0,#?V3
   \   0000D2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D5   75..07       MOV     ?V3,#0x7
   \   0000D8   78..         MOV     R0,#?V3
   \   0000DA   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DD   EE           MOV     A,R6
   \   0000DE   FC           MOV     R4,A
   \   0000DF   EF           MOV     A,R7
   \   0000E0   FD           MOV     R5,A
   \   0000E1   AA..         MOV     R2,?V8
   \   0000E3   AB..         MOV     R3,?V9
   \   0000E5   A9..         MOV     R1,?V2
   \   0000E7   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000EA   740B         MOV     A,#0xb
   \   0000EC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EF   E9           MOV     A,R1
   \   0000F0   FE           MOV     R6,A
   1110              zcl_mem_free( buf );
   \   0000F1                ; Setup parameters for call to function osal_mem_free
   \   0000F1   AA..         MOV     R2,?V0
   \   0000F3   AB..         MOV     R3,?V1
   \   0000F5   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000F8   8002         SJMP    ??zcl_SendConfigReportRspCmd_5
   1111            }
   1112            else
   1113            {
   1114              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000FA   7E10         MOV     R6,#0x10
   1115            }
   1116          
   1117            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   0000FC   02....       LJMP    ?Subroutine9 & 0xFFFF
   1118          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine137_0
   \   000001                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   0A           INC     R2
   \   000008   AB83         MOV     R3,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   75..00       MOV     ?V1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   1119          
   1120          /*********************************************************************
   1121           * @fn      zcl_SendReadReportCfgCmd
   1122           *
   1123           * @brief   Send a Read Reporting Configuration command
   1124           *
   1125           * @param   dstAddr - destination address
   1126           * @param   clusterID - cluster ID
   1127           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1128           * @param   direction - direction of the command
   1129           * @param   seqNum - transaction sequence number
   1130           *
   1131           * @return  ZSuccess if OK
   1132           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1133          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1134                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1135                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1136          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine75 & 0xFFFF
   1137            uint16 dataLen;
   1138            uint8 *buf;
   1139            ZStatus_t status;
   1140          
   1141            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   \                     ??CrossCallReturnLabel_115:
   \   000017   E0           MOVX    A,@DPTR
   \   000018   75F003       MOV     B,#0x3
   \   00001B   A4           MUL     AB
   \   00001C   F5..         MOV     ?V6,A
   \   00001E   E5F0         MOV     A,B
   \   000020   F5..         MOV     ?V7,A
   1142          
   1143            buf = (unsigned char *)zcl_mem_alloc( dataLen );
   \   000022                ; Setup parameters for call to function osal_mem_alloc
   \   000022   AA..         MOV     R2,?V6
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000028   8A..         MOV     ?V0,R2
   \   00002A   8B..         MOV     ?V1,R3
   1144            if ( buf != NULL )
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V1
   \   00002F   7003         JNZ     $+5
   \   000031   02....       LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
   1145            {
   1146              // Load the buffer - serially
   1147              uint8 *pBuf = buf;
   \   000034   A8..         MOV     R0,?V0
   \   000036   A9..         MOV     R1,?V1
   1148              uint8 i;
   1149          
   1150              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   000038   7C00         MOV     R4,#0x0
   \   00003A   8030         SJMP    ??zcl_SendReadReportCfgCmd_1
   1151              {
   1152                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   00003C   EC           MOV     A,R4
   \   00003D   75F003       MOV     B,#0x3
   \   000040   A4           MUL     AB
   \   000041   FA           MOV     R2,A
   \   000042   ABF0         MOV     R3,B
   \   000044   E5..         MOV     A,?V4
   \   000046   2A           ADD     A,R2
   \   000047   FA           MOV     R2,A
   \   000048   E5..         MOV     A,?V5
   \   00004A   3B           ADDC    A,R3
   \   00004B   FB           MOV     R3,A
   \   00004C   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \   000051   A882         MOV     R0,DPL
   \   000053   A983         MOV     R1,DPH
   1153                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   \   000055   EA           MOV     A,R2
   \   000056   2402         ADD     A,#0x2
   \   000058   FA           MOV     R2,A
   \   000059   5001         JNC     ??zcl_SendReadReportCfgCmd_3
   \   00005B   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   12....       LCALL   ?Subroutine84 & 0xFFFF
   1154                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_137:
   \   000063   8A82         MOV     DPL,R2
   \   000065   8B83         MOV     DPH,R3
   \   000067   A3           INC     DPTR
   \   000068   12....       LCALL   ?Subroutine84 & 0xFFFF
   1155              }
   \                     ??CrossCallReturnLabel_138:
   \   00006B   0C           INC     R4
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   00006C   85..82       MOV     DPL,?V4
   \   00006F   85..83       MOV     DPH,?V5
   \   000072   E0           MOVX    A,@DPTR
   \   000073   FA           MOV     R2,A
   \   000074   EC           MOV     A,R4
   \   000075   C3           CLR     C
   \   000076   9A           SUBB    A,R2
   \   000077   40C3         JC      ??zcl_SendReadReportCfgCmd_2
   1156          
   1157              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1158                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000079                ; Setup parameters for call to function zcl_SendCommand
   \   000079   78..         MOV     R0,#?V0
   \   00007B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007E   78..         MOV     R0,#?V6
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   741C         MOV     A,#0x1c
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008E   E4           CLR     A
   \   00008F   F5..         MOV     ?V4,A
   \   000091   F5..         MOV     ?V5,A
   \   000093   78..         MOV     R0,#?V4
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000098   741E         MOV     A,#0x1e
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000A0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A3   741E         MOV     A,#0x1e
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0000AB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AE   75..00       MOV     ?V3,#0x0
   \   0000B1   78..         MOV     R0,#?V3
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B6   75..08       MOV     ?V3,#0x8
   \   0000B9   78..         MOV     R0,#?V3
   \   0000BB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000BE   EE           MOV     A,R6
   \   0000BF   FC           MOV     R4,A
   \   0000C0   EF           MOV     A,R7
   \   0000C1   FD           MOV     R5,A
   \   0000C2   AA..         MOV     R2,?V8
   \   0000C4   AB..         MOV     R3,?V9
   \   0000C6   A9..         MOV     R1,?V2
   \   0000C8   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000CB   740B         MOV     A,#0xb
   \   0000CD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D0   E9           MOV     A,R1
   \   0000D1   FE           MOV     R6,A
   1159              zcl_mem_free( buf );
   \   0000D2                ; Setup parameters for call to function osal_mem_free
   \   0000D2   AA..         MOV     R2,?V0
   \   0000D4   AB..         MOV     R3,?V1
   \   0000D6   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000D9   8002         SJMP    ??zcl_SendReadReportCfgCmd_4
   1160            }
   1161            else
   1162            {
   1163              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   0000DB   7E10         MOV     R6,#0x10
   1164            }
   1165          
   1166            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_4:
   \   0000DD                REQUIRE ?Subroutine9
   \   0000DD                ; // Fall through to label ?Subroutine9
   1167          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   08           INC     R0
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET
   1168          
   1169          /*********************************************************************
   1170           * @fn      zcl_SendReadReportCfgRspCmd
   1171           *
   1172           * @brief   Send a Read Reporting Configuration Response command
   1173           *
   1174           * @param   dstAddr - destination address
   1175           * @param   clusterID - cluster ID
   1176           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1177           * @param   direction - direction of the command
   1178           * @param   seqNum - transaction sequence number
   1179           *
   1180           * @return  ZSuccess if OK
   1181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1182          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1183                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1184                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1185          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1186            uint8 *buf;
   1187            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1188            ZStatus_t status;
   1189            uint8 i;
   1190          
   1191            // Find out the data length
   1192            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   00001D   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1193            {
   1194              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1195          
   1196              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1197          
   1198              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1199              {
   1200                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1201                {
   1202                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1203          
   1204                  // Find out the size of the Reportable Change field (for Analog data types)
   1205                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1206                  {
   1207                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1208                  }
   1209                }
   1210                else
   1211                {
   1212                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1213                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   000028   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   00002B   504C         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00D       MOV     B,#0xd
   \   000032   A4           MUL     AB
   \   000033   F8           MOV     R0,A
   \   000034   A9F0         MOV     R1,B
   \   000036   E5..         MOV     A,?V8
   \   000038   28           ADD     A,R0
   \   000039   F582         MOV     DPL,A
   \   00003B   E5..         MOV     A,?V9
   \   00003D   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000040   2404         ADD     A,#0x4
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   70D2         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   00004D   EE           MOV     A,R6
   \   00004E   2405         ADD     A,#0x5
   \   000050   FE           MOV     R6,A
   \   000051   E4           CLR     A
   \   000052   3F           ADDC    A,R7
   \   000053   FF           MOV     R7,A
   \   000054   E8           MOV     A,R0
   \   000055   2404         ADD     A,#0x4
   \   000057   F5..         MOV     ?V2,A
   \   000059   E4           CLR     A
   \   00005A   39           ADDC    A,R1
   \   00005B   F5..         MOV     ?V3,A
   \   00005D                ; Setup parameters for call to function zclAnalogDataType
   \   00005D   85..82       MOV     DPL,?V2
   \   000060   F583         MOV     DPH,A
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F9           MOV     R1,A
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60BC         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   85..82       MOV     DPL,?V2
   \   00006D   85..83       MOV     DPH,?V3
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F9           MOV     R1,A
   \   000072   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000075   EE           MOV     A,R6
   \   000076   29           ADD     A,R1
   \   000077   80A9         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1214              }
   1215            }
   1216          
   1217            buf = (unsigned char *)zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000079                ; Setup parameters for call to function osal_mem_alloc
   \   000079   EE           MOV     A,R6
   \   00007A   FA           MOV     R2,A
   \   00007B   EF           MOV     A,R7
   \   00007C   FB           MOV     R3,A
   \   00007D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000080   8A..         MOV     ?V2,R2
   \   000082   8B..         MOV     ?V3,R3
   1218            if ( buf != NULL )
   \   000084   EA           MOV     A,R2
   \   000085   45..         ORL     A,?V3
   \   000087   7003         JNZ     $+5
   \   000089   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1219            {
   1220              // Load the buffer - serially
   1221              uint8 *pBuf = buf;
   \   00008C   8A..         MOV     ?V6,R2
   \   00008E   8B..         MOV     ?V7,R3
   1222          
   1223              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000090   75..00       MOV     ?V0,#0x0
   \   000093   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1224              {
   1225                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1226          
   1227                *pBuf++ = reportRspRec->status;
   1228                *pBuf++ = reportRspRec->direction;
   1229                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1230                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1231          
   1232                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1233                {
   1234                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1235                  {
   1236                    *pBuf++ = reportRspRec->dataType;
   1237                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1238                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1239                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1240                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1241          
   1242                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1243                    {
   1244                      pBuf = zclSerializeData( reportRspRec->dataType,
   1245                                               reportRspRec->reportableChange, pBuf );
   1246                    }
   1247                  }
   1248                  else
   1249                  {
   1250                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000095   E5..         MOV     A,?V4
   \   000097   2409         ADD     A,#0x9
   \   000099   12....       LCALL   ?Subroutine18 & 0xFFFF
   1251                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1252                  }
   \                     ??CrossCallReturnLabel_9:
   \   00009C   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   00009E   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   0000A1   506C         JNC     ??zcl_SendReadReportCfgRspCmd_8
   \   0000A3   E5..         MOV     A,?V0
   \   0000A5   75F00D       MOV     B,#0xd
   \   0000A8   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   0000B2   E5..         MOV     A,?V4
   \   0000B4   2402         ADD     A,#0x2
   \   0000B6   F8           MOV     R0,A
   \   0000B7   E4           CLR     A
   \   0000B8   35..         ADDC    A,?V5
   \   0000BA   F9           MOV     R1,A
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   8983         MOV     DPH,R1
   \   0000BF   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000C2   85..82       MOV     DPL,?V4
   \   0000C5   85..83       MOV     DPH,?V5
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   70D1         JNZ     ??CrossCallReturnLabel_9
   \   0000CB   85..82       MOV     DPL,?V6
   \   0000CE   85..83       MOV     DPH,?V7
   \   0000D1   A3           INC     DPTR
   \   0000D2   A882         MOV     R0,DPL
   \   0000D4   A983         MOV     R1,DPH
   \   0000D6   8A82         MOV     DPL,R2
   \   0000D8   8B83         MOV     DPH,R3
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   70B8         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000DD   E5..         MOV     A,?V4
   \   0000DF   2404         ADD     A,#0x4
   \   0000E1   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   0000E4   2405         ADD     A,#0x5
   \   0000E6   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000E9   2407         ADD     A,#0x7
   \   0000EB   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   0000EE   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000F1   E9           MOV     A,R1
   \   0000F2   60A8         JZ      ??CrossCallReturnLabel_9
   \   0000F4                ; Setup parameters for call to function zclSerializeData
   \   0000F4   AC..         MOV     R4,?V6
   \   0000F6   AD..         MOV     R5,?V7
   \   0000F8   E5..         MOV     A,?V4
   \   0000FA   240B         ADD     A,#0xb
   \   0000FC   F582         MOV     DPL,A
   \   0000FE   E4           CLR     A
   \   0000FF   35..         ADDC    A,?V5
   \   000101   F583         MOV     DPH,A
   \   000103   12....       LCALL   ??Subroutine136_0 & 0xFFFF
   1253                }
   1254              }
   \                     ??CrossCallReturnLabel_225:
   \   000106   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000109   8A..         MOV     ?V6,R2
   \   00010B   8B..         MOV     ?V7,R3
   \   00010D   808D         SJMP    ??CrossCallReturnLabel_9
   1255          
   1256              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1257                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1258                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00010F                ; Setup parameters for call to function zcl_SendCommand
   \   00010F   78..         MOV     R0,#?V2
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000114   8E..         MOV     ?V4,R6
   \   000116   8F..         MOV     ?V5,R7
   \   000118   78..         MOV     R0,#?V4
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011D   7420         MOV     A,#0x20
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000125   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000128   E4           CLR     A
   \   000129   F5..         MOV     ?V4,A
   \   00012B   F5..         MOV     ?V5,A
   \   00012D   78..         MOV     R0,#?V4
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   7422         MOV     A,#0x22
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00013D   7422         MOV     A,#0x22
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   75..00       MOV     ?V0,#0x0
   \   00014B   78..         MOV     R0,#?V0
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000150   75..09       MOV     ?V0,#0x9
   \   000153   78..         MOV     R0,#?V0
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000158   AC..         MOV     R4,?V12
   \   00015A   AD..         MOV     R5,?V13
   \   00015C   AA..         MOV     R2,?V14
   \   00015E   AB..         MOV     R3,?V15
   \   000160   A9..         MOV     R1,?V1
   \   000162   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000165   740B         MOV     A,#0xb
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016A   E9           MOV     A,R1
   \   00016B   FE           MOV     R6,A
   1259              zcl_mem_free( buf );
   \   00016C                ; Setup parameters for call to function osal_mem_free
   \   00016C   AA..         MOV     R2,?V2
   \   00016E   AB..         MOV     R3,?V3
   \   000170   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000173   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_9
   1260            }
   1261            else
   1262            {
   1263              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   000175   7E10         MOV     R6,#0x10
   1264            }
   1265          
   1266            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000177   02....       LJMP    ?Subroutine10 & 0xFFFF
   1267          }
   1268          
   1269          /*********************************************************************
   1270           * @fn      zcl_SendReportCmd
   1271           *
   1272           * @brief   Send a Report command
   1273           *
   1274           * @param   dstAddr - destination address
   1275           * @param   clusterID - cluster ID
   1276           * @param   reportCmd - report command to be sent
   1277           * @param   direction - direction of the command
   1278           * @param   seqNum - transaction sequence number
   1279           *
   1280           * @return  ZSuccess if OK
   1281           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1282          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1283                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1284                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1285          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1286            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1287            uint8 *buf;
   1288            ZStatus_t status;
   1289            uint8 i;
   1290          
   1291            // calculate the size of the command
   1292            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   00001D   8020         SJMP    ??zcl_SendReportCmd_0
   1293            {
   1294              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_1:
   \   00001F   12....       LCALL   ?Subroutine100 & 0xFFFF
   1295          
   1296              dataLen += 2 + 1; // Attribute ID + data type
   1297          
   1298              // Attribute Data
   1299              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   \                     ??CrossCallReturnLabel_171:
   \   000022                ; Setup parameters for call to function zclGetAttrDataLength
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   12....       LCALL   ?Subroutine77 & 0xFFFF
   1300            }
   \                     ??CrossCallReturnLabel_119:
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002D   8B..         MOV     ?V1,R3
   \   00002F   EA           MOV     A,R2
   \   000030   2403         ADD     A,#0x3
   \   000032   F8           MOV     R0,A
   \   000033   E4           CLR     A
   \   000034   35..         ADDC    A,?V1
   \   000036   F9           MOV     R1,A
   \   000037   EE           MOV     A,R6
   \   000038   28           ADD     A,R0
   \   000039   FE           MOV     R6,A
   \   00003A   EF           MOV     A,R7
   \   00003B   39           ADDC    A,R1
   \   00003C   FF           MOV     R7,A
   \   00003D   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_0:
   \   00003F   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000042   40DB         JC      ??zcl_SendReportCmd_1
   1301          
   1302            buf = (unsigned char *)zcl_mem_alloc( dataLen );
   \   000044                ; Setup parameters for call to function osal_mem_alloc
   \   000044   EE           MOV     A,R6
   \   000045   FA           MOV     R2,A
   \   000046   EF           MOV     A,R7
   \   000047   FB           MOV     R3,A
   \   000048   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00004B   8A..         MOV     ?V0,R2
   \   00004D   8B..         MOV     ?V1,R3
   1303            if ( buf != NULL )
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V1
   \   000052   7003         JNZ     $+5
   \   000054   02....       LJMP    ??zcl_SendReportCmd_2 & 0xFFFF
   1304            {
   1305              // Load the buffer - serially
   1306              uint8 *pBuf = buf;
   \   000057   AC..         MOV     R4,?V0
   \   000059   AD..         MOV     R5,?V1
   1307          
   1308              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   00005B   75..00       MOV     ?V2,#0x0
   \   00005E   8034         SJMP    ??zcl_SendReportCmd_3
   1309              {
   1310                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_4:
   \   000060   12....       LCALL   ?Subroutine100 & 0xFFFF
   1311          
   1312                *pBuf++ = LO_UINT16( reportRec->attrID );
   \                     ??CrossCallReturnLabel_172:
   \   000063   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000066   AC82         MOV     R4,DPL
   \   000068   AD83         MOV     R5,DPH
   1313                *pBuf++ = HI_UINT16( reportRec->attrID );
   \   00006A   8882         MOV     DPL,R0
   \   00006C   8983         MOV     DPH,R1
   \   00006E   A3           INC     DPTR
   \   00006F   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   1314                *pBuf++ = reportRec->dataType;
   \                     ??CrossCallReturnLabel_248:
   \   000072   E8           MOV     A,R0
   \   000073   2402         ADD     A,#0x2
   \   000075   FA           MOV     R2,A
   \   000076   E4           CLR     A
   \   000077   39           ADDC    A,R1
   \   000078   FB           MOV     R3,A
   \   000079   8A..         MOV     ?V10,R2
   \   00007B   8B..         MOV     ?V11,R3
   \   00007D   8A82         MOV     DPL,R2
   \   00007F   F583         MOV     DPH,A
   \   000081   12....       LCALL   ?Subroutine29 & 0xFFFF
   1315          
   1316                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1317              }
   \                     ??CrossCallReturnLabel_26:
   \   000084   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000087   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   00008A   8A..         MOV     ?V10,R2
   \   00008C   8B..         MOV     ?V11,R3
   \   00008E   AC..         MOV     R4,?V10
   \   000090   AD..         MOV     R5,?V11
   \   000092   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_3:
   \   000094   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   000097   40C7         JC      ??zcl_SendReportCmd_4
   1318          
   1319              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1320                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000099                ; Setup parameters for call to function zcl_SendCommand
   \   000099   78..         MOV     R0,#?V0
   \   00009B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009E   8E..         MOV     ?V4,R6
   \   0000A0   8F..         MOV     ?V5,R7
   \   0000A2   78..         MOV     R0,#?V4
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A7   741C         MOV     A,#0x1c
   \   0000A9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AC   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B2   E4           CLR     A
   \   0000B3   F5..         MOV     ?V4,A
   \   0000B5   F5..         MOV     ?V5,A
   \   0000B7   78..         MOV     R0,#?V4
   \   0000B9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BC   741E         MOV     A,#0x1e
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   0000C4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C7   741E         MOV     A,#0x1e
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   0000CF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D2   75..00       MOV     ?V2,#0x0
   \   0000D5   78..         MOV     R0,#?V2
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DA   75..0A       MOV     ?V2,#0xa
   \   0000DD   78..         MOV     R0,#?V2
   \   0000DF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E2   AC..         MOV     R4,?V6
   \   0000E4   AD..         MOV     R5,?V7
   \   0000E6   AA..         MOV     R2,?V8
   \   0000E8   AB..         MOV     R3,?V9
   \   0000EA   A9..         MOV     R1,?V3
   \   0000EC   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000EF   740B         MOV     A,#0xb
   \   0000F1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F4   E9           MOV     A,R1
   \   0000F5   FE           MOV     R6,A
   1321              zcl_mem_free( buf );
   \   0000F6                ; Setup parameters for call to function osal_mem_free
   \   0000F6   AA..         MOV     R2,?V0
   \   0000F8   AB..         MOV     R3,?V1
   \   0000FA   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000FD   8002         SJMP    ??zcl_SendReportCmd_5
   1322            }
   1323            else
   1324            {
   1325              status = ZMemError;
   \                     ??zcl_SendReportCmd_2:
   \   0000FF   7E10         MOV     R6,#0x10
   1326            }
   1327          
   1328            return ( status );
   \                     ??zcl_SendReportCmd_5:
   \   000101   02....       LJMP    ?Subroutine9 & 0xFFFF
   1329          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000008   A882         MOV     R0,DPL
   \   00000A   A983         MOV     R1,DPH
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000003                ; Setup parameters for call to function zclSerializeData
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1330          #endif // ZCL_REPORT
   1331          
   1332          /*********************************************************************
   1333           * @fn      zcl_SendDefaultRspCmd
   1334           *
   1335           * @brief   Send a Default Response command
   1336           *
   1337           *          Note: The manufacturer code field should be set if this
   1338           *          command is being sent in response to a manufacturer specific
   1339           *          command.
   1340           *
   1341           * @param   dstAddr - destination address
   1342           * @param   clusterID - cluster ID
   1343           * @param   defaultRspCmd - default response command to be sent
   1344           * @param   direction - direction of the command
   1345           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1346           * @param   seqNum - transaction sequence number
   1347           *
   1348           * @return  ZSuccess if OK
   1349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1350          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1351                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1352                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1353          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   1354            uint8 buf[2]; // Command ID and Status;
   1355          
   1356            // Load the buffer - serially
   1357            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_371:
   \   000014   8882         MOV     DPL,R0
   \   000016   8983         MOV     DPH,R1
   \   000018   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   00001B   12....       LCALL   ?Subroutine109 & 0xFFFF
   1358            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_186:
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   C0E0         PUSH    A
   \   000021   7401         MOV     A,#0x1
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   D0E0         POP     A
   \   000028   F0           MOVX    @DPTR,A
   1359          
   1360            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1361                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000029                ; Setup parameters for call to function zcl_SendCommand
   \   000029   A8..         MOV     R0,?XSP + 0
   \   00002B   A9..         MOV     R1,?XSP + 1
   \   00002D   88..         MOV     ?V0,R0
   \   00002F   89..         MOV     ?V1,R1
   \   000031   78..         MOV     R0,#?V0
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   75..02       MOV     ?V0,#0x2
   \   000039   75..00       MOV     ?V1,#0x0
   \   00003C   78..         MOV     R0,#?V0
   \   00003E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000041   7416         MOV     A,#0x16
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000049   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00004C   7415         MOV     A,#0x15
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000054   7416         MOV     A,#0x16
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005F   7416         MOV     A,#0x16
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006A   75..00       MOV     ?V0,#0x0
   \   00006D   78..         MOV     R0,#?V0
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000072   75..0B       MOV     ?V0,#0xb
   \   000075   78..         MOV     R0,#?V0
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007A   EE           MOV     A,R6
   \   00007B   F9           MOV     R1,A
   \   00007C   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00007F   740B         MOV     A,#0xb
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   7402         MOV     A,#0x2
   \   000086   02....       LJMP    ?Subroutine2 & 0xFFFF
   1362          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine152_0
   \   000003                ; // Fall through to label ??Subroutine152_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine162_0:
   \   000000   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   000003   22           RET
   1363          
   1364          #ifdef ZCL_DISCOVER
   1365          /*********************************************************************
   1366           * @fn      zcl_SendDiscoverCmdsCmd
   1367           *
   1368           * @brief   Send a Discover Commands command
   1369           *
   1370           * @param   dstAddr - destination address
   1371           * @param   clusterID - cluster ID
   1372           * @param   cmdType - requesting command ID
   1373           * @param   pDiscoverCmd - discover command to be sent
   1374           * @param   direction - direction of the command
   1375           * @param   seqNum - transaction sequence number
   1376           *
   1377           * @return  ZSuccess if OK
   1378           */
   1379          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1380                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1381                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1382          {
   1383            uint8 payload[2]; // size of startCmdID and maxCmdID
   1384            ZStatus_t status;
   1385          
   1386            payload[0] = pDiscoverCmd->startCmdID;
   1387            payload[1] = pDiscoverCmd->maxCmdID;
   1388          
   1389            // Send message for either commands received or generated
   1390            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1391            {
   1392              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1393                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1394            }
   1395            else  // generated
   1396            {
   1397              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1398                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1399            }
   1400          
   1401            return ( status );
   1402          }
   1403          
   1404          /*********************************************************************
   1405           * @fn      zcl_SendDiscoverCmdsRspCmd
   1406           *
   1407           * @brief   Send a Discover Commands Response command
   1408           *
   1409           * @param   dstAddr - destination address
   1410           * @param   clusterID - cluster ID
   1411           * @param   pDiscoverRspCmd - response command to be sent
   1412           * @param   direction - direction of the command
   1413           * @param   seqNum - transaction sequence number
   1414           *
   1415           * @return  ZSuccess if OK
   1416           */
   1417          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1418                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1419                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1420          {
   1421            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1422            uint8 *pCmdBuf;
   1423            uint8 i;
   1424            ZStatus_t status = ZSuccess;
   1425          
   1426            // allocate memory
   1427            pCmdBuf = zcl_mem_alloc( payloadSize );
   1428            if ( pCmdBuf != NULL )
   1429            {
   1430              uint8 *pBuf = pCmdBuf;
   1431          
   1432              // Load the buffer - serially
   1433              *pBuf++ = pDiscoverRspCmd->discComplete;
   1434              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1435              {
   1436                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1437              }
   1438          
   1439              // Send response message for either commands received or generated
   1440              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1441              {
   1442                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1443                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1444              }
   1445              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1446              {
   1447                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1448                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1449              }
   1450          
   1451              zcl_mem_free( pCmdBuf );
   1452            }
   1453            else
   1454            {
   1455              status = ZMemError;
   1456            }
   1457          
   1458            return ( status );
   1459          }
   1460          
   1461          /*********************************************************************
   1462           * @fn      zcl_SendDiscoverAttrsCmd
   1463           *
   1464           * @brief   Send a Discover Attributes command
   1465           *
   1466           * @param   dstAddr - destination address
   1467           * @param   clusterID - cluster ID
   1468           * @param   pDiscoverCmd - discover command to be sent
   1469           * @param   direction - direction of the command
   1470           * @param   seqNum - transaction sequence number
   1471           *
   1472           * @return  ZSuccess if OK
   1473           */
   1474          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1475                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1476                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1477          {
   1478            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1479            uint8 *buf;
   1480            ZStatus_t status;
   1481          
   1482            buf = zcl_mem_alloc( dataLen );
   1483            if ( buf != NULL )
   1484            {
   1485              // Load the buffer - serially
   1486              uint8 *pBuf = buf;
   1487              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1488              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1489              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1490          
   1491              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1492                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1493              zcl_mem_free( buf );
   1494            }
   1495            else
   1496            {
   1497              status = ZMemError;
   1498            }
   1499          
   1500            return ( status );
   1501          }
   1502          
   1503          /*********************************************************************
   1504           * @fn      zcl_SendDiscoverAttrsRspCmd
   1505           *
   1506           * @brief   Send a Discover Attributes Response command
   1507           *
   1508           * @param   dstAddr - destination address
   1509           * @param   clusterID - cluster ID
   1510           * @param   reportRspCmd - report response command to be sent
   1511           * @param   direction - direction of the command
   1512           * @param   seqNum - transaction sequence number
   1513           *
   1514           * @return  ZSuccess if OK
   1515           */
   1516          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1517                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1518                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1519          {
   1520            uint16 dataLen = 1; // Discovery complete
   1521            uint8 *buf;
   1522            ZStatus_t status;
   1523          
   1524            // calculate the size of the command
   1525            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1526          
   1527            buf = zcl_mem_alloc( dataLen );
   1528            if ( buf != NULL )
   1529            {
   1530              // Load the buffer - serially
   1531              uint8 i;
   1532              uint8 *pBuf = buf;
   1533          
   1534              *pBuf++ = pDiscoverRspCmd->discComplete;
   1535          
   1536              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1537              {
   1538                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1539                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1540                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1541              }
   1542          
   1543              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1544                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1545              zcl_mem_free( buf );
   1546            }
   1547            else
   1548            {
   1549              status = ZMemError;
   1550            }
   1551          
   1552            return ( status );
   1553          }
   1554          
   1555          /*********************************************************************
   1556           * @fn      zcl_SendDiscoverAttrsExt
   1557           *
   1558           * @brief   Send a Discover Attributes Extended command
   1559           *
   1560           * @param   dstAddr - destination address
   1561           * @param   clusterID - cluster ID
   1562           * @param   pDiscoverAttrsExt:
   1563           *            - startAttrID: the first attribute to be selected
   1564           *            - maxAttrIDs: maximum number of returned attributes
   1565           * @param   direction - direction of the command
   1566           * @param   seqNum - transaction sequence number
   1567           *
   1568           * @return  ZSuccess if OK
   1569           */
   1570          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1571                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1572                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1573          {
   1574            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1575            ZStatus_t status;
   1576          
   1577            // Load the buffer - serially
   1578            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1579            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1580            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1581          
   1582            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1583                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1584          
   1585            return ( status );
   1586          }
   1587          
   1588          /*********************************************************************
   1589           * @fn      zcl_SendDiscoverAttrsExtRsp
   1590           *
   1591           * @brief   Send a Discover Attributes Extended Response command
   1592           *
   1593           * @param   dstAddr - destination address
   1594           * @param   clusterID - cluster ID
   1595           * @param   pDiscoverRspCmd:
   1596           *            - discComplete: indicates whether all requested attributes returned
   1597           *            - attrID: attribute ID
   1598           *            - attrDataType: data type of the given attribute
   1599           *            - attrAccessControl: access control of the given attribute
   1600           * @param   direction - direction of the command
   1601           * @param   seqNum - transaction sequence number
   1602           *
   1603           * @return  ZSuccess if OK
   1604           */
   1605          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1606                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1607                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1608          {
   1609            uint8 *buf;
   1610            uint8 i;
   1611            uint16 dataLen = 1; // Discovery complete
   1612            ZStatus_t status;
   1613          
   1614            // calculate the size of the command
   1615            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1616          
   1617            buf = zcl_mem_alloc( dataLen );
   1618            if ( buf != NULL )
   1619            {
   1620              // Load the buffer - serially
   1621              uint8 *pBuf = buf;
   1622              *pBuf++ = pDiscoverRspCmd->discComplete;
   1623              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1624              {
   1625                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1626                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1627                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1628                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1629              }
   1630          
   1631              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1632                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1633              zcl_mem_free( buf );
   1634            }
   1635            else
   1636            {
   1637              status = ZMemError;
   1638            }
   1639          
   1640            return ( status );
   1641          }
   1642          #endif // ZCL_DISCOVER
   1643          
   1644          /*********************************************************************
   1645           * @fn      zcl_ProcessMessageMSG
   1646           *
   1647           * @brief   Data message processor callback.  This function processes
   1648           *          any incoming data - probably from other devices.  So, based
   1649           *          on cluster ID, perform the intended action.
   1650           *
   1651           * @param   pkt - incoming message
   1652           *
   1653           * @return  zclProcMsgStatus_t
   1654           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1655          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1656          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1657            endPointDesc_t *epDesc;
   1658            zclIncoming_t inMsg;
   1659            zclLibPlugin_t *pInPlugin;
   1660            zclDefaultRspCmd_t defautlRspCmd;
   1661            uint8 options;
   1662            uint8 securityEnable;
   1663            uint8 interPanMsg;
   1664            ZStatus_t status = ZFailure;
   1665            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   1666          
   1667            if ( pkt->cmd.DataLength == 0 ){
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   F5..         MOV     ?V4,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   F5..         MOV     ?V5,A
   \   00001A   85..82       MOV     DPL,?V4
   \   00001D   F583         MOV     DPH,A
   \   00001F   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000022   7005         JNZ     ??zcl_ProcessMessageMSG_0
   1668              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000024   7901         MOV     R1,#0x1
   \   000026   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1669            }
   1670          
   1671            // Initialize
   1672            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000029   90....       MOV     DPTR,#rawAFMsg
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
   1673            inMsg.msg = pkt;
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   EE           MOV     A,R6
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   EF           MOV     A,R7
   \   00003A   F0           MOVX    @DPTR,A
   1674            inMsg.attrCmd = NULL;
   \   00003B   740E         MOV     A,#0xe
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E4           CLR     A
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   F0           MOVX    @DPTR,A
   1675            inMsg.pData = NULL;
   \   000044   740A         MOV     A,#0xa
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   F0           MOVX    @DPTR,A
   1676            inMsg.pDataLen = 0;
   \   00004D   740C         MOV     A,#0xc
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E4           CLR     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   F0           MOVX    @DPTR,A
   1677          
   1678            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000056   EE           MOV     A,R6
   \   000057   2422         ADD     A,#0x22
   \   000059   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   00005C   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AA82         MOV     R2,DPL
   \   000066   AB83         MOV     R3,DPH
   \   000068   12....       LCALL   ??zclParseHdr?relay  ; Banked call to: zclParseHdr
   \   00006B   8A..         MOV     ?V6,R2
   \   00006D   8B..         MOV     ?V7,R3
   \   00006F   A8..         MOV     R0,?V6
   \   000071   A9..         MOV     R1,?V7
   \   000073   740A         MOV     A,#0xa
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1679            inMsg.pDataLen = pkt->cmd.DataLength;
   1680            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_209:
   \   00007B   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   00007E   EA           MOV     A,R2
   \   00007F   C3           CLR     C
   \   000080   98           SUBB    A,R0
   \   000081   F8           MOV     R0,A
   \   000082   EB           MOV     A,R3
   \   000083   99           SUBB    A,R1
   \   000084   F9           MOV     R1,A
   \   000085   85..82       MOV     DPL,?V0
   \   000088   85..83       MOV     DPH,?V1
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   28           ADD     A,R0
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   39           ADDC    A,R1
   \   000091   F9           MOV     R1,A
   \   000092   740C         MOV     A,#0xc
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1681          
   1682            // Temporary workaround to allow callback functions access to the 
   1683            // transaction sequence number.  Callback functions will call 
   1684            // zcl_getParsedTransSeqNum() to retrieve this number.
   1685            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_210:
   \   00009A   7408         MOV     A,#0x8
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A3   F0           MOVX    @DPTR,A
   1686            
   1687            // Find the wanted endpoint
   1688            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A4   EE           MOV     A,R6
   \   0000A5   2414         ADD     A,#0x14
   \   0000A7   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   0000AF   8A82         MOV     DPL,R2
   \   0000B1   8B83         MOV     DPH,R3
   1689            if ( epDesc == NULL )
   \   0000B3   E582         MOV     A,DPL
   \   0000B5   4583         ORL     A,DPH
   \   0000B7   700C         JNZ     ??zcl_ProcessMessageMSG_2
   1690            {
   1691              rawAFMsg = NULL;
   \   0000B9   90....       MOV     DPTR,#rawAFMsg
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   F0           MOVX    @DPTR,A
   1692              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000C0   7902         MOV     R1,#0x2
   \   0000C2   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1693            }
   1694          
   1695            if ( ( epDesc->simpleDesc == NULL ) ||
   1696                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1697                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C5   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   0000C8   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000CA   EE           MOV     A,R6
   \   0000CB   2404         ADD     A,#0x4
   \   0000CD   F5..         MOV     ?V4,A
   \   0000CF   E4           CLR     A
   \   0000D0   3F           ADDC    A,R7
   \   0000D1   F5..         MOV     ?V5,A
   \   0000D3                ; Setup parameters for call to function zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   0000D3   A3           INC     DPTR
   \   0000D4   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D7   740B         MOV     A,#0xb
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FD           MOV     R5,A
   \   0000DE   7406         MOV     A,#0x6
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   5403         ANL     A,#0x3
   \   0000E6   FC           MOV     R4,A
   \   0000E7   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   0000EA   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
   \   0000ED   7402         MOV     A,#0x2
   \   0000EF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F2   E9           MOV     A,R1
   \   0000F3   700C         JNZ     ??zcl_ProcessMessageMSG_4
   1698            {
   1699              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F5   90....       MOV     DPTR,#rawAFMsg
   \   0000F8   E4           CLR     A
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   A3           INC     DPTR
   \   0000FB   F0           MOVX    @DPTR,A
   1700              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FC   7903         MOV     R1,#0x3
   \   0000FE   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1701            }
   1702          
   1703          #if defined ( INTER_PAN )
   1704            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1705            {
   1706              // No foundation command is supported thru Inter-PAN communication.
   1707              // But the Light Link cluster uses a different Frame Control format
   1708              // for it's Inter-PAN messages, where the messages could be confused
   1709              // with the foundation commands.
   1710              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1711              {
   1712                rawAFMsg = NULL;
   1713                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   1714              }
   1715          
   1716              interPanMsg = TRUE;
   1717              options = AF_TX_OPTIONS_NONE;
   1718            }
   1719            else
   1720          #endif
   1721            {
   1722              interPanMsg = FALSE;
   1723              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000101                ; Setup parameters for call to function zclGetClusterOption(uint8, uint16)
   \   000101   12....       LCALL   ?Subroutine50 & 0xFFFF
   1724            }
   \                     ??CrossCallReturnLabel_59:
   \   000104   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption(uint8, uint16)
   \   000107   E9           MOV     A,R1
   \   000108   F5..         MOV     ?V3,A
   1725          
   1726            // Find the appropriate plugin
   1727            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   00010A   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   00010D   EA           MOV     A,R2
   \   00010E   FC           MOV     R4,A
   \   00010F   EB           MOV     A,R3
   \   000110   FD           MOV     R5,A
   \   000111   90....       MOV     DPTR,#plugins
   \   000114   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000116   8882         MOV     DPL,R0
   \   000118   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00011A   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   00011D   7003         JNZ     $+5
   \   00011F   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000122   8882         MOV     DPL,R0
   \   000124   8983         MOV     DPH,R1
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   12....       LCALL   ??Subroutine165_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   00012B   C3           CLR     C
   \   00012C   EC           MOV     A,R4
   \   00012D   95..         SUBB    A,?V6
   \   00012F   ED           MOV     A,R5
   \   000130   95..         SUBB    A,?V7
   \   000132   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000134   8882         MOV     DPL,R0
   \   000136   8983         MOV     DPH,R1
   \   000138   A3           INC     DPTR
   \   000139   A3           INC     DPTR
   \   00013A   A3           INC     DPTR
   \   00013B   A3           INC     DPTR
   \   00013C   C3           CLR     C
   \   00013D   E0           MOVX    A,@DPTR
   \   00013E   9C           SUBB    A,R4
   \   00013F   A3           INC     DPTR
   \   000140   E0           MOVX    A,@DPTR
   \   000141   9D           SUBB    A,R5
   \   000142   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000144   E8           MOV     A,R0
   \   000145   FC           MOV     R4,A
   \   000146   E9           MOV     A,R1
   \   000147   FD           MOV     R5,A
   \   000148   7404         MOV     A,#0x4
   \   00014A   12....       LCALL   ?XSTACK_DISP0_8
   \   00014D   E0           MOVX    A,@DPTR
   \   00014E   5407         ANL     A,#0x7
   \   000150   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000152   7409         MOV     A,#0x9
   \   000154   12....       LCALL   ?XSTACK_DISP0_8
   \   000157   E0           MOVX    A,@DPTR
   \   000158   640B         XRL     A,#0xb
   \   00015A   7003         JNZ     $+5
   \   00015C   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1728          
   1729            // Local and remote Security options must match except for Default Response command
   1730            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1731            {
   1732              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   00015F   E5..         MOV     A,?V3
   \   000161   A2E6         MOV     C,0xE0 /* A   */.6
   \   000163   4003         JC      $+5
   \   000165   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   000168   EE           MOV     A,R6
   \   000169   2419         ADD     A,#0x19
   \   00016B   F582         MOV     DPL,A
   \   00016D   E4           CLR     A
   \   00016E   3F           ADDC    A,R7
   \   00016F   F583         MOV     DPH,A
   \   000171   E0           MOVX    A,@DPTR
   \   000172   6003         JZ      $+5
   \   000174   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1733          
   1734              // Make sure that Clusters specifically defined to use security are received secure,
   1735              // any other cluster that wants to use APS security will be allowed
   1736              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1737              {
   1738                if ( UNICAST_MSG( inMsg.msg ) ) {
   \   000177   7402         MOV     A,#0x2
   \   000179   12....       LCALL   ?XSTACK_DISP0_8
   \   00017C   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00017F   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   000181   7402         MOV     A,#0x2
   \   000183   12....       LCALL   ?XSTACK_DISP0_8
   \   000186   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000189   7073         JNZ     ??zcl_ProcessMessageMSG_10
   1739                  // Send a Default Response command back with no Application Link Key security
   1740                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00018B                ; Setup parameters for call to function zclSetSecurityOption(uint8, uint16, uint8)
   \   00018B   7C00         MOV     R4,#0x0
   \   00018D   85..82       MOV     DPL,?V0
   \   000190   85..83       MOV     DPH,?V1
   \   000193   E0           MOVX    A,@DPTR
   \   000194   F9           MOV     R1,A
   \   000195   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption(uint8, uint16, uint8)
   1741          
   1742                  defautlRspCmd.statusCode = status;
   \   000198   7401         MOV     A,#0x1
   \   00019A   12....       LCALL   ?XSTACK_DISP0_8
   \   00019D   7401         MOV     A,#0x1
   \   00019F   F0           MOVX    @DPTR,A
   1743                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A0   7409         MOV     A,#0x9
   \   0001A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A5   12....       LCALL   ?Subroutine82 & 0xFFFF
   1744                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr), inMsg.msg->clusterId, &defautlRspCmd, !inMsg.hdr.fc.direction, true,  inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_128:
   \   0001A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AB   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0001AE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B1   7407         MOV     A,#0x7
   \   0001B3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001B9   75..01       MOV     ?V2,#0x1
   \   0001BC   78..         MOV     R0,#?V2
   \   0001BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C1   7408         MOV     A,#0x8
   \   0001C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C6   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   0001C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001CC   7405         MOV     A,#0x5
   \   0001CE   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D1   88..         MOV     ?V2,R0
   \   0001D3   89..         MOV     ?V3,R1
   \   0001D5   78..         MOV     R0,#?V2
   \   0001D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DA   7409         MOV     A,#0x9
   \   0001DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DF   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0001E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E5   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   0001E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EB   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0001EE   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   0001F1   7407         MOV     A,#0x7
   \   0001F3   12....       LCALL   ?DEALLOC_XSTACK8
   1745                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001F6                ; Setup parameters for call to function zclSetSecurityOption(uint8, uint16, uint8)
   \   0001F6   7C01         MOV     R4,#0x1
   \   0001F8   12....       LCALL   ?Subroutine50 & 0xFFFF
   1746                }
   \                     ??CrossCallReturnLabel_60:
   \   0001FB   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption(uint8, uint16, uint8)
   1747          
   1748                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   0001FE   90....       MOV     DPTR,#rawAFMsg
   \   000201   E4           CLR     A
   \   000202   F0           MOVX    @DPTR,A
   \   000203   A3           INC     DPTR
   \   000204   F0           MOVX    @DPTR,A
   1749                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000205   7905         MOV     R1,#0x5
   \   000207   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1750              }
   1751            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00020A   7C00         MOV     R4,#0x0
   \   00020C   7D00         MOV     R5,#0x0
   1752          
   1753            // Is this a foundation type message
   1754           	if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) ) {
   \                     ??zcl_ProcessMessageMSG_9:
   \   00020E   7404         MOV     A,#0x4
   \   000210   12....       LCALL   ?XSTACK_DISP0_8
   \   000213   E0           MOVX    A,@DPTR
   \   000214   F8           MOV     R0,A
   \   000215   5403         ANL     A,#0x3
   \   000217   6003         JZ      $+5
   \   000219   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   1755              	if ( inMsg.hdr.fc.manuSpecific ) {
   \   00021C   E8           MOV     A,R0
   \   00021D   5404         ANL     A,#0x4
   \   00021F   6005         JZ      ??zcl_ProcessMessageMSG_12
   1756                		// We don't support any manufacturer specific command
   1757                		status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000221   7E84         MOV     R6,#-0x7c
   \   000223   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   1758              	} else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) && ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) ){
   \                     ??zcl_ProcessMessageMSG_12:
   \   000226   7409         MOV     A,#0x9
   \   000228   12....       LCALL   ?XSTACK_DISP0_8
   \   00022B   E0           MOVX    A,@DPTR
   \   00022C   F5..         MOV     ?V4,A
   \   00022E   C3           CLR     C
   \   00022F   9417         SUBB    A,#0x17
   \   000231   4003         JC      $+5
   \   000233   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   000236   75..00       MOV     ?V5,#0x0
   \   000239   7402         MOV     A,#0x2
   \   00023B   78..         MOV     R0,#?V4
   \   00023D   12....       LCALL   ?S_SHL
   \   000240   74..         MOV     A,#zclCmdTable & 0xff
   \   000242   25..         ADD     A,?V4
   \   000244   F582         MOV     DPL,A
   \   000246   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   000248   35..         ADDC    A,?V5
   \   00024A   F583         MOV     DPH,A
   \   00024C   E4           CLR     A
   \   00024D   93           MOVC    A,@A+DPTR
   \   00024E   F8           MOV     R0,A
   \   00024F   7401         MOV     A,#0x1
   \   000251   93           MOVC    A,@A+DPTR
   \   000252   F9           MOV     R1,A
   \   000253   E8           MOV     A,R0
   \   000254   49           ORL     A,R1
   \   000255   7003         JNZ     $+5
   \   000257   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   1759          			zclParseCmd_t parseCmd;
   1760          
   1761          			parseCmd.endpoint = pkt->endPoint;
   \   00025A   85..82       MOV     DPL,?V0
   \   00025D   85..83       MOV     DPH,?V1
   \   000260   E0           MOVX    A,@DPTR
   \   000261   C0E0         PUSH    A
   \   000263   7410         MOV     A,#0x10
   \   000265   12....       LCALL   ?XSTACK_DISP0_8
   \   000268   D0E0         POP     A
   \   00026A   F0           MOVX    @DPTR,A
   1762          			parseCmd.dataLen = inMsg.pDataLen;
   \   00026B   740C         MOV     A,#0xc
   \   00026D   12....       LCALL   ?XSTACK_DISP0_8
   \   000270   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000273   7411         MOV     A,#0x11
   \   000275   12....       LCALL   ?XSTACK_DISP0_8
   \   000278   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1763          			parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_211:
   \   00027B   740A         MOV     A,#0xa
   \   00027D   12....       LCALL   ?XSTACK_DISP0_8
   \   000280   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   000283   7413         MOV     A,#0x13
   \   000285   12....       LCALL   ?XSTACK_DISP0_8
   \   000288   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1764          
   1765          			// Parse the command, remember that the return value is a pointer to allocated memory
   1766          			inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_212:
   \   00028B                ; Setup parameters for indirect call
   \   00028B   7410         MOV     A,#0x10
   \   00028D   12....       LCALL   ?XSTACK_DISP101_8
   \   000290   7409         MOV     A,#0x9
   \   000292   12....       LCALL   ?XSTACK_DISP0_8
   \   000295   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000298   12....       LCALL   ?S_SHL
   \   00029B   74..         MOV     A,#zclCmdTable & 0xff
   \   00029D   25..         ADD     A,?V0
   \   00029F   F582         MOV     DPL,A
   \   0002A1   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002A3   35..         ADDC    A,?V1
   \   0002A5   F583         MOV     DPH,A
   \   0002A7   E4           CLR     A
   \   0002A8   93           MOVC    A,@A+DPTR
   \   0002A9   C0E0         PUSH    A
   \   0002AB   7401         MOV     A,#0x1
   \   0002AD   93           MOVC    A,@A+DPTR
   \   0002AE   F583         MOV     DPH,A
   \   0002B0   D082         POP     DPL
   \   0002B2   12....       LCALL   ?CALL_IND
   \   0002B5   8A..         MOV     ?V0,R2
   \   0002B7   8B..         MOV     ?V1,R3
   \   0002B9   A8..         MOV     R0,?V0
   \   0002BB   A9..         MOV     R1,?V1
   \   0002BD   740E         MOV     A,#0xe
   \   0002BF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C2   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   1767          			if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) ) {
   \                     ??CrossCallReturnLabel_213:
   \   0002C5   E8           MOV     A,R0
   \   0002C6   49           ORL     A,R1
   \   0002C7   6045         JZ      ??zcl_ProcessMessageMSG_15
   \   0002C9   7409         MOV     A,#0x9
   \   0002CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002CE   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   0002D1   12....       LCALL   ?S_SHL
   \   0002D4   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002D6   25..         ADD     A,?V0
   \   0002D8   F582         MOV     DPL,A
   \   0002DA   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002DC   35..         ADDC    A,?V1
   \   0002DE   F583         MOV     DPH,A
   \   0002E0   E4           CLR     A
   \   0002E1   93           MOVC    A,@A+DPTR
   \   0002E2   F8           MOV     R0,A
   \   0002E3   7401         MOV     A,#0x1
   \   0002E5   93           MOVC    A,@A+DPTR
   \   0002E6   F9           MOV     R1,A
   \   0002E7   8882         MOV     DPL,R0
   \   0002E9   8983         MOV     DPH,R1
   \   0002EB   E582         MOV     A,DPL
   \   0002ED   4583         ORL     A,DPH
   \   0002EF   6012         JZ      ??zcl_ProcessMessageMSG_16
   1768          				// Process the command
   1769          				if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE ) {
   \   0002F1                ; Setup parameters for indirect call
   \   0002F1   7402         MOV     A,#0x2
   \   0002F3   12....       LCALL   ?XSTACK_DISP101_8
   \   0002F6   12....       LCALL   ?CALL_IND
   1770          					// Couldn't find attribute in the table.
   1771          				}
   1772          			}
   1773          
   1774          			// Free the buffer
   1775          			if ( inMsg.attrCmd )	{
   \   0002F9   740E         MOV     A,#0xe
   \   0002FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002FE   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000301   600B         JZ      ??zcl_ProcessMessageMSG_15
   1776          				zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   000303                ; Setup parameters for call to function osal_mem_free
   \   000303   740E         MOV     A,#0xe
   \   000305   12....       LCALL   ?XSTACK_DISP0_8
   \   000308   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   1777          			}
   \                     ??CrossCallReturnLabel_261:
   \   00030B   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   1778          
   1779          			if ( CMD_HAS_RSP( inMsg.hdr.commandID ) ) {
   \                     ??zcl_ProcessMessageMSG_15:
   \   00030E   7409         MOV     A,#0x9
   \   000310   12....       LCALL   ?XSTACK_DISP0_8
   \   000313   E0           MOVX    A,@DPTR
   \   000314   F8           MOV     R0,A
   \   000315   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   000317   7402         MOV     A,#0x2
   \   000319   68           XRL     A,R0
   \   00031A   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   00031C   7403         MOV     A,#0x3
   \   00031E   68           XRL     A,R0
   \   00031F   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000321   7406         MOV     A,#0x6
   \   000323   68           XRL     A,R0
   \   000324   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   000326   7408         MOV     A,#0x8
   \   000328   68           XRL     A,R0
   \   000329   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00032B   740C         MOV     A,#0xc
   \   00032D   68           XRL     A,R0
   \   00032E   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   000330   7411         MOV     A,#0x11
   \   000332   68           XRL     A,R0
   \   000333   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000335   7413         MOV     A,#0x13
   \   000337   68           XRL     A,R0
   \   000338   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   00033A   7415         MOV     A,#0x15
   \   00033C   68           XRL     A,R0
   \   00033D   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   00033F   740B         MOV     A,#0xb
   \   000341   68           XRL     A,R0
   \   000342   6027         JZ      ??zcl_ProcessMessageMSG_17
   1780          				rawAFMsg = NULL;
   1781          				return ( ZCL_PROC_SUCCESS ); // We're done
   1782          			}
   1783          
   1784          			status = ZSuccess;
   \   000344   7E00         MOV     R6,#0x0
   \   000346   8043         SJMP    ??zcl_ProcessMessageMSG_13
   1785          		} else {
   1786          			// Unsupported message
   1787          			status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   000348   7E82         MOV     R6,#-0x7e
   \   00034A   803F         SJMP    ??zcl_ProcessMessageMSG_13
   1788          		}
   1789            	} else {  // Not a foundation type message, so it must be specific to the cluster ID.
   1790           		if ( pInPlugin && pInPlugin->pfnIncomingHdlr ) {
   \                     ??zcl_ProcessMessageMSG_11:
   \   00034C   EC           MOV     A,R4
   \   00034D   4D           ORL     A,R5
   \   00034E   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   000350   8C82         MOV     DPL,R4
   \   000352   8D83         MOV     DPH,R5
   \   000354   A3           INC     DPTR
   \   000355   A3           INC     DPTR
   \   000356   A3           INC     DPTR
   \   000357   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   00035A   601F         JZ      ??zcl_ProcessMessageMSG_18
   1791                // The return value of the plugin function will be
   1792                //  ZSuccess - Supported and need default response
   1793                //  ZFailure - Unsupported
   1794                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1795                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1796                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1797                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1798                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00035C                ; Setup parameters for indirect call
   \   00035C   7402         MOV     A,#0x2
   \   00035E   12....       LCALL   ?XSTACK_DISP101_8
   \   000361   12....       LCALL   ?CALL_IND
   \   000364   E9           MOV     A,R1
   \   000365   FE           MOV     R6,A
   1799                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000366   74FF         MOV     A,#-0x1
   \   000368   6E           XRL     A,R6
   \   000369   700B         JNZ     ??zcl_ProcessMessageMSG_19
   1800                {
   1801                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00036B   90....       MOV     DPTR,#rawAFMsg
   \   00036E   E4           CLR     A
   \   00036F   F0           MOVX    @DPTR,A
   \   000370   A3           INC     DPTR
   \   000371   F0           MOVX    @DPTR,A
   1802                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000372   F9           MOV     R1,A
   \   000373   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1803                }
   1804              }
   1805          
   1806              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000376   7401         MOV     A,#0x1
   \   000378   6E           XRL     A,R6
   \   000379   7010         JNZ     ??zcl_ProcessMessageMSG_13
   1807              {
   1808                // Unsupported message
   1809                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00037B   7404         MOV     A,#0x4
   \   00037D   12....       LCALL   ?XSTACK_DISP0_8
   \   000380   E0           MOVX    A,@DPTR
   \   000381   5404         ANL     A,#0x4
   \   000383   6004         JZ      ??zcl_ProcessMessageMSG_20
   1810                {
   1811                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000385   7E83         MOV     R6,#-0x7d
   \   000387   8002         SJMP    ??zcl_ProcessMessageMSG_13
   1812                }
   1813                else
   1814                {
   1815                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   000389   7E81         MOV     R6,#-0x7f
   1816                }
   1817              }
   1818            }
   1819          
   1820            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00038B   7402         MOV     A,#0x2
   \   00038D   12....       LCALL   ?XSTACK_DISP0_8
   \   000390   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   000393   7074         JNZ     ??zcl_ProcessMessageMSG_21
   \   000395   7402         MOV     A,#0x2
   \   000397   12....       LCALL   ?XSTACK_DISP0_8
   \   00039A   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   00039D   706A         JNZ     ??zcl_ProcessMessageMSG_21
   \   00039F   7404         MOV     A,#0x4
   \   0003A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A4   E0           MOVX    A,@DPTR
   \   0003A5   5410         ANL     A,#0x10
   \   0003A7   7060         JNZ     ??zcl_ProcessMessageMSG_21
   1821            {
   1822              // Send a Default Response command back
   1823              defautlRspCmd.statusCode = status;
   \   0003A9   7401         MOV     A,#0x1
   \   0003AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003AE   EE           MOV     A,R6
   \   0003AF   F0           MOVX    @DPTR,A
   1824              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003B0   7409         MOV     A,#0x9
   \   0003B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B5   12....       LCALL   ?Subroutine82 & 0xFFFF
   1825              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1826                                     inMsg.msg->clusterId, &defautlRspCmd,
   1827                                     !inMsg.hdr.fc.direction, true,
   1828                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_129:
   \   0003B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BB   12....       LCALL   ??Subroutine147_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   0003BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C1   7407         MOV     A,#0x7
   \   0003C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C6   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003C9   75..01       MOV     ?V0,#0x1
   \   0003CC   78..         MOV     R0,#?V0
   \   0003CE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D1   7408         MOV     A,#0x8
   \   0003D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D6   12....       LCALL   ??Subroutine164_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   0003D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003DC   7405         MOV     A,#0x5
   \   0003DE   12....       LCALL   ?XSTACK_DISP100_8
   \   0003E1   88..         MOV     ?V0,R0
   \   0003E3   89..         MOV     ?V1,R1
   \   0003E5   78..         MOV     R0,#?V0
   \   0003E7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003EA   7409         MOV     A,#0x9
   \   0003EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003EF   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0003F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F5   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   0003F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FB   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   0003FE   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   000401   7407         MOV     A,#0x7
   \   000403   12....       LCALL   ?DEALLOC_XSTACK8
   1829              defaultResponseSent = TRUE;
   \   000406   75..01       MOV     ?V2,#0x1
   1830            }
   1831          
   1832            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000409   90....       MOV     DPTR,#rawAFMsg
   \   00040C   E4           CLR     A
   \   00040D   F0           MOVX    @DPTR,A
   \   00040E   A3           INC     DPTR
   \   00040F   F0           MOVX    @DPTR,A
   1833            if ( status == ZSuccess )
   \   000410   EE           MOV     A,R6
   \   000411   7004         JNZ     ??zcl_ProcessMessageMSG_22
   1834            {
   1835              return ( ZCL_PROC_SUCCESS );
   \   000413   7900         MOV     R1,#0x0
   \   000415   801F         SJMP    ??zcl_ProcessMessageMSG_1
   1836            }
   1837            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   000417   7484         MOV     A,#-0x7c
   \   000419   6E           XRL     A,R6
   \   00041A   700E         JNZ     ??zcl_ProcessMessageMSG_23
   1838            {
   1839              if ( defaultResponseSent )
   \   00041C   E5..         MOV     A,?V2
   \   00041E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000420   5004         JNC     ??zcl_ProcessMessageMSG_24
   1840              {
   1841                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   000422   7907         MOV     R1,#0x7
   \   000424   8010         SJMP    ??zcl_ProcessMessageMSG_1
   1842              }
   1843              else
   1844              {
   1845                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   000426   7906         MOV     R1,#0x6
   \   000428   800C         SJMP    ??zcl_ProcessMessageMSG_1
   1846              }
   1847            }
   1848            else
   1849            {
   1850              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   00042A   E5..         MOV     A,?V2
   \   00042C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00042E   5004         JNC     ??zcl_ProcessMessageMSG_25
   1851              {
   1852                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000430   7909         MOV     R1,#0x9
   \   000432   8002         SJMP    ??zcl_ProcessMessageMSG_1
   1853              }
   1854              else
   1855              {
   1856                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   000434   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   000436   7415         MOV     A,#0x15
   \   000438   12....       LCALL   ?DEALLOC_XSTACK8
   \   00043B   7F08         MOV     R7,#0x8
   \   00043D   02....       LJMP    ?BANKED_LEAVE_XDATA
   1857              }
   1858            }
   1859          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine144_0
   \   000006                ; // Fall through to label ??Subroutine144_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C8           XCH     A,R0
   \   000005   2415         ADD     A,#0x15
   \   000007   F582         MOV     DPL,A
   \   000009   E4           CLR     A
   \   00000A   38           ADDC    A,R0
   \   00000B   F583         MOV     DPH,A
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_395:
   \   000003   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine145_0
   \   000004                ; // Fall through to label ??Subroutine145_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_401:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine146_0
   \   000003                ; // Fall through to label ??Subroutine146_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine146_0:
   \   000000   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_394:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine153_0
   \   000005                ; // Fall through to label ??Subroutine153_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000003   F5..         MOV     ?V2,A
   \   000005   78..         MOV     R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine164_0:
   \   000000   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000003   F5..         MOV     ?V0,A
   \   000005   78..         MOV     R0,#?V0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine165_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine166_0
   \   000003                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F583         MOV     DPH,A
   \   000003   8882         MOV     DPL,R0
   \   000005   22           RET
   1860          
   1861          /*********************************************************************
   1862           * PRIVATE FUNCTIONS
   1863           *********************************************************************/
   1864          
   1865          /*********************************************************************
   1866           * @fn      zclParseHdr
   1867           *
   1868           * @brief   Parse header of the ZCL format
   1869           *
   1870           * @param   hdr - place to put the frame control information
   1871           * @param   pData - incoming buffer to parse
   1872           *
   1873           * @return  pointer past the header
   1874           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1875          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1876          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1877            // Clear the header
   1878            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1879          
   1880            // Parse the Frame Control
   1881            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   FA           MOV     R2,A
   \   00002B   E8           MOV     A,R0
   \   00002C   4A           ORL     A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine32 & 0xFFFF
   1882            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_30:
   \   000031   A2E2         MOV     C,0xE0 /* A   */.2
   \   000033   5004         JNC     ??zclParseHdr_0
   \   000035   D2F0         SETB    B.0
   \   000037   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000039   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   00003B   E8           MOV     A,R0
   \   00003C   54FB         ANL     A,#0xfb
   \   00003E   FA           MOV     R2,A
   \   00003F   A2F0         MOV     C,B.0
   \   000041   E4           CLR     A
   \   000042   33           RLC     A
   \   000043   F5..         MOV     ?V2,A
   \   000045   75..00       MOV     ?V3,#0x0
   \   000048   7402         MOV     A,#0x2
   \   00004A   78..         MOV     R0,#?V2
   \   00004C   12....       LCALL   ?S_SHL
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V2
   \   000052   12....       LCALL   ?Subroutine32 & 0xFFFF
   1883            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_31:
   \   000055   A2E3         MOV     C,0xE0 /* A   */.3
   \   000057   85..82       MOV     DPL,?V0
   \   00005A   85..83       MOV     DPH,?V1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5004         JNC     ??zclParseHdr_2
   1884            {
   1885              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000060   4408         ORL     A,#0x8
   \   000062   8002         SJMP    ??zclParseHdr_3
   1886            }
   1887            else
   1888            {
   1889              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000064   54F7         ANL     A,#0xf7
   1890            }
   \                     ??zclParseHdr_3:
   \   000066   12....       LCALL   ?Subroutine110 & 0xFFFF
   1891          
   1892            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_292:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   D2F0         SETB    B.0
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0
   \   000077   85..83       MOV     DPH,?V1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   FA           MOV     R2,A
   \   00007E   A2F0         MOV     C,B.0
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F5..         MOV     ?V2,A
   \   000084   7404         MOV     A,#0x4
   \   000086   78..         MOV     R0,#?V2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   EA           MOV     A,R2
   \   00008C   45..         ORL     A,?V2
   \   00008E   F8           MOV     R0,A
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   12....       LCALL   ??Subroutine154_0 & 0xFFFF
   1893            pData++;  // move past the frame control field
   1894          
   1895            // parse the manfacturer code
   1896            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_322:
   \   000095   E8           MOV     A,R0
   \   000096   5404         ANL     A,#0x4
   \   000098   600A         JZ      ??zclParseHdr_6
   1897            {
   1898              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   12....       LCALL   ?Subroutine76 & 0xFFFF
   1899              pData += 2;
   1900            }
   \                     ??CrossCallReturnLabel_116:
   \   00009E   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   0000A1   5001         JNC     ??zclParseHdr_6
   \   0000A3   0F           INC     R7
   1901          
   1902            // parse the Transaction Sequence Number
   1903            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   85..82       MOV     DPL,?V0
   \   0000AC   85..83       MOV     DPH,?V1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   12....       LCALL   ??Subroutine149_0 & 0xFFFF
   1904          
   1905            // parse the Cluster's command ID
   1906            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_298:
   \   0000B5   85..82       MOV     DPL,?V0
   \   0000B8   85..83       MOV     DPH,?V1
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   12....       LCALL   ?Subroutine28 & 0xFFFF
   1907          
   1908            // Should point to the frame payload
   1909            return ( pData );
   \                     ??CrossCallReturnLabel_290:
   \   0000C0   AA82         MOV     R2,DPL
   \   0000C2   AB83         MOV     R3,DPH
   \   0000C4   02....       LJMP    ?Subroutine1 & 0xFFFF
   1910          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine148_0
   \   000003                ; // Fall through to label ??Subroutine148_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine149_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine150_0
   \   000001                ; // Fall through to label ??Subroutine150_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine150_0:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine154_0:
   \   000000   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   AE82         MOV     R6,DPL
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EA           MOV     A,R2
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine157_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET
   1911          
   1912          /*********************************************************************
   1913           * @fn      zclBuildHdr
   1914           *
   1915           * @brief   Build header of the ZCL format
   1916           *
   1917           * @param   hdr - outgoing header information
   1918           * @param   pData - outgoing header space
   1919           *
   1920           * @return  pointer past the header
   1921           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1922          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     ??zclBuildHdr:
   1923          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1924            // Build the Frame Control byte
   1925            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine151_0 & 0xFFFF
   1926            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_303:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine34 & 0xFFFF
   1927            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_301:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine34 & 0xFFFF
   1928            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_302:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   12....       LCALL   ?Subroutine107 & 0xFFFF
   1929            pData++;  // move past the frame control field
   1930          
   1931            // Add the manfacturer code
   1932            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_182:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   6011         JZ      ??CrossCallReturnLabel_249
   1933            {
   1934              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   EA           MOV     A,R2
   \   00002F   2402         ADD     A,#0x2
   \   000031   F8           MOV     R0,A
   \   000032   E4           CLR     A
   \   000033   3B           ADDC    A,R3
   \   000034   F9           MOV     R1,A
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   12....       LCALL   ?Subroutine29 & 0xFFFF
   1935              *pData++ = HI_UINT16( hdr->manuCode );
   1936            }
   \                     ??CrossCallReturnLabel_27:
   \   00003C   12....       LCALL   ??Subroutine143_0 & 0xFFFF
   1937          
   1938            // Add the Transaction Sequence Number
   1939            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_249:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   12....       LCALL   ?Subroutine26 & 0xFFFF
   1940          
   1941            // Add the Cluster's command ID
   1942            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_23:
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   12....       LCALL   ?Subroutine129 & 0xFFFF
   1943          
   1944            // Should point to the frame payload
   1945            return ( pData );
   \                     ??CrossCallReturnLabel_255:
   \   000051   AA82         MOV     R2,DPL
   \   000053   AB83         MOV     R3,DPH
   \   000055                REQUIRE ?Subroutine6
   \   000055                ; // Fall through to label ?Subroutine6
   1946          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine151_0
   \   000007                ; // Fall through to label ??Subroutine151_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine151_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   1947          
   1948          /*********************************************************************
   1949           * @fn      zclCalcHdrSize
   1950           *
   1951           * @brief   Calculate the number of bytes needed for an outgoing
   1952           *          ZCL header.
   1953           *
   1954           * @param   hdr - outgoing header information
   1955           *
   1956           * @return  returns the number of bytes needed
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   \                     ??zclCalcHdrSize:
   1959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   \   000004   7903         MOV     R1,#0x3
   1961          
   1962            // Add the manfacturer code
   1963            if ( hdr->fc.manuSpecific )
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   5404         ANL     A,#0x4
   \   00000D   6002         JZ      ??zclCalcHdrSize_1
   1964            {
   1965              needed += 2;
   \   00000F   09           INC     R1
   \   000010   09           INC     R1
   1966            }
   1967          
   1968            return ( needed );
   \                     ??zclCalcHdrSize_1:
   \   000011                REQUIRE ?Subroutine0
   \   000011                ; // Fall through to label ?Subroutine0
   1969          }
   1970          
   1971          /*********************************************************************
   1972           * @fn      zclFindPlugin
   1973           *
   1974           * @brief   Find the right plugin for a cluster ID
   1975           *
   1976           * @param   clusterID - cluster ID to look for
   1977           * @param   profileID - profile ID
   1978           *
   1979           * @return  pointer to plugin, NULL if not found
   1980           */
   1981          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1982          {
   1983            zclLibPlugin_t *pLoop = plugins;
   1984          
   1985            (void)profileID;  // Intentionally unreferenced parameter
   1986          
   1987            while ( pLoop != NULL )
   1988            {
   1989              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   1990              {
   1991                return ( pLoop );
   1992              }
   1993          
   1994              pLoop = pLoop->next;
   1995            }
   1996          
   1997            return ( (zclLibPlugin_t *)NULL );
   1998          }
   1999          
   2000          #ifdef ZCL_DISCOVER
   2001          /*********************************************************************
   2002           * @fn      zclFindCmdRecsList
   2003           *
   2004           * @brief   Find the right command record list for an endpoint
   2005           *
   2006           * @param   endpoint - endpoint to look for
   2007           *
   2008           * @return  pointer to record list, NULL if not found
   2009           */
   2010          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2011          {
   2012            zclCmdRecsList_t *pLoop = gpCmdList;
   2013          
   2014            while ( pLoop != NULL )
   2015            {
   2016              if ( pLoop->endpoint == endpoint )
   2017              {
   2018                return ( pLoop );
   2019              }
   2020          
   2021              pLoop = pLoop->pNext;
   2022            }
   2023          
   2024            return ( NULL );
   2025          }
   2026          
   2027          /*********************************************************************
   2028           * @fn      zclFindCmdRec
   2029           *
   2030           * @brief   Find the command record that matchs the parameters
   2031           *
   2032           * @param   endpoint - Application's endpoint
   2033           * @param   clusterID - cluster ID
   2034           * @param   attrId - attribute looking for
   2035           * @param   pAttr - attribute record to be returned
   2036           *
   2037           * @return  TRUE if record found. FALSE, otherwise.
   2038           */
   2039          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2040          {
   2041            uint8 i;
   2042            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2043          
   2044            if ( pRec != NULL )
   2045            {
   2046              for ( i = 0; i < pRec->numCommands; i++ )
   2047              {
   2048                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2049                {
   2050                  *pCmd = pRec->pCmdRecs[i];
   2051          
   2052                  return ( TRUE ); // EMBEDDED RETURN
   2053                }
   2054              }
   2055            }
   2056          
   2057            return ( FALSE );
   2058          }
   2059          #endif // ZCL_DISCOVER
   2060          
   2061          
   2062          /*********************************************************************
   2063           * @fn      zclFindClusterOption
   2064           *
   2065           * @brief   Find the option record that matchs the cluster id
   2066           *
   2067           * @param   endpoint - Application's endpoint
   2068           * @param   clusterID - cluster ID looking for
   2069           *
   2070           * @return  pointer to clutser option, NULL if not found
   2071           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2072          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     ??zclFindClusterOption:
   2073          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2074            zclClusterOptionList *pLoop;
   2075          
   2076            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   8004         SJMP    ??zclFindClusterOption_1
   2077            while ( pLoop != NULL )
   2078            {
   2079              if ( pLoop->endpoint == endpoint )
   2080              {
   2081                uint8 x;
   2082                for ( x = 0; x < pLoop->numOptions; x++ )
   2083                {
   2084                  if ( pLoop->options[x].clusterID == clusterID )
   2085                  {
   2086                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2087                  }
   2088                }
   2089              }
   2090          
   2091              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_2:
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_1:
   \   000014   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000017   6047         JZ      ??zclFindClusterOption_3
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   70ED         JNZ     ??zclFindClusterOption_2
   \   000023   75..00       MOV     ?V0,#0x0
   \   000026   8002         SJMP    ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_5:
   \   000028   05..         INC     ?V0
   \                     ??zclFindClusterOption_4:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   E5..         MOV     A,?V0
   \   000035   C3           CLR     C
   \   000036   9A           SUBB    A,R2
   \   000037   50D7         JNC     ??zclFindClusterOption_2
   \   000039   E5..         MOV     A,?V0
   \   00003B   75F003       MOV     B,#0x3
   \   00003E   A4           MUL     AB
   \   00003F   FA           MOV     R2,A
   \   000040   ABF0         MOV     R3,B
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   3B           ADDC    A,R3
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6C           XRL     A,R4
   \   000057   7003         JNZ     ??zclFindClusterOption_6
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6D           XRL     A,R5
   \                     ??zclFindClusterOption_6:
   \   00005C   70CA         JNZ     ??zclFindClusterOption_5
   \   00005E   8004         SJMP    ??zclFindClusterOption_7
   2092            }
   2093          
   2094            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_7:
   \   000064   02....       LJMP    ?Subroutine6 & 0xFFFF
   2095          }
   2096          
   2097          /*********************************************************************
   2098           * @fn      zclGetClusterOption
   2099           *
   2100           * @brief   Get the option record that matchs the cluster id
   2101           *
   2102           * @param   endpoint - Application's endpoint
   2103           * @param   clusterID - cluster ID looking for
   2104           *
   2105           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2106           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2107          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     ??zclGetClusterOption:
   2108          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2109            uint8 option;
   2110            zclOptionRec_t *pOption;
   2111          
   2112            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption(uint8, uint16)
   \   000005   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption(uint8, uint16)
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2113            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6008         JZ      ??zclGetClusterOption_1
   2114            {
   2115              option = pOption->option;
   2116              if ( !ZG_SECURE_ENABLED )
   2117              {
   2118                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2119              }
   2120          
   2121              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   54BF         ANL     A,#0xbf
   \   000017   F9           MOV     R1,A
   \   000018   8002         SJMP    ??zclGetClusterOption_2
   2122            }
   2123          
   2124            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_1:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_2:
   \   00001C   80..         SJMP    ??Subroutine152_0
   2125          }
   2126          
   2127          /*********************************************************************
   2128           * @fn      zclSetSecurityOption
   2129           *
   2130           * @brief   Set the security option for the cluster id
   2131           *
   2132           * @param   endpoint - Application's endpoint
   2133           * @param   clusterID - cluster ID looking for
   2134           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2135           *
   2136           * @return  none
   2137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2138          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     ??zclSetSecurityOption:
   2139          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2140            zclOptionRec_t *pOption;
   2141          
   2142            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption(uint8, uint16)
   \   000007   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption(uint8, uint16)
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2143            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_1
   2144            {
   2145              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_2
   2146              {
   2147                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_3
   2148              }
   2149              else
   2150              {
   2151                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_2:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_3:
   \   00002A   F0           MOVX    @DPTR,A
   2152              }
   2153            }
   2154          }
   \                     ??zclSetSecurityOption_1:
   \   00002B   80..         SJMP    ??Subroutine152_0
   2155          
   2156          #ifdef ZCL_DISCOVER
   2157          /*********************************************************************
   2158           * @fn      zclFindNextCmdRec
   2159           *
   2160           * @brief   Find the command (or next) record that matchs the parameters
   2161           *
   2162           * @param   endpoint - Application's endpoint
   2163           * @param   clusterID - cluster ID
   2164           * @param   commandID - command ID from requesting command
   2165           * @param   direction- direction of received command
   2166           * @param   pCmdID - command looking for
   2167           * @param   pCmd - command information within command record list
   2168           *
   2169           * @return  pointer to command record, NULL no more records of this cluster
   2170           */
   2171          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2172                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2173          {
   2174            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2175            uint8 i;
   2176          
   2177            if ( pRec != NULL )
   2178            {
   2179              for ( i = 0; i < pRec->numCommands; i++ )
   2180              {
   2181                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2182                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2183                {
   2184                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2185                  {
   2186                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2187                    {
   2188                      *pCmd = pRec->pCmdRecs[i];
   2189          
   2190                      // Update command ID
   2191                      *pCmdID = pCmd->cmdID;
   2192          
   2193                      return ( TRUE ); // EMBEDDED RETURN
   2194                    }
   2195                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2196                    {
   2197                      *pCmd = pRec->pCmdRecs[i];
   2198          
   2199                      // Update command ID
   2200                      *pCmdID = pCmd->cmdID;
   2201          
   2202                      return ( TRUE ); // EMBEDDED RETURN
   2203                    }
   2204                  }
   2205                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2206                  {
   2207                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2208                    {
   2209                      *pCmd = pRec->pCmdRecs[i];
   2210          
   2211                      // Update command ID
   2212                      *pCmdID = pCmd->cmdID;
   2213          
   2214                      return ( TRUE ); // EMBEDDED RETURN
   2215                    }
   2216                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2217                    {
   2218                      *pCmd = pRec->pCmdRecs[i];
   2219          
   2220                      // Update command ID
   2221                      *pCmdID = pCmd->cmdID;
   2222          
   2223                      return ( TRUE ); // EMBEDDED RETURN
   2224                    }
   2225                  }
   2226                  else
   2227                  {
   2228                    return ( FALSE ); // Incorrect Command ID
   2229                  }
   2230                }
   2231              }
   2232            }
   2233          
   2234            return ( FALSE );
   2235          }
   2236          
   2237          /*********************************************************************
   2238           * @fn      zclFindNextAttrRec
   2239           *
   2240           * @brief   Find the attribute (or next) record that matchs the parameters
   2241           *
   2242           * @param   endpoint - Application's endpoint
   2243           * @param   clusterID - cluster ID
   2244           * @param   attr - attribute looking for
   2245           *
   2246           * @return  pointer to attribute record, NULL if not found
   2247           */
   2248          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2249                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2250          {
   2251            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2252            uint8 attrDir;
   2253          
   2254            if ( pRec != NULL )
   2255            {
   2256              uint16 x;
   2257          
   2258              for ( x = 0; x < pRec->numAttributes; x++ )
   2259              {
   2260                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2261                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2262                {
   2263                  // also make sure direction is right
   2264                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2265                  if ( attrDir == direction )
   2266                  {
   2267                    // return attribute and found attribute ID
   2268                    *pAttr = pRec->attrs[x];
   2269                    *attrId = pAttr->attr.attrId;
   2270          
   2271                    return ( TRUE ); // EMBEDDED RETURN
   2272                  }
   2273                }
   2274              }
   2275            }
   2276          
   2277            return ( FALSE );
   2278          }
   2279          #endif // ZCL_DISCOVER
   2280          
   2281          
   2282          #ifdef ZCL_REPORT
   2283          /*********************************************************************
   2284           * @fn      zclAnalogDataType
   2285           *
   2286           * @brief   Checks to see if Data Type is Analog
   2287           *
   2288           * @param   dataType - data type
   2289           *
   2290           * @return  TRUE if data type is analog
   2291           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2292          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2293          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2294            uint8 analog;
   2295          
   2296            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2297            {
   2298              case ZCL_DATATYPE_UINT8:
   2299              case ZCL_DATATYPE_UINT16:
   2300              case ZCL_DATATYPE_UINT24:
   2301              case ZCL_DATATYPE_UINT32:
   2302              case ZCL_DATATYPE_UINT40:
   2303              case ZCL_DATATYPE_UINT48:
   2304              case ZCL_DATATYPE_UINT56:
   2305              case ZCL_DATATYPE_UINT64:
   2306              case ZCL_DATATYPE_INT8:
   2307              case ZCL_DATATYPE_INT16:
   2308              case ZCL_DATATYPE_INT24:
   2309              case ZCL_DATATYPE_INT32:
   2310              case ZCL_DATATYPE_INT40:
   2311              case ZCL_DATATYPE_INT48:
   2312              case ZCL_DATATYPE_INT56:
   2313              case ZCL_DATATYPE_INT64:
   2314              case ZCL_DATATYPE_SEMI_PREC:
   2315              case ZCL_DATATYPE_SINGLE_PREC:
   2316              case ZCL_DATATYPE_DOUBLE_PREC:
   2317              case ZCL_DATATYPE_TOD:
   2318              case ZCL_DATATYPE_DATE:
   2319              case ZCL_DATATYPE_UTC:
   2320                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2321                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2322          
   2323              default:
   2324                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2325                break;
   2326            }
   2327          
   2328            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2329          }
   2330          
   2331          /*********************************************************************
   2332           * @fn      zclIsLittleEndianMachine
   2333           *
   2334           * @brief   Verifies endianness in system.
   2335           *
   2336           * @param   none
   2337           *
   2338           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2339           */
   2340          static int zclIsLittleEndianMachine(void)
   2341          {
   2342            uint16 test = 0x0001;
   2343          
   2344            return (*((uint8 *)(&test)));
   2345          }
   2346          
   2347          /*********************************************************************
   2348           * @fn      zcl_BuildAnalogData
   2349           *
   2350           * @brief   Build an analog arribute out of sequential bytes.
   2351           *
   2352           * @param   dataType - type of data
   2353           * @param   pData - pointer to data
   2354           * @param   pBuf - where to put the data
   2355           *
   2356           * @return  none
   2357           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2358          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     ??zcl_BuildAnalogData:
   2359          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   2360            int current_byte_index;
   2361            int remaining_bytes;
   2362            int step;
   2363          
   2364            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   2365          
   2366            // decide if move forward or backwards to copy data
   2367            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   F0           MOVX    @DPTR,A
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   E0           MOVX    A,@DPTR
   \   000028   600C         JZ      ??zcl_BuildAnalogData_1
   2368            {
   2369              step = 1;
   \   00002A   75..01       MOV     ?V4,#0x1
   \   00002D   75..00       MOV     ?V5,#0x0
   2370              current_byte_index = 0;
   \   000030   7800         MOV     R0,#0x0
   \   000032   7900         MOV     R1,#0x0
   \   000034   8038         SJMP    ??zcl_BuildAnalogData_2
   2371            }
   2372            else
   2373            {
   2374              step = -1;
   \                     ??zcl_BuildAnalogData_1:
   \   000036   75..FF       MOV     ?V4,#-0x1
   \   000039   75..FF       MOV     ?V5,#-0x1
   2375              current_byte_index = remaining_bytes - 1;
   \   00003C   EA           MOV     A,R2
   \   00003D   24FF         ADD     A,#-0x1
   \   00003F   F8           MOV     R0,A
   \   000040   EB           MOV     A,R3
   \   000041   34FF         ADDC    A,#-0x1
   \   000043   8028         SJMP    ??zcl_BuildAnalogData_3
   2376            }
   2377          
   2378            while ( remaining_bytes-- )
   2379            {
   2380              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_4:
   \   000045   85..82       MOV     DPL,?V0
   \   000048   85..83       MOV     DPH,?V1
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   C0E0         PUSH    A
   \   00004E   EE           MOV     A,R6
   \   00004F   28           ADD     A,R0
   \   000050   F582         MOV     DPL,A
   \   000052   EF           MOV     A,R7
   \   000053   39           ADDC    A,R1
   \   000054   F583         MOV     DPH,A
   \   000056   D0E0         POP     A
   \   000058   F0           MOVX    @DPTR,A
   \   000059   85..82       MOV     DPL,?V0
   \   00005C   85..83       MOV     DPH,?V1
   \   00005F   A3           INC     DPTR
   \   000060   8582..       MOV     ?V0,DPL
   \   000063   8583..       MOV     ?V1,DPH
   2381              current_byte_index += step;
   \   000066   E8           MOV     A,R0
   \   000067   25..         ADD     A,?V4
   \   000069   F8           MOV     R0,A
   \   00006A   E9           MOV     A,R1
   \   00006B   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_3:
   \   00006D   F9           MOV     R1,A
   2382            }
   \                     ??zcl_BuildAnalogData_2:
   \   00006E   EA           MOV     A,R2
   \   00006F   FC           MOV     R4,A
   \   000070   EB           MOV     A,R3
   \   000071   FD           MOV     R5,A
   \   000072   EC           MOV     A,R4
   \   000073   24FF         ADD     A,#-0x1
   \   000075   1A           DEC     R2
   \   000076   ED           MOV     A,R5
   \   000077   34FF         ADDC    A,#-0x1
   \   000079   FB           MOV     R3,A
   \   00007A   EC           MOV     A,R4
   \   00007B   4D           ORL     A,R5
   \   00007C   70C7         JNZ     ??zcl_BuildAnalogData_4
   2383          }
   \   00007E   7402         MOV     A,#0x2
   \   000080   02....       LJMP    ??Subroutine135_0 & 0xFFFF
   2384          #endif // ZCL_REPORT
   2385          
   2386          
   2387          
   2388          
   2389          #ifdef ZCL_READ
   2390          /*********************************************************************
   2391           * @fn      zclReadAttrData
   2392           *
   2393           * @brief   Read the attribute's current value into pAttrData.
   2394           *          NOTE - Not compatible with application's attributes callbacks.
   2395           *
   2396           * @param   pAttrData - where to put attribute data
   2397           * @param   pAttr - pointer to attribute
   2398           * @param   pDataLen - where to put attribute data length
   2399           *
   2400           * @return Success
   2401           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2402          ZStatus_t zclReadAttrData( uint8 *pAttrData, struct zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2403          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2404            uint16 dataLen;
   2405          
   2406            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   2407            {
   2408              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   803A         SJMP    ??zclReadAttrData_1
   2409            }
   2410          
   2411            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   2412            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   000035   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000038   AC..         MOV     R4,?V2
   \   00003A   AD..         MOV     R5,?V3
   \   00003C   EE           MOV     A,R6
   \   00003D   FA           MOV     R2,A
   \   00003E   EF           MOV     A,R7
   \   00003F   FB           MOV     R3,A
   \   000040   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000043   7403         MOV     A,#0x3
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   740F         MOV     A,#0xf
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ??Subroutine146_0 & 0xFFFF
   2413          
   2414            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_271:
   \   000050   6007         JZ      ??zclReadAttrData_2
   2415            {
   2416              *pDataLen = dataLen;
   \   000052   E5..         MOV     A,?V2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   E5..         MOV     A,?V3
   \   000058   F0           MOVX    @DPTR,A
   2417            }
   2418          
   2419            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   000059   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00005B                REQUIRE ?Subroutine7
   \   00005B                ; // Fall through to label ?Subroutine7
   2420          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   85....       MOV     ?V4,?V0
   \   00000E   F5..         MOV     ?V5,A
   \   000010   75..00       MOV     ?V6,#0x0
   \   000013   78..         MOV     R0,#?V4
   \   000015   22           RET
   2421          
   2422          /*********************************************************************
   2423           * @fn      zcl_ReadAttrData
   2424           *
   2425           * @brief   Read the attribute's current value into pAttrData.
   2426           *          Use application's callback function if assigned to this attribute.
   2427           *
   2428           * @param   endpoint - application's endpoint
   2429           * @param   clusterId - cluster that attribute belongs to
   2430           * @param   attrId - attribute id
   2431           * @param   pAttrData - where to put attribute data
   2432           * @param   pDataLen - where to put attribute data length
   2433           *
   2434           * @return  Successful if data was read
   2435           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2436          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId, uint8 *pAttrData, uint16 *pDataLen ){
   \                     zcl_ReadAttrData:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2437            struct zclAttrRec_t attrRec;
   2438          
   2439            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE ) {
   \   00000C                ; Setup parameters for call to function zclFindAttrRec
   \   00000C   A8..         MOV     R0,?XSP + 0
   \   00000E   A9..         MOV     R1,?XSP + 1
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   78..         MOV     R0,#?V0
   \   000016   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000019   EE           MOV     A,R6
   \   00001A   F9           MOV     R1,A
   \   00001B   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?DEALLOC_XSTACK8
   \   000023   E9           MOV     A,R1
   \   000024   6029         JZ      ??zcl_ReadAttrData_0
   2440              return ( ZCL_STATUS_FAILURE );
   2441            }
   2442          
   2443            if ( attrRec.attr.dataPtr != NULL ){
   \   000026   7406         MOV     A,#0x6
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   00002E   601F         JZ      ??zcl_ReadAttrData_0
   2444              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   000030                ; Setup parameters for call to function zclReadAttrData
   \   000030   7416         MOV     A,#0x16
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000038   7402         MOV     A,#0x2
   \   00003A   12....       LCALL   ?XSTACK_DISP102_8
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   2445            }
   \                     ??CrossCallReturnLabel_262:
   \   000045   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004D   8002         SJMP    ??zcl_ReadAttrData_1
   2446            
   2447            return ZCL_STATUS_FAILURE;
   \                     ??zcl_ReadAttrData_0:
   \   00004F   7901         MOV     R1,#0x1
   \                     ??zcl_ReadAttrData_1:
   \   000051   740A         MOV     A,#0xa
   \   000053   02....       LJMP    ?Subroutine2 & 0xFFFF
   2448            
   2449          }
   2450          
   2451          
   2452          /*********************************************************************
   2453           * @fn      zclAuthorizeRead
   2454           *
   2455           * @brief   Use application's callback to authorize a Read operation
   2456           *          on a given attribute.
   2457           *
   2458           * @param   endpoint - application's endpoint
   2459           * @param   srcAddr - source Address
   2460           * @param   pAttr - pointer to attribute
   2461           *
   2462           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2463           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2464           */
   2465          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, struct zclAttrRec_t *pAttr )
   2466          {
   2467            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   2468            {
   2469          	  // TODO: authorize
   2470            }
   2471          
   2472            return ( ZCL_STATUS_SUCCESS );
   2473          }
   2474          #endif // ZCL_READ
   2475          
   2476          #ifdef ZCL_WRITE
   2477          /*********************************************************************
   2478           * @fn      zclWriteAttrData
   2479           *
   2480           * @brief   Write the received data.
   2481           *
   2482           * @param   endpoint - application's endpoint
   2483           * @param   pAttr - where to write data to
   2484           * @param   pWriteRec - data to be written
   2485           *
   2486           * @return  Successful if data was written
   2487           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2488          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr, struct zclAttrRec_t *pAttr, ZclWriteRec *pWriteRec )
   \                     ??zclWriteAttrData:
   2489          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   2490            uint8 status;
   2491          
   2492            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) ) {
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   5073         JNC     ??zclWriteAttrData_1
   2493              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017   75..00       MOV     ?V2,#0x0
   \   00001A   740F         MOV     A,#0xf
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V1,A
   2494              if ( status == ZCL_STATUS_SUCCESS ) {
   2495                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) ) {
   \   000026   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000029   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   00002C   6011         JZ      ??zclWriteAttrData_2
   \   00002E                ; Setup parameters for indirect call
   \   00002E   AC..         MOV     R4,?V0
   \   000030   AD..         MOV     R5,?V1
   \   000032   EE           MOV     A,R6
   \   000033   FA           MOV     R2,A
   \   000034   EF           MOV     A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   000039   12....       LCALL   ?CALL_IND
   \   00003C   E9           MOV     A,R1
   \   00003D   6046         JZ      ??zclWriteAttrData_3
   2496                  // Write the attribute value
   2497                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   00003F   E5..         MOV     A,?V0
   \   000041   2403         ADD     A,#0x3
   \   000043   F8           MOV     R0,A
   \   000044   E4           CLR     A
   \   000045   35..         ADDC    A,?V1
   \   000047   F9           MOV     R1,A
   \   000048   88..         MOV     ?V0,R0
   \   00004A   89..         MOV     ?V1,R1
   \   00004C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00004C   8882         MOV     DPL,R0
   \   00004E   F583         MOV     DPH,A
   \   000050   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   A3           INC     DPTR
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F9           MOV     R1,A
   \   00005D   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000060   8A..         MOV     ?V4,R2
   \   000062   8B..         MOV     ?V5,R3
   \   000064   AC..         MOV     R4,?V4
   \   000066   AD..         MOV     R5,?V5
   2498                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   000068                ; Setup parameters for call to function osal_memcpy
   \   000068   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   A3           INC     DPTR
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   00007B   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00007E   7403         MOV     A,#0x3
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   2499                  status = ZCL_STATUS_SUCCESS;
   \   000083   8008         SJMP    ??zclWriteAttrData_4
   2500                } else{
   2501                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   000085   75..87       MOV     ?V2,#-0x79
   \   000088   8003         SJMP    ??zclWriteAttrData_4
   2502                }
   2503              }
   2504            } else {
   2505              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_1:
   \   00008A   75..88       MOV     ?V2,#-0x78
   2506            }
   2507          
   2508            return ( status );
   \                     ??zclWriteAttrData_4:
   \   00008D   A9..         MOV     R1,?V2
   \   00008F   02....       LJMP    ?Subroutine7 & 0xFFFF
   2509          }
   2510          
   2511          
   2512          /*********************************************************************
   2513           * @fn      zclAuthorizeWrite
   2514           *
   2515           * @brief   Use application's callback to authorize a Write operation
   2516           *          on a given attribute.
   2517           *
   2518           * @param   endpoint - application's endpoint
   2519           * @param   srcAddr - source Address
   2520           * @param   pAttr - pointer to attribute
   2521           *
   2522           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2523           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2524           */
   2525          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, struct zclAttrRec_t *pAttr )
   2526          {
   2527            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   2528            {
   2529          // TODO: authorize
   2530            }
   2531          
   2532            return ( ZCL_STATUS_SUCCESS );
   2533          }
   2534          #endif // ZCL_WRITE
   2535          
   2536          #ifdef ZCL_READ
   2537          /*********************************************************************
   2538           * @fn      zclParseInReadCmd
   2539           *
   2540           * @brief   Parse the "Profile" Read Commands
   2541           *
   2542           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2543           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2544           *
   2545           * @param   pCmd - pointer to incoming data to parse
   2546           *
   2547           * @return  pointer to the parsed command structure
   2548           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2549          void *zclParseInReadCmd( zclParseCmd_t *pCmd ){
   \                     zclParseInReadCmd:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2550            return  (void *)new zclReadCmd_t(pCmd);
   \   000004                ; Setup parameters for call to function zclReadCmd_t::new zclReadCmd_t(zclParseCmd_t *)
   \   000004   12....       LCALL   `??new zclReadCmd_t?relay`; Banked call to: zclReadCmd_t::new zclReadCmd_t(zclParseCmd_t *)
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
   2551          }
   2552          
   2553          /*********************************************************************
   2554           * @fn      zclParseInReadRspCmd
   2555           *
   2556           * @brief   Parse the "Profile" Read Response Commands
   2557           *
   2558           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2559           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2560           *
   2561           * @param   pCmd - pointer to incoming data to parse
   2562           *
   2563           * @return  pointer to the parsed command structure
   2564           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2565          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     ??zclParseInReadRspCmd:
   2566          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   2567            zclReadRspCmd_t *readRspCmd;
   2568            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine66 & 0xFFFF
   2569            uint8 *dataPtr;
   2570            uint8 numAttr = 0;
   2571            uint8 hdrLen;
   2572            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_98:
   \   000019   803A         SJMP    ??zclParseInReadRspCmd_1
   2573            uint16 attrDataLen;
   2574          
   2575            // find out the number of attributes and the length of attribute data
   2576            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2577            {
   2578              uint8 status;
   2579          
   2580              numAttr++;
   \                     ??zclParseInReadRspCmd_2:
   \   00001B   05..         INC     ?V2
   2581              pBuf += 2; // move pass attribute id
   \   00001D   EE           MOV     A,R6
   \   00001E   2402         ADD     A,#0x2
   \   000020   FE           MOV     R6,A
   \   000021   5001         JNC     ??zclParseInReadRspCmd_3
   \   000023   0F           INC     R7
   2582          
   2583              status = *pBuf++;
   \                     ??zclParseInReadRspCmd_3:
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   E0           MOVX    A,@DPTR
   \   000029   A3           INC     DPTR
   \   00002A   AE82         MOV     R6,DPL
   \   00002C   AF83         MOV     R7,DPH
   2584              if ( status == ZCL_STATUS_SUCCESS )
   \   00002E   7025         JNZ     ??zclParseInReadRspCmd_1
   2585              {
   2586                uint8 dataType = *pBuf++;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   A3           INC     DPTR
   \   000033   0E           INC     R6
   \   000034   AF83         MOV     R7,DPH
   2587          
   2588                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000036                ; Setup parameters for call to function zclGetAttrDataLength
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00003D   12....       LCALL   ?Subroutine101 & 0xFFFF
   2589                pBuf += attrDataLen; // move pass attribute data
   2590          
   2591                // add padding if needed
   2592                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_173:
   \   000040   5007         JNC     ??zclParseInReadRspCmd_4
   2593                {
   2594                  attrDataLen++;
   \   000042   05..         INC     ?V0
   \   000044   04           INC     A
   \   000045   7002         JNZ     ??zclParseInReadRspCmd_4
   \   000047   05..         INC     ?V1
   2595                }
   2596          
   2597                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_4:
   \   000049   E5..         MOV     A,?V6
   \   00004B   25..         ADD     A,?V0
   \   00004D   F5..         MOV     ?V6,A
   \   00004F   E5..         MOV     A,?V7
   \   000051   35..         ADDC    A,?V1
   \   000053   F5..         MOV     ?V7,A
   2598              }
   2599            }
   \                     ??zclParseInReadRspCmd_1:
   \   000055   85..82       MOV     DPL,?V8
   \   000058   85..83       MOV     DPH,?V9
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00005F   12....       LCALL   ??Subroutine156_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000062   40B7         JC      ??zclParseInReadRspCmd_2
   2600          
   2601            // calculate the length of the response header
   2602            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000064   75F006       MOV     B,#0x6
   \   000067   E5..         MOV     A,?V2
   \   000069   A4           MUL     AB
   \   00006A   2407         ADD     A,#0x7
   \   00006C   12....       LCALL   ?Subroutine103 & 0xFFFF
   2603          
   2604            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_177:
   \   00006F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000072   8A..         MOV     ?V10,R2
   \   000074   8B..         MOV     ?V11,R3
   2605            if ( readRspCmd != NULL )
   \   000076   EA           MOV     A,R2
   \   000077   45..         ORL     A,?V11
   \   000079   7003         JNZ     $+5
   \   00007B   02....       LJMP    ??zclParseInReadRspCmd_5 & 0xFFFF
   2606            {
   2607              uint8 i;
   2608              pBuf = pCmd->pData;
   \   00007E   85..82       MOV     DPL,?V4
   \   000081   85..83       MOV     DPH,?V5
   \   000084   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   2609              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_329:
   \   000087   F5..         MOV     ?V8,A
   \   000089   E4           CLR     A
   \   00008A   3B           ADDC    A,R3
   \   00008B   F5..         MOV     ?V9,A
   2610          
   2611              readRspCmd->numAttr = numAttr;
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   8B83         MOV     DPH,R3
   \   000091   E5..         MOV     A,?V2
   \   000093   F0           MOVX    @DPTR,A
   2612              for ( i = 0; i < numAttr; i++ )
   \   000094   75..00       MOV     ?V3,#0x0
   \   000097   8074         SJMP    ??zclParseInReadRspCmd_6
   2613              {
   2614                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_7:
   \   000099   E5..         MOV     A,?V3
   \   00009B   75F006       MOV     B,#0x6
   \   00009E   12....       LCALL   ?Subroutine12 & 0xFFFF
   2615          
   2616                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2617                pBuf += 2;
   \                     ??CrossCallReturnLabel_334:
   \   0000A1   5001         JNC     ??zclParseInReadRspCmd_8
   \   0000A3   0F           INC     R7
   2618          
   2619                statusRec->status = *pBuf++;
   \                     ??zclParseInReadRspCmd_8:
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   12....       LCALL   ?Subroutine19 & 0xFFFF
   2620                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_323:
   \   0000AC   705D         JNZ     ??zclParseInReadRspCmd_9
   2621                {
   2622                  statusRec->dataType = *pBuf++;
   \   0000AE   E0           MOVX    A,@DPTR
   \   0000AF   F9           MOV     R1,A
   \   0000B0   85..82       MOV     DPL,?V12
   \   0000B3   85..83       MOV     DPH,?V13
   \   0000B6   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   0000B9   0E           INC     R6
   \   0000BA   AF83         MOV     R7,DPH
   2623          
   2624                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0000BC                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000BC   EE           MOV     A,R6
   \   0000BD   FA           MOV     R2,A
   \   0000BE   EF           MOV     A,R7
   \   0000BF   FB           MOV     R3,A
   \   0000C0   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000C3   8A..         MOV     ?V0,R2
   \   0000C5   8B..         MOV     ?V1,R3
   2625                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000C7                ; Setup parameters for call to function osal_memcpy
   \   0000C7   8E..         MOV     ?V4,R6
   \   0000C9   8F..         MOV     ?V5,R7
   \   0000CB   75..00       MOV     ?V6,#0x0
   \   0000CE   78..         MOV     R0,#?V4
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D3   AC..         MOV     R4,?V0
   \   0000D5   AD..         MOV     R5,?V1
   \   0000D7   AA..         MOV     R2,?V8
   \   0000D9   AB..         MOV     R3,?V9
   \   0000DB   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000DE   7403         MOV     A,#0x3
   \   0000E0   12....       LCALL   ?DEALLOC_XSTACK8
   2626                  statusRec->data = dataPtr;
   \   0000E3   85..82       MOV     DPL,?V12
   \   0000E6   85..83       MOV     DPH,?V13
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   E5..         MOV     A,?V8
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   E5..         MOV     A,?V9
   \   0000F3   12....       LCALL   ?Subroutine24 & 0xFFFF
   2627          
   2628                  pBuf += attrDataLen; // move pass attribute data
   2629          
   2630                  // advance attribute data pointer
   2631                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_18:
   \   0000F6   5007         JNC     ??zclParseInReadRspCmd_10
   2632                  {
   2633                    attrDataLen++;
   \   0000F8   05..         INC     ?V0
   \   0000FA   04           INC     A
   \   0000FB   7002         JNZ     ??zclParseInReadRspCmd_10
   \   0000FD   05..         INC     ?V1
   2634                  }
   2635          
   2636                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_10:
   \   0000FF   E5..         MOV     A,?V8
   \   000101   25..         ADD     A,?V0
   \   000103   F5..         MOV     ?V8,A
   \   000105   E5..         MOV     A,?V9
   \   000107   35..         ADDC    A,?V1
   \   000109   F5..         MOV     ?V9,A
   2637                }
   2638              }
   \                     ??zclParseInReadRspCmd_9:
   \   00010B   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_6:
   \   00010D   E5..         MOV     A,?V3
   \   00010F   C3           CLR     C
   \   000110   95..         SUBB    A,?V2
   \   000112   4085         JC      ??zclParseInReadRspCmd_7
   2639            }
   2640          
   2641            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_5:
   \   000114   02....       LJMP    ?Subroutine8 & 0xFFFF
   2642          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008                REQUIRE ??Subroutine154_0
   \   000008                ; // Fall through to label ??Subroutine154_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   F5..         MOV     ?V8,A
   \   000002                ; Setup parameters for call to function osal_mem_alloc
   \   000002                ; Setup parameters for call to function osal_mem_alloc
   \   000002                ; Setup parameters for call to function osal_mem_alloc
   \   000002   25..         ADD     A,?V6
   \   000004   FA           MOV     R2,A
   \   000005   E4           CLR     A
   \   000006   35..         ADDC    A,?V7
   \   000008   FB           MOV     R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine155_0:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   000003   EA           MOV     A,R2
   \   000004   25..         ADD     A,?V8
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   F583         MOV     DPH,A
   \   000002   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   000005   75..00       MOV     ?V2,#0x0
   \   000008   75..00       MOV     ?V6,#0x0
   \   00000B   75..00       MOV     ?V7,#0x0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine156_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   EE           MOV     A,R6
   \   000009   98           SUBB    A,R0
   \   00000A   EF           MOV     A,R7
   \   00000B   99           SUBB    A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   8582..       MOV     ?V12,DPL
   \   000012   8583..       MOV     ?V13,DPH
   \   000015   8E82         MOV     DPL,R6
   \   000017   8F83         MOV     DPH,R7
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FA           MOV     R2,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F9           MOV     R1,A
   \   00001E   EA           MOV     A,R2
   \   00001F   85..82       MOV     DPL,?V12
   \   000022   85..83       MOV     DPH,?V13
   \   000025                REQUIRE ??Subroutine157_0
   \   000025                ; // Fall through to label ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   8A..         MOV     ?V0,R2
   \   000002   8B..         MOV     ?V1,R3
   \   000004   EE           MOV     A,R6
   \   000005   2A           ADD     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EF           MOV     A,R7
   \   000008   35..         ADDC    A,?V1
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   25..         ADD     A,?V0
   \   000004   FE           MOV     R6,A
   \   000005   EF           MOV     A,R7
   \   000006   35..         ADDC    A,?V1
   \   000008   FF           MOV     R7,A
   \   000009   E5..         MOV     A,?V0
   \   00000B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_379:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   85..83       MOV     DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004                REQUIRE ??Subroutine160_0
   \   000004                ; // Fall through to label ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine160_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   2643          #endif // ZCL_READ
   2644          
   2645          
   2646          /*********************************************************************
   2647           * @fn      zclParseInWriteCmd
   2648           *
   2649           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2650           *          Response Commands
   2651           *
   2652           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2653           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2654           *
   2655           * @param   pCmd - pointer to incoming data to parse
   2656           *
   2657           * @return  pointer to the parsed command structure
   2658           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2659          void *zclParseInWriteCmd( zclParseCmd_t *pCmd ){
   \                     zclParseInWriteCmd:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2660          	return new ZclWriteCmd(pCmd);
   \   000004                ; Setup parameters for call to function ZclWriteCmd::new ZclWriteCmd(zclParseCmd_t *)
   \   000004   12....       LCALL   `??new ZclWriteCmd?relay`; Banked call to: ZclWriteCmd::new ZclWriteCmd(zclParseCmd_t *)
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
   2661          }
   2662          
   2663          /*********************************************************************
   2664           * @fn      zclParseInWriteRspCmd
   2665           *
   2666           * @brief   Parse the "Profile" Write Response Commands
   2667           *
   2668           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2669           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2670           *
   2671           * @param   pCmd - pointer to incoming data to parse
   2672           *
   2673           * @return  pointer to the parsed command structure
   2674           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2675          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd ){
   \                     ??zclParseInWriteRspCmd:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2676          	return new ZclWriteRspCmd(pCmd);
   \   000004                ; Setup parameters for call to function ZclWriteRspCmd::new ZclWriteRspCmd(zclParseCmd_t *)
   \   000004   12....       LCALL   `??new ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::new ZclWriteRspCmd(zclParseCmd_t *)
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
   2677          }
   2678          
   2679          #ifdef ZCL_REPORT
   2680          /*********************************************************************
   2681           * @fn      zclParseInConfigReportCmd
   2682           *
   2683           * @brief   Parse the "Profile" Configure Reporting Command
   2684           *
   2685           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2686           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2687           *
   2688           * @param   pCmd - pointer to incoming data to parse
   2689           *
   2690           * @return  pointer to the parsed command structure
   2691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine138_0
   \   000004                ; // Fall through to label ??Subroutine138_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2692          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   2693          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   2694            zclCfgReportCmd_t *cfgReportCmd;
   2695            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine66 & 0xFFFF
   2696            uint8 *dataPtr;
   2697            uint8 numAttr = 0;
   2698            uint8 dataType;
   2699            uint8 hdrLen;
   2700            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_99:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   2701            uint8 reportChangeLen; // length of Reportable Change field
   2702          
   2703            // Calculate the length of the Request command
   2704            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2705            {
   2706              uint8 direction;
   2707          
   2708              numAttr++;
   2709              direction = *pBuf++;
   2710              pBuf += 2; // move pass the attribute ID
   2711          
   2712              // Is there a Reportable Change field?
   2713              if ( direction == ZCL_SEND_ATTR_REPORTS )
   2714              {
   2715                dataType = *pBuf++;
   2716                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2717          
   2718                // For attributes of 'discrete' data types this field is omitted
   2719                if ( zclAnalogDataType( dataType ) )
   2720                {
   2721                  reportChangeLen = zclGetDataTypeLength( dataType );
   2722                  pBuf += reportChangeLen;
   2723          
   2724                  // add padding if needed
   2725                  if ( PADDING_NEEDED( reportChangeLen ) )
   2726                  {
   2727                    reportChangeLen++;
   2728                  }
   2729          
   2730                  dataLen += reportChangeLen;
   2731                }
   2732                else
   2733                {
   2734                  pBuf++; // move past reportable change field
   2735                }
   2736              }
   2737              else
   2738              {
   2739                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2402         ADD     A,#0x2
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   2740              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   00002B   504B         JNC     ??zclParseInConfigReportCmd_2
   \   00002D   05..         INC     ?V2
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   AF83         MOV     R7,DPH
   \   000038   E582         MOV     A,DPL
   \   00003A   2402         ADD     A,#0x2
   \   00003C   FE           MOV     R6,A
   \   00003D   5001         JNC     ??zclParseInConfigReportCmd_3
   \   00003F   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000040   E8           MOV     A,R0
   \   000041   70D8         JNZ     ??zclParseInConfigReportCmd_1
   \   000043   8E82         MOV     DPL,R6
   \   000045   8F83         MOV     DPH,R7
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F5..         MOV     ?V3,A
   \   00004A   A3           INC     DPTR
   \   00004B   AF83         MOV     R7,DPH
   \   00004D   E582         MOV     A,DPL
   \   00004F   2404         ADD     A,#0x4
   \   000051   FE           MOV     R6,A
   \   000052   5001         JNC     ??zclParseInConfigReportCmd_4
   \   000054   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_4:
   \   000055                ; Setup parameters for call to function zclAnalogDataType
   \   000055   A9..         MOV     R1,?V3
   \   000057   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005A   E9           MOV     A,R1
   \   00005B   6011         JZ      ??zclParseInConfigReportCmd_5
   \   00005D                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005D   A9..         MOV     R1,?V3
   \   00005F   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000062   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000065   5002         JNC     ??zclParseInConfigReportCmd_6
   \   000067   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_6:
   \   000069   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   00006C   80B4         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_5:
   \   00006E   8E82         MOV     DPL,R6
   \   000070   8F83         MOV     DPH,R7
   \   000072   A3           INC     DPTR
   \   000073   0E           INC     R6
   \   000074   AF83         MOV     R7,DPH
   \   000076   80AA         SJMP    ??zclParseInConfigReportCmd_0
   2741            } // while loop
   2742          
   2743            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   000078   75F00C       MOV     B,#0xc
   \   00007B   E5..         MOV     A,?V2
   \   00007D   A4           MUL     AB
   \   00007E   240D         ADD     A,#0xd
   \   000080   12....       LCALL   ?Subroutine103 & 0xFFFF
   2744          
   2745            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_178:
   \   000083   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000086   8A..         MOV     ?V6,R2
   \   000088   8B..         MOV     ?V7,R3
   2746            if ( cfgReportCmd != NULL )
   \   00008A   EA           MOV     A,R2
   \   00008B   45..         ORL     A,?V7
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   2747            {
   2748              uint8 i;
   2749              pBuf = pCmd->pData;
   \   000092   12....       LCALL   ?Subroutine71 & 0xFFFF
   2750              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_327:
   \   000095   F5..         MOV     ?V4,A
   \   000097   E4           CLR     A
   \   000098   3B           ADDC    A,R3
   \   000099   F5..         MOV     ?V5,A
   2751          
   2752              cfgReportCmd->numAttr = numAttr;
   \   00009B   8A82         MOV     DPL,R2
   \   00009D   8B83         MOV     DPH,R3
   \   00009F   E5..         MOV     A,?V2
   \   0000A1   F0           MOVX    @DPTR,A
   2753              for ( i = 0; i < numAttr; i++ )
   \   0000A2   75..00       MOV     ?V3,#0x0
   \   0000A5   800B         SJMP    ??zclParseInConfigReportCmd_8
   2754              {
   2755                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   2756          
   2757                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2758          
   2759                reportRec->direction = *pBuf++;
   2760                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2761                pBuf += 2;
   2762                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2763                {
   2764                  // Attribute to be reported
   2765                  reportRec->dataType = *pBuf++;
   2766                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2767                  pBuf += 2;
   2768                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2769                  pBuf += 2;
   2770          
   2771                  // For attributes of 'discrete' data types this field is omitted
   2772                  if ( zclAnalogDataType( reportRec->dataType ) )
   2773                  {
   2774                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2775                    reportRec->reportableChange = dataPtr;
   2776          
   2777                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2778                    pBuf += reportChangeLen;
   2779          
   2780                    // advance attribute data pointer
   2781                    if ( PADDING_NEEDED( reportChangeLen ) )
   2782                    {
   2783                      reportChangeLen++;
   2784                    }
   2785          
   2786                    dataPtr += reportChangeLen;
   2787                  }
   2788                }
   2789                else
   2790                {
   2791                  // Attribute reports to be received
   2792                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_9:
   \   0000A7   12....       LCALL   ?Subroutine57 & 0xFFFF
   2793                  pBuf += 2;
   2794                }
   \                     ??CrossCallReturnLabel_76:
   \   0000AA   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   0000AD   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000AF   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000B0   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B2   E5..         MOV     A,?V3
   \   0000B4   C3           CLR     C
   \   0000B5   95..         SUBB    A,?V2
   \   0000B7   4003         JC      $+5
   \   0000B9   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   \   0000BC   E5..         MOV     A,?V3
   \   0000BE   75F00C       MOV     B,#0xc
   \   0000C1   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   0000C4                ; Setup parameters for call to function osal_memset
   \   0000C4   7C0C         MOV     R4,#0xc
   \   0000C6   7D00         MOV     R5,#0x0
   \   0000C8   7900         MOV     R1,#0x0
   \   0000CA   AA..         MOV     R2,?V0
   \   0000CC   AB..         MOV     R3,?V1
   \   0000CE   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0000D1   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0000D4   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   0000D7   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   0000DA   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0000DD   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000DF   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000E0   8E82         MOV     DPL,R6
   \   0000E2   8F83         MOV     DPH,R7
   \   0000E4   A3           INC     DPTR
   \   0000E5   A882         MOV     R0,DPL
   \   0000E7   A983         MOV     R1,DPH
   \   0000E9   8E82         MOV     DPL,R6
   \   0000EB   8F83         MOV     DPH,R7
   \   0000ED   E0           MOVX    A,@DPTR
   \   0000EE   F5..         MOV     ?V10,A
   \   0000F0   EC           MOV     A,R4
   \   0000F1   70B4         JNZ     ??zclParseInConfigReportCmd_9
   \   0000F3   E5..         MOV     A,?V0
   \   0000F5   2403         ADD     A,#0x3
   \   0000F7   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000FA   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   0000FD   5001         JNC     ??zclParseInConfigReportCmd_12
   \   0000FF   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_12:
   \   000100   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000103   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   000106   5001         JNC     ??zclParseInConfigReportCmd_13
   \   000108   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_13:
   \   000109                ; Setup parameters for call to function zclAnalogDataType
   \   000109   A9..         MOV     R1,?V10
   \   00010B   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00010E   E9           MOV     A,R1
   \   00010F   609F         JZ      ??zclParseInConfigReportCmd_10
   \   000111                ; Setup parameters for call to function zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
   \   000111   EE           MOV     A,R6
   \   000112   FC           MOV     R4,A
   \   000113   EF           MOV     A,R7
   \   000114   FD           MOV     R5,A
   \   000115   AA..         MOV     R2,?V4
   \   000117   AB..         MOV     R3,?V5
   \   000119   85..82       MOV     DPL,?V8
   \   00011C   85..83       MOV     DPH,?V9
   \   00011F   E0           MOVX    A,@DPTR
   \   000120   F9           MOV     R1,A
   \   000121   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
   \   000124   85..82       MOV     DPL,?V0
   \   000127   85..83       MOV     DPH,?V1
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   A3           INC     DPTR
   \   000133   A3           INC     DPTR
   \   000134   E5..         MOV     A,?V4
   \   000136   F0           MOVX    @DPTR,A
   \   000137   A3           INC     DPTR
   \   000138   E5..         MOV     A,?V5
   \   00013A   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   00013D   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000140   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000143   5002         JNC     ??zclParseInConfigReportCmd_14
   \   000145   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_14:
   \   000147   E5..         MOV     A,?V4
   \   000149   25..         ADD     A,?V10
   \   00014B   F5..         MOV     ?V4,A
   \   00014D   E4           CLR     A
   \   00014E   35..         ADDC    A,?V5
   \   000150   F5..         MOV     ?V5,A
   \   000152   02....       LJMP    ??zclParseInConfigReportCmd_10 & 0xFFFF
   2795              } // while loop
   2796            }
   2797          
   2798            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_7:
   \   000155   02....       LJMP    ?Subroutine5 & 0xFFFF
   2799          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine155_0
   \   000006                ; // Fall through to label ??Subroutine155_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009                REQUIRE ??Subroutine156_0
   \   000009                ; // Fall through to label ??Subroutine156_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   E5..         MOV     A,?V6
   \   000002   25..         ADD     A,?V10
   \   000004   F5..         MOV     ?V6,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V7
   \   000009   F5..         MOV     ?V7,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V10,A
   \   000003   EE           MOV     A,R6
   \   000004   29           ADD     A,R1
   \   000005   FE           MOV     R6,A
   \   000006   E4           CLR     A
   \   000007   3F           ADDC    A,R7
   \   000008   FF           MOV     R7,A
   \   000009   E9           MOV     A,R1
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   39           ADDC    A,R1
   \   00000C   F583         MOV     DPH,A
   \   00000E   A3           INC     DPTR
   \   00000F   8582..       MOV     ?V0,DPL
   \   000012   8583..       MOV     ?V1,DPH
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FC           MOV     R4,A
   \   000006   85..82       MOV     DPL,?V0
   \   000009   85..83       MOV     DPH,?V1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   E5..         MOV     A,?V10
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   85..82       MOV     DPL,?V8
   \   00000A   F583         MOV     DPH,A
   \   00000C   E5..         MOV     A,?V10
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   0E           INC     R6
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   2800          
   2801          /*********************************************************************
   2802           * @fn      zclParseInConfigReportRspCmd
   2803           *
   2804           * @brief   Parse the "Profile" Configure Reporting Response Command
   2805           *
   2806           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2807           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2808           *
   2809           * @param   pCmd - pointer to incoming data to parse
   2810           *
   2811           * @return  pointer to the parsed command structure
   2812           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000008                REQUIRE ??Subroutine149_0
   \   000008                ; // Fall through to label ??Subroutine149_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2813          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     ??zclParseInConfigReportRspCmd:
   2814          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   2815            zclCfgReportRspCmd_t *cfgReportRspCmd;
   2816            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine85 & 0xFFFF
   2817            uint8 numAttr;
   2818          
   2819            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_139:
   \   000008   A3           INC     DPTR
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F5..         MOV     ?V0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F5..         MOV     ?V1,A
   \   000010   7402         MOV     A,#0x2
   \   000012   78..         MOV     R0,#?V0
   \   000014   12....       LCALL   ?US_SHR
   \   000017   E5..         MOV     A,?V0
   \   000019   F5..         MOV     ?V2,A
   2820          
   2821            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   2822                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   00001B                ; Setup parameters for call to function osal_mem_alloc
   \   00001B   75..00       MOV     ?V1,#0x0
   \   00001E   7402         MOV     A,#0x2
   \   000020   78..         MOV     R0,#?V0
   \   000022   12....       LCALL   ?S_SHL
   \   000025   E5..         MOV     A,?V0
   \   000027   2405         ADD     A,#0x5
   \   000029   FA           MOV     R2,A
   \   00002A   E4           CLR     A
   \   00002B   35..         ADDC    A,?V1
   \   00002D   FB           MOV     R3,A
   \   00002E   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   2823            if ( cfgReportRspCmd != NULL )
   \   000031   EA           MOV     A,R2
   \   000032   4B           ORL     A,R3
   \   000033   6040         JZ      ??zclParseInConfigReportRspCmd_1
   2824            {
   2825              uint8 i;
   2826              cfgReportRspCmd->numAttr = numAttr;
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   E5..         MOV     A,?V2
   \   00003B   F0           MOVX    @DPTR,A
   2827              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003C   75..00       MOV     ?V2,#0x0
   \   00003F   802B         SJMP    ??zclParseInConfigReportRspCmd_2
   2828              {
   2829                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_3:
   \   000041   85....       MOV     ?V0,?V2
   \   000044   75..00       MOV     ?V1,#0x0
   \   000047   7402         MOV     A,#0x2
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?S_SHL
   \   00004E   EA           MOV     A,R2
   \   00004F   25..         ADD     A,?V0
   \   000051   F8           MOV     R0,A
   \   000052   EB           MOV     A,R3
   \   000053   35..         ADDC    A,?V1
   \   000055   12....       LCALL   ?Subroutine14 & 0xFFFF
   2830                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   2831                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2832                pBuf += 2;
   2833              }
   \                     ??CrossCallReturnLabel_296:
   \   000058   8882         MOV     DPL,R0
   \   00005A   8983         MOV     DPH,R1
   \   00005C   A3           INC     DPTR
   \   00005D   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000060   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000063   A3           INC     DPTR
   \   000064   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000067   5001         JNC     ??zclParseInConfigReportRspCmd_4
   \   000069   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_4:
   \   00006A   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_2:
   \   00006C   8A82         MOV     DPL,R2
   \   00006E   8B83         MOV     DPH,R3
   \   000070   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   2834            }
   \                     ??CrossCallReturnLabel_352:
   \   000073   40CC         JC      ??zclParseInConfigReportRspCmd_3
   2835          
   2836            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_1:
   \   000075   7F03         MOV     R7,#0x3
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   2837          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   ED           MOV     A,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   EE           MOV     A,R6
   \   000007   2402         ADD     A,#0x2
   \   000009   FE           MOV     R6,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000004   A3           INC     DPTR
   \   000005   0E           INC     R6
   \   000006   AF83         MOV     R7,DPH
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET
   2838          
   2839          /*********************************************************************
   2840           * @fn      zclParseInReadReportCfgCmd
   2841           *
   2842           * @brief   Parse the "Profile" Read Reporting Configuration Command
   2843           *
   2844           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2845           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2846           *
   2847           * @param   pCmd - pointer to incoming data to parse
   2848           *
   2849           * @return  pointer to the parsed command structure
   2850           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2851          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   2852          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   2853            zclReadReportCfgCmd_t *readReportCfgCmd;
   2854            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine85 & 0xFFFF
   2855            uint8 numAttr;
   2856          
   2857            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_140:
   \   000008   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   00000B   7A03         MOV     R2,#0x3
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ?US_DIV_MOD
   \   000012   E8           MOV     A,R0
   \   000013   F5..         MOV     ?V0,A
   2858          
   2859            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   2860                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   75F003       MOV     B,#0x3
   \   000018   A4           MUL     AB
   \   000019   A9F0         MOV     R1,B
   \   00001B   2404         ADD     A,#0x4
   \   00001D   FA           MOV     R2,A
   \   00001E   E4           CLR     A
   \   00001F   39           ADDC    A,R1
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   2861            if ( readReportCfgCmd != NULL )
   \   000024   EA           MOV     A,R2
   \   000025   4B           ORL     A,R3
   \   000026   6031         JZ      ??zclParseInReadReportCfgCmd_0
   2862            {
   2863              uint8 i;
   2864              readReportCfgCmd->numAttr = numAttr;
   \   000028   8A82         MOV     DPL,R2
   \   00002A   8B83         MOV     DPH,R3
   \   00002C   E5..         MOV     A,?V0
   \   00002E   F0           MOVX    @DPTR,A
   2865              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   00002F   75..00       MOV     ?V2,#0x0
   \   000032   801C         SJMP    ??zclParseInReadReportCfgCmd_1
   2866              {
   2867                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   000034   E5..         MOV     A,?V2
   \   000036   75F003       MOV     B,#0x3
   \   000039   A4           MUL     AB
   \   00003A   F8           MOV     R0,A
   \   00003B   A9F0         MOV     R1,B
   \   00003D   EA           MOV     A,R2
   \   00003E   28           ADD     A,R0
   \   00003F   F8           MOV     R0,A
   \   000040   EB           MOV     A,R3
   \   000041   39           ADDC    A,R1
   \   000042   12....       LCALL   ?Subroutine14 & 0xFFFF
   2868                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2869                pBuf += 2;
   2870              }
   \                     ??CrossCallReturnLabel_297:
   \   000045   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   000048   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00004B   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   00004D   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00004E   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   000050   8A82         MOV     DPL,R2
   \   000052   8B83         MOV     DPH,R3
   \   000054   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   2871            }
   \                     ??CrossCallReturnLabel_353:
   \   000057   40DB         JC      ??zclParseInReadReportCfgCmd_2
   2872          
   2873            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000059   02....       LJMP    ?Subroutine1 & 0xFFFF
   2874          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine162_0
   \   000001                ; // Fall through to label ??Subroutine162_0
   2875          
   2876          /*********************************************************************
   2877           * @fn      zclParseInReadReportCfgRspCmd
   2878           *
   2879           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   2880           *
   2881           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2882           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2883           *
   2884           * @param   pCmd - pointer to incoming data to parse
   2885           *
   2886           * @return  pointer to the parsed command structure
   2887           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2888          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     ??zclParseInReadReportCfgRspCmd:
   2889          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   2890            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   2891            uint8 reportChangeLen;
   2892            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine86 & 0xFFFF
   2893            uint8 *dataPtr;
   2894            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_364:
   \   000019   75..00       MOV     ?V4,#0x0
   2895            uint8 hdrLen;
   2896            uint16 dataLen = 0;
   \   00001C   75..00       MOV     ?V6,#0x0
   \   00001F   75..00       MOV     ?V7,#0x0
   \   000022   8007         SJMP    ??zclParseInReadReportCfgRspCmd_1
   2897          
   2898            // Calculate the length of the response command
   2899            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2900            {
   2901              uint8 status;
   2902              uint8 direction;
   2903          
   2904              numAttr++;
   2905              status = *pBuf++;
   2906              direction = *pBuf++;
   2907              pBuf += 2; // move pass the attribute ID
   2908          
   2909              if ( status == ZCL_STATUS_SUCCESS )
   2910              {
   2911                if ( direction == ZCL_SEND_ATTR_REPORTS )
   2912                {
   2913                  uint8 dataType = *pBuf++;
   2914                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   2915          
   2916                  // For attributes of 'discrete' data types this field is omitted
   2917                  if ( zclAnalogDataType( dataType ) )
   2918                  {
   2919                    reportChangeLen = zclGetDataTypeLength( dataType );
   2920                    pBuf += reportChangeLen;
   2921          
   2922                    // add padding if needed
   2923                    if ( PADDING_NEEDED( reportChangeLen ) )
   2924                    {
   2925                      reportChangeLen++;
   2926                    }
   2927          
   2928                    dataLen += reportChangeLen;
   2929                  }
   2930                }
   2931                else
   2932                {
   2933                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   000024   EE           MOV     A,R6
   \   000025   2402         ADD     A,#0x2
   \   000027   FE           MOV     R6,A
   \   000028   5001         JNC     ??zclParseInReadReportCfgRspCmd_1
   \   00002A   0F           INC     R7
   2934                }
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   00002B   85..82       MOV     DPL,?V2
   \   00002E   85..83       MOV     DPH,?V3
   \   000031   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000034   5045         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000036   05..         INC     ?V4
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   00003F   A3           INC     DPTR
   \   000040   AF83         MOV     R7,DPH
   \   000042   E582         MOV     A,DPL
   \   000044   2402         ADD     A,#0x2
   \   000046   FE           MOV     R6,A
   \   000047   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000049   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   00004A   E8           MOV     A,R0
   \   00004B   70DE         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   00004D   E9           MOV     A,R1
   \   00004E   70D4         JNZ     ??zclParseInReadReportCfgRspCmd_2
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F5..         MOV     ?V5,A
   \   000057   A3           INC     DPTR
   \   000058   AF83         MOV     R7,DPH
   \   00005A   E582         MOV     A,DPL
   \   00005C   2404         ADD     A,#0x4
   \   00005E   FE           MOV     R6,A
   \   00005F   5001         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   000061   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   000062                ; Setup parameters for call to function zclAnalogDataType
   \   000062   A9..         MOV     R1,?V5
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60C1         JZ      ??zclParseInReadReportCfgRspCmd_1
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   A9..         MOV     R1,?V5
   \   00006C   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006F   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000072   5002         JNC     ??zclParseInReadReportCfgRspCmd_6
   \   000074   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   000076   12....       LCALL   ?Subroutine102 & 0xFFFF
   2935              }
   2936            } // while loop
   \                     ??CrossCallReturnLabel_176:
   \   000079   80B0         SJMP    ??zclParseInReadReportCfgRspCmd_1
   2937          
   2938            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   00007B   75F00D       MOV     B,#0xd
   \   00007E   E5..         MOV     A,?V4
   \   000080   A4           MUL     AB
   \   000081   240E         ADD     A,#0xe
   \   000083   12....       LCALL   ?Subroutine103 & 0xFFFF
   2939          
   2940            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_179:
   \   000086   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000089   8A..         MOV     ?V6,R2
   \   00008B   8B..         MOV     ?V7,R3
   2941            if ( readReportCfgRspCmd != NULL )
   \   00008D   EA           MOV     A,R2
   \   00008E   45..         ORL     A,?V7
   \   000090   7003         JNZ     $+5
   \   000092   02....       LJMP    ??zclParseInReadReportCfgRspCmd_7 & 0xFFFF
   2942            {
   2943              uint8 i;
   2944              pBuf = pCmd->pData;
   \   000095   12....       LCALL   ?Subroutine71 & 0xFFFF
   2945              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_328:
   \   000098   F5..         MOV     ?V2,A
   \   00009A   E4           CLR     A
   \   00009B   3B           ADDC    A,R3
   \   00009C   F5..         MOV     ?V3,A
   2946          
   2947              readReportCfgRspCmd->numAttr = numAttr;
   \   00009E   8A82         MOV     DPL,R2
   \   0000A0   8B83         MOV     DPH,R3
   \   0000A2   E5..         MOV     A,?V4
   \   0000A4   F0           MOVX    @DPTR,A
   2948              for ( i = 0; i < numAttr; i++ )
   \   0000A5   75..00       MOV     ?V5,#0x0
   \   0000A8   800C         SJMP    ??zclParseInReadReportCfgRspCmd_8
   2949              {
   2950                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   2951          
   2952                reportRspRec->status = *pBuf++;
   2953                reportRspRec->direction = *pBuf++;
   2954                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2955                pBuf += 2;
   2956          
   2957                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   2958                {
   2959                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   2960                  {
   2961                    reportRspRec->dataType = *pBuf++;
   2962                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2963                    pBuf += 2;
   2964                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2965                    pBuf += 2;
   2966          
   2967                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   2968                    {
   2969                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   2970                      reportRspRec->reportableChange = dataPtr;
   2971          
   2972                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   2973                      pBuf += reportChangeLen;
   2974          
   2975                      // advance attribute data pointer
   2976                      if ( PADDING_NEEDED( reportChangeLen ) )
   2977                      {
   2978                        reportChangeLen++;
   2979                      }
   2980          
   2981                      dataPtr += reportChangeLen;
   2982                    }
   2983                  }
   2984                  else
   2985                  {
   2986                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000AA   12....       LCALL   ?Subroutine57 & 0xFFFF
   2987                    pBuf += 2;
   2988                  }
   \                     ??CrossCallReturnLabel_77:
   \   0000AD   A3           INC     DPTR
   \   0000AE   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   0000B1   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000B3   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000B4   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000B6   E5..         MOV     A,?V5
   \   0000B8   C3           CLR     C
   \   0000B9   95..         SUBB    A,?V4
   \   0000BB   4003         JC      $+5
   \   0000BD   02....       LJMP    ??zclParseInReadReportCfgRspCmd_7 & 0xFFFF
   \   0000C0   E5..         MOV     A,?V5
   \   0000C2   75F00D       MOV     B,#0xd
   \   0000C5   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   0000C8   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   0000CB   12....       LCALL   ??Subroutine150_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   0000CE   FD           MOV     R5,A
   \   0000CF   85..82       MOV     DPL,?V0
   \   0000D2   85..83       MOV     DPH,?V1
   \   0000D5   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000D8   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   0000DB   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   0000DE   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   0000E0   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   0000E1   EC           MOV     A,R4
   \   0000E2   70D0         JNZ     ??zclParseInReadReportCfgRspCmd_10
   \   0000E4   8E82         MOV     DPL,R6
   \   0000E6   8F83         MOV     DPH,R7
   \   0000E8   A3           INC     DPTR
   \   0000E9   A882         MOV     R0,DPL
   \   0000EB   A983         MOV     R1,DPH
   \   0000ED   8E82         MOV     DPL,R6
   \   0000EF   8F83         MOV     DPH,R7
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   F5..         MOV     ?V10,A
   \   0000F4   ED           MOV     A,R5
   \   0000F5   70B3         JNZ     ??zclParseInReadReportCfgRspCmd_9
   \   0000F7   E5..         MOV     A,?V0
   \   0000F9   2404         ADD     A,#0x4
   \   0000FB   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000FE   A3           INC     DPTR
   \   0000FF   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   000102   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   000104   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   000105   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000108   A3           INC     DPTR
   \   000109   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   00010C   5001         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   00010E   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   00010F                ; Setup parameters for call to function zclAnalogDataType
   \   00010F   A9..         MOV     R1,?V10
   \   000111   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000114   E9           MOV     A,R1
   \   000115   609D         JZ      ??zclParseInReadReportCfgRspCmd_10
   \   000117                ; Setup parameters for call to function zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
   \   000117   EE           MOV     A,R6
   \   000118   FC           MOV     R4,A
   \   000119   EF           MOV     A,R7
   \   00011A   FD           MOV     R5,A
   \   00011B   AA..         MOV     R2,?V2
   \   00011D   AB..         MOV     R3,?V3
   \   00011F   85..82       MOV     DPL,?V8
   \   000122   85..83       MOV     DPH,?V9
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F9           MOV     R1,A
   \   000127   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
   \   00012A   E5..         MOV     A,?V0
   \   00012C   240B         ADD     A,#0xb
   \   00012E   F582         MOV     DPL,A
   \   000130   E4           CLR     A
   \   000131   35..         ADDC    A,?V1
   \   000133   F583         MOV     DPH,A
   \   000135   E5..         MOV     A,?V2
   \   000137   F0           MOVX    @DPTR,A
   \   000138   A3           INC     DPTR
   \   000139   E5..         MOV     A,?V3
   \   00013B   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   00013E   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000141   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000144   5002         JNC     ??zclParseInReadReportCfgRspCmd_14
   \   000146   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_14:
   \   000148   E5..         MOV     A,?V2
   \   00014A   25..         ADD     A,?V10
   \   00014C   F5..         MOV     ?V2,A
   \   00014E   E4           CLR     A
   \   00014F   35..         ADDC    A,?V3
   \   000151   F5..         MOV     ?V3,A
   \   000153   02....       LJMP    ??zclParseInReadReportCfgRspCmd_10 & 0xFFFF
   2989                }
   2990              }
   2991            }
   2992          
   2993            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   000156   02....       LJMP    ?Subroutine5 & 0xFFFF
   2994          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine161_0
   \   000002                ; // Fall through to label ??Subroutine161_0
   2995          
   2996          /*********************************************************************
   2997           * @fn      zclParseInReportCmd
   2998           *
   2999           * @brief   Parse the "Profile" Report Command
   3000           *
   3001           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3002           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3003           *
   3004           * @param   pCmd - pointer to incoming data to parse
   3005           *
   3006           * @return  pointer to the parsed command structure
   3007           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3008          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   3009          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3010            zclReportCmd_t *reportCmd;
   3011            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V2,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V3,A
   \   000013   85..82       MOV     DPL,?V2
   \   000016   12....       LCALL   ?Subroutine86 & 0xFFFF
   3012            uint16 attrDataLen;
   3013            uint8 *dataPtr;
   3014            uint8 numAttr = 0;
   \                     ??CrossCallReturnLabel_365:
   \   000019   75..00       MOV     ?V7,#0x0
   3015            uint8 hdrLen;
   3016            uint16 dataLen = 0;
   \   00001C   75..00       MOV     ?V4,#0x0
   \   00001F   75..00       MOV     ?V5,#0x0
   \   000022   8033         SJMP    ??zclParseInReportCmd_0
   3017          
   3018            // find out the number of attributes and the length of attribute data
   3019            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3020            {
   3021              uint8 dataType;
   3022          
   3023              numAttr++;
   \                     ??zclParseInReportCmd_1:
   \   000024   05..         INC     ?V7
   3024              pBuf += 2; // move pass attribute id
   \   000026   EE           MOV     A,R6
   \   000027   2402         ADD     A,#0x2
   \   000029   FE           MOV     R6,A
   \   00002A   5001         JNC     ??zclParseInReportCmd_2
   \   00002C   0F           INC     R7
   3025          
   3026              dataType = *pBuf++;
   \                     ??zclParseInReportCmd_2:
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   A3           INC     DPTR
   \   000034   AE82         MOV     R6,DPL
   \   000036   AF83         MOV     R7,DPH
   3027          
   3028              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000038                ; Setup parameters for call to function zclGetAttrDataLength
   \   000038   EE           MOV     A,R6
   \   000039   FA           MOV     R2,A
   \   00003A   EF           MOV     A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00003F   12....       LCALL   ?Subroutine101 & 0xFFFF
   3029              pBuf += attrDataLen; // move pass attribute data
   3030          
   3031              // add padding if needed
   3032              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_174:
   \   000042   5007         JNC     ??zclParseInReportCmd_3
   3033              {
   3034                attrDataLen++;
   \   000044   05..         INC     ?V0
   \   000046   04           INC     A
   \   000047   7002         JNZ     ??zclParseInReportCmd_3
   \   000049   05..         INC     ?V1
   3035              }
   3036          
   3037              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_3:
   \   00004B   E5..         MOV     A,?V4
   \   00004D   25..         ADD     A,?V0
   \   00004F   F5..         MOV     ?V4,A
   \   000051   E5..         MOV     A,?V5
   \   000053   35..         ADDC    A,?V1
   \   000055   F5..         MOV     ?V5,A
   3038            }
   \                     ??zclParseInReportCmd_0:
   \   000057   85..82       MOV     DPL,?V8
   \   00005A   85..83       MOV     DPH,?V9
   \   00005D   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   000060   85..82       MOV     DPL,?V2
   \   000063   85..83       MOV     DPH,?V3
   \   000066   12....       LCALL   ??Subroutine156_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   000069   40B9         JC      ??zclParseInReportCmd_1
   3039          
   3040            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   00006B   75F005       MOV     B,#0x5
   \   00006E   E5..         MOV     A,?V7
   \   000070   A4           MUL     AB
   \   000071   2406         ADD     A,#0x6
   \   000073   F5..         MOV     ?V6,A
   3041          
   3042            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000075                ; Setup parameters for call to function osal_mem_alloc
   \   000075   25..         ADD     A,?V4
   \   000077   FA           MOV     R2,A
   \   000078   E4           CLR     A
   \   000079   35..         ADDC    A,?V5
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00007F   8A..         MOV     ?V10,R2
   \   000081   8B..         MOV     ?V11,R3
   3043            if (reportCmd != NULL )
   \   000083   EA           MOV     A,R2
   \   000084   45..         ORL     A,?V11
   \   000086   7003         JNZ     $+5
   \   000088   02....       LJMP    ??zclParseInReportCmd_4 & 0xFFFF
   3044            {
   3045              uint8 i;
   3046              pBuf = pCmd->pData;
   \   00008B   85..82       MOV     DPL,?V2
   \   00008E   85..83       MOV     DPH,?V3
   \   000091   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   3047              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_360:
   \   000094   85....       MOV     ?V0,?V6
   \   000097   EA           MOV     A,R2
   \   000098   25..         ADD     A,?V0
   \   00009A   F5..         MOV     ?V2,A
   \   00009C   E4           CLR     A
   \   00009D   3B           ADDC    A,R3
   \   00009E   F5..         MOV     ?V3,A
   3048          
   3049              reportCmd->numAttr = numAttr;
   \   0000A0   8A82         MOV     DPL,R2
   \   0000A2   8B83         MOV     DPH,R3
   \   0000A4   E5..         MOV     A,?V7
   \   0000A6   F0           MOVX    @DPTR,A
   3050              for ( i = 0; i < numAttr; i++ )
   \   0000A7   75..00       MOV     ?V8,#0x0
   \   0000AA   8064         SJMP    ??zclParseInReportCmd_5
   3051              {
   3052                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_6:
   \   0000AC   E5..         MOV     A,?V8
   \   0000AE   75F005       MOV     B,#0x5
   \   0000B1   12....       LCALL   ?Subroutine12 & 0xFFFF
   3053          
   3054                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3055                pBuf += 2;
   \                     ??CrossCallReturnLabel_335:
   \   0000B4   5001         JNC     ??zclParseInReportCmd_7
   \   0000B6   0F           INC     R7
   3056                reportRec->dataType = *pBuf++;
   \                     ??zclParseInReportCmd_7:
   \   0000B7   8E82         MOV     DPL,R6
   \   0000B9   8F83         MOV     DPH,R7
   \   0000BB   E0           MOVX    A,@DPTR
   \   0000BC   F9           MOV     R1,A
   \   0000BD   12....       LCALL   ?Subroutine19 & 0xFFFF
   3057          
   3058                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_324:
   \   0000C0                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C0   EE           MOV     A,R6
   \   0000C1   FA           MOV     R2,A
   \   0000C2   EF           MOV     A,R7
   \   0000C3   FB           MOV     R3,A
   \   0000C4   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000C7   8A..         MOV     ?V0,R2
   \   0000C9   8B..         MOV     ?V1,R3
   3059                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   0000CB                ; Setup parameters for call to function osal_memcpy
   \   0000CB   8E..         MOV     ?V4,R6
   \   0000CD   8F..         MOV     ?V5,R7
   \   0000CF   75..00       MOV     ?V6,#0x0
   \   0000D2   78..         MOV     R0,#?V4
   \   0000D4   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D7   AC..         MOV     R4,?V0
   \   0000D9   AD..         MOV     R5,?V1
   \   0000DB   AA..         MOV     R2,?V2
   \   0000DD   AB..         MOV     R3,?V3
   \   0000DF   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000E2   7403         MOV     A,#0x3
   \   0000E4   12....       LCALL   ?DEALLOC_XSTACK8
   3060                reportRec->attrData = dataPtr;
   \   0000E7   85..82       MOV     DPL,?V12
   \   0000EA   85..83       MOV     DPH,?V13
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   E5..         MOV     A,?V2
   \   0000F2   F0           MOVX    @DPTR,A
   \   0000F3   A3           INC     DPTR
   \   0000F4   E5..         MOV     A,?V3
   \   0000F6   12....       LCALL   ?Subroutine24 & 0xFFFF
   3061          
   3062                pBuf += attrDataLen; // move pass attribute data
   3063          
   3064                // advance attribute data pointer
   3065                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_19:
   \   0000F9   5007         JNC     ??zclParseInReportCmd_8
   3066                {
   3067                  attrDataLen++;
   \   0000FB   05..         INC     ?V0
   \   0000FD   04           INC     A
   \   0000FE   7002         JNZ     ??zclParseInReportCmd_8
   \   000100   05..         INC     ?V1
   3068                }
   3069          
   3070                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_8:
   \   000102   E5..         MOV     A,?V2
   \   000104   25..         ADD     A,?V0
   \   000106   F5..         MOV     ?V2,A
   \   000108   E5..         MOV     A,?V3
   \   00010A   35..         ADDC    A,?V1
   \   00010C   F5..         MOV     ?V3,A
   3071              }
   \   00010E   05..         INC     ?V8
   \                     ??zclParseInReportCmd_5:
   \   000110   E5..         MOV     A,?V8
   \   000112   C3           CLR     C
   \   000113   95..         SUBB    A,?V7
   \   000115   4095         JC      ??zclParseInReportCmd_6
   3072            }
   3073          
   3074            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_4:
   \   000117   02....       LJMP    ?Subroutine8 & 0xFFFF
   3075          }
   3076          #endif // ZCL_REPORT
   3077          
   3078          /*********************************************************************
   3079           * @fn      zclParseInDefaultRspCmd
   3080           *
   3081           * @brief   Parse the "Profile" Default Response Command
   3082           *
   3083           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3084           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3085           *
   3086           * @param   pCmd - pointer to incoming data to parse
   3087           *
   3088           * @return  pointer to the parsed command structure
   3089           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3090          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     ??zclParseInDefaultRspCmd:
   3091          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3092            zclDefaultRspCmd_t *defaultRspCmd;
   3093            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   3094          
   3095            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_361:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3096            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   600F         JZ      ??zclParseInDefaultRspCmd_1
   3097            {
   3098              defaultRspCmd->commandID = *pBuf++;
   \   00001A   8E82         MOV     DPL,R6
   \   00001C   8F83         MOV     DPH,R7
   \   00001E   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000021   12....       LCALL   ??Subroutine148_0 & 0xFFFF
   3099              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_289:
   \   000024   12....       LCALL   ?Subroutine87 & 0xFFFF
   3100            }
   \                     ??CrossCallReturnLabel_143:
   \   000027   A3           INC     DPTR
   \   000028   F0           MOVX    @DPTR,A
   3101          
   3102            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_1:
   \   000029   02....       LJMP    ??Subroutine152_0 & 0xFFFF
   3103          }
   3104          
   3105          #ifdef ZCL_DISCOVER
   3106          /*********************************************************************
   3107           * @fn      zclParseInDiscAttrsCmd
   3108           *
   3109           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3110           *
   3111           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3112           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3113           *
   3114           * @param   pCmd - pointer to incoming data to parse
   3115           *
   3116           * @return  pointer to the parsed command structure
   3117           */
   3118          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3119          {
   3120            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3121            uint8 *pBuf = pCmd->pData;
   3122          
   3123            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3124            if ( pDiscoverCmd != NULL )
   3125            {
   3126              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3127              pBuf += 2;
   3128              pDiscoverCmd->maxAttrIDs = *pBuf;
   3129            }
   3130          
   3131            return ( (void *)pDiscoverCmd );
   3132          }
   3133          
   3134          /*********************************************************************
   3135           * @fn      zclParseInDiscAttrsRspCmd
   3136           *
   3137           * @brief   Parse the "Profile" Discovery Response Commands
   3138           *
   3139           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3140           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3141           *
   3142           * @param   pCmd - pointer to incoming data to parse
   3143           *
   3144           * @return  pointer to the parsed command structure
   3145           */
   3146          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3147          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3148          {
   3149            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3150            uint8 *pBuf = pCmd->pData;
   3151            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3152          
   3153            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3154                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3155          
   3156            if ( pDiscoverRspCmd != NULL )
   3157            {
   3158              uint8 i;
   3159          
   3160              pDiscoverRspCmd->discComplete = *pBuf++;
   3161              pDiscoverRspCmd->numAttr = numAttr;
   3162          
   3163              for ( i = 0; i < numAttr; i++ )
   3164              {
   3165                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3166                pBuf += 2;
   3167                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3168              }
   3169            }
   3170          
   3171            return ( (void *)pDiscoverRspCmd );
   3172          }
   3173          
   3174          /*********************************************************************
   3175           * @fn      zclParseInDiscCmdsCmd
   3176           *
   3177           * @brief   Parse the "Profile" Discovery Commands
   3178           *
   3179           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3180           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3181           *
   3182           * @param   pCmd - pointer to incoming data to parse
   3183           *
   3184           * @return  pointer to the parsed command structure
   3185           */
   3186          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   3187          {
   3188            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   3189            uint8 *pBuf = pCmd->pData;
   3190          
   3191            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   3192            if ( pDiscoverCmd != NULL )
   3193            {
   3194              pDiscoverCmd->startCmdID = *pBuf++;
   3195              pDiscoverCmd->maxCmdID = *pBuf++;
   3196            }
   3197          
   3198            return ( (void *)pDiscoverCmd );
   3199          }
   3200          
   3201          /*********************************************************************
   3202           * @fn      zclParseInDiscCmdsRspCmd
   3203           *
   3204           * @brief   Parse the Discover Commands Response Command
   3205           *
   3206           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3207           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3208           *
   3209           * @param   pCmd - pointer to incoming data to parse
   3210           *
   3211           * @return  pointer to the parsed command structure
   3212           */
   3213          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3214          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   3215          {
   3216            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   3217            uint8 *pBuf = pCmd->pData;
   3218            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   3219          
   3220              // allocate memory for size of structure plus variable array
   3221            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   3222                              ( numCmds * sizeof(uint8) ) );
   3223            if ( pDiscoverRspCmd != NULL )
   3224            {
   3225              uint8 i;
   3226              pDiscoverRspCmd->discComplete = *pBuf++;
   3227              pDiscoverRspCmd->numCmd = numCmds;
   3228          
   3229              for ( i = 0; i < numCmds; i++ )
   3230              {
   3231                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   3232              }
   3233            }
   3234          
   3235            return ( (void *)pDiscoverRspCmd );
   3236          }
   3237          
   3238          /*********************************************************************
   3239           * @fn      zclParseInDiscAttrsExtRspCmd
   3240           *
   3241           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   3242           *
   3243           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3244           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3245           *
   3246           * @param   pCmd - pointer to incoming data to parse
   3247           *
   3248           * @return  pointer to the parsed command structure
   3249           */
   3250          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3251          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   3252          {
   3253            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   3254            uint8 i;
   3255            uint8 *pBuf = pCmd->pData;
   3256            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   3257          
   3258            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   3259                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   3260          
   3261            if ( pDiscoverRspCmd != NULL )
   3262            {
   3263              pDiscoverRspCmd->discComplete = *pBuf++;
   3264              pDiscoverRspCmd->numAttr = numAttrs;
   3265          
   3266              for ( i = 0; i < numAttrs; i++ )
   3267              {
   3268                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3269                pBuf += 2;
   3270                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   3271                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   3272              }
   3273            }
   3274          
   3275            return ( (void *)pDiscoverRspCmd );
   3276          }
   3277          #endif // ZCL_DISCOVER
   3278          
   3279          
   3280          /*********************************************************************
   3281           * @fn      zclProcessInReadCmd
   3282           *
   3283           * @brief   Process the "Profile" Read Command
   3284           *
   3285           * @param   pInMsg - incoming message to process
   3286           *
   3287           * @return  TRUE if command processed. FALSE, otherwise.
   3288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine133_0
   \   000001                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3289          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg ){
   \                     ??zclProcessInReadCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3290          	zclReadCmd_t *readCmd;
   3291          	zclReadRspCmd_t *readRspCmd;
   3292          	struct zclAttrRec_t attrRec;
   3293          	uint16 len;
   3294          	uint8 i;
   3295          
   3296          	readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   12....       LCALL   ?Subroutine72 & 0xFFFF
   3297          
   3298          	// calculate the length of the response status record
   3299          	len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   3300          
   3301          	readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( len );
   \                     ??CrossCallReturnLabel_107:
   \   00001A   75F006       MOV     B,#0x6
   \   00001D   A4           MUL     AB
   \   00001E   A9F0         MOV     R1,B
   \   000020   2407         ADD     A,#0x7
   \   000022   FA           MOV     R2,A
   \   000023   E4           CLR     A
   \   000024   39           ADDC    A,R1
   \   000025   FB           MOV     R3,A
   \   000026   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000029   8A..         MOV     ?V0,R2
   \   00002B   8B..         MOV     ?V1,R3
   3302          	if ( readRspCmd == NULL ){
   \   00002D   EA           MOV     A,R2
   \   00002E   45..         ORL     A,?V1
   \   000030   7005         JNZ     ??zclProcessInReadCmd_1
   3303          		return FALSE; // EMBEDDED RETURN
   \   000032   7900         MOV     R1,#0x0
   \   000034   02....       LJMP    ??zclProcessInReadCmd_2 & 0xFFFF
   3304          	}
   3305          
   3306          	readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_1:
   \   000037   85..82       MOV     DPL,?V8
   \   00003A   85..83       MOV     DPH,?V9
   \   00003D   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000040   F0           MOVX    @DPTR,A
   3307          	for ( i = 0; i < readCmd->numAttr; i++ ) {
   \   000041   75..00       MOV     ?V2,#0x0
   \   000044   800B         SJMP    ??zclProcessInReadCmd_3
   3308          		zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   3309          		statusRec->attrID = readCmd->attrID[i];
   3310          		if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, readCmd->attrID[i], &attrRec ) ){
   3311          			if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) ) {
   3312          				statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), &attrRec );
   3313          				if ( statusRec->status == ZCL_STATUS_SUCCESS ) {
   3314          					statusRec->data = (unsigned char *)attrRec.attr.dataPtr;
   3315          					statusRec->dataType = attrRec.attr.dataType;
   3316          				}
   3317          			} else {
   3318          				statusRec->status = ZCL_STATUS_WRITE_ONLY;
   3319          			}
   3320          		} else {
   3321          			statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_4:
   \   000046   85..82       MOV     DPL,?V10
   \   000049   85..83       MOV     DPH,?V11
   \   00004C   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_5:
   \   00004E   F0           MOVX    @DPTR,A
   3322          		}
   \   00004F   05..         INC     ?V2
   \                     ??zclProcessInReadCmd_3:
   \   000051   85..82       MOV     DPL,?V8
   \   000054   85..83       MOV     DPH,?V9
   \   000057   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   00005F   85..82       MOV     DPL,?V2
   \   000062   A882         MOV     R0,DPL
   \   000064   E8           MOV     A,R0
   \   000065   75F006       MOV     B,#0x6
   \   000068   A4           MUL     AB
   \   000069   FA           MOV     R2,A
   \   00006A   ABF0         MOV     R3,B
   \   00006C   E5..         MOV     A,?V0
   \   00006E   2A           ADD     A,R2
   \   00006F   F582         MOV     DPL,A
   \   000071   E5..         MOV     A,?V1
   \   000073   3B           ADDC    A,R3
   \   000074   F583         MOV     DPH,A
   \   000076   A3           INC     DPTR
   \   000077   8582..       MOV     ?V4,DPL
   \   00007A   8583..       MOV     ?V5,DPH
   \   00007D   E8           MOV     A,R0
   \   00007E   28           ADD     A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F9           MOV     R1,A
   \   000083   85..82       MOV     DPL,?V8
   \   000086   85..83       MOV     DPH,?V9
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   28           ADD     A,R0
   \   00008C   FA           MOV     R2,A
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   39           ADDC    A,R1
   \   000090   FB           MOV     R3,A
   \   000091   8A82         MOV     DPL,R2
   \   000093   8B83         MOV     DPH,R3
   \   000095   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000098   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   00009B   E5..         MOV     A,?V4
   \   00009D   2402         ADD     A,#0x2
   \   00009F   F5..         MOV     ?V10,A
   \   0000A1   E4           CLR     A
   \   0000A2   35..         ADDC    A,?V5
   \   0000A4   F5..         MOV     ?V11,A
   \   0000A6   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   0000A9                ; Setup parameters for call to function zclFindAttrRec
   \   0000A9   A8..         MOV     R0,?XSP + 0
   \   0000AB   A9..         MOV     R1,?XSP + 1
   \   0000AD   88..         MOV     ?V12,R0
   \   0000AF   89..         MOV     ?V13,R1
   \   0000B1   78..         MOV     R0,#?V12
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   8A82         MOV     DPL,R2
   \   0000B8   8B83         MOV     DPH,R3
   \   0000BA   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   0000BD   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000C0   7402         MOV     A,#0x2
   \   0000C2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C5   E9           MOV     A,R1
   \   0000C6   7003         JNZ     $+5
   \   0000C8   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \   0000CB   7405         MOV     A,#0x5
   \   0000CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000D3   85..82       MOV     DPL,?V10
   \   0000D6   85..83       MOV     DPH,?V11
   \   0000D9   5022         JNC     ??zclProcessInReadCmd_7
   \   0000DB   E4           CLR     A
   \   0000DC   F0           MOVX    @DPTR,A
   \   0000DD   7406         MOV     A,#0x6
   \   0000DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E2   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000E5   A3           INC     DPTR
   \   0000E6   A3           INC     DPTR
   \   0000E7   A3           INC     DPTR
   \   0000E8   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   0000EB   7404         MOV     A,#0x4
   \   0000ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   85..82       MOV     DPL,?V4
   \   0000F4   85..83       MOV     DPH,?V5
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   A3           INC     DPTR
   \   0000FA   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   0000FD   748F         MOV     A,#-0x71
   \   0000FF   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   3323          	}
   3324          
   3325          	// Build and send Read Response command
   3326          	zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,readRspCmd, !pInMsg->hdr.fc.direction,true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   000102   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000105                ; Setup parameters for call to function zcl_SendReadRsp
   \   000105   8E82         MOV     DPL,R6
   \   000107   8F83         MOV     DPH,R7
   \   000109   A3           INC     DPTR
   \   00010A   A3           INC     DPTR
   \   00010B   A3           INC     DPTR
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   A3           INC     DPTR
   \   00010F   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000112   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000115   75..01       MOV     ?V2,#0x1
   \   000118   78..         MOV     R0,#?V2
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00011D   8E82         MOV     DPL,R6
   \   00011F   8F83         MOV     DPH,R7
   \   000121   A3           INC     DPTR
   \   000122   A3           INC     DPTR
   \   000123   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   000126   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000129   78..         MOV     R0,#?V0
   \   00012B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00012E   85..82       MOV     DPL,?V6
   \   000131   85..83       MOV     DPH,?V7
   \   000134   A3           INC     DPTR
   \   000135   A3           INC     DPTR
   \   000136   A3           INC     DPTR
   \   000137   A3           INC     DPTR
   \   000138   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   00013B   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   00013E   12....       LCALL   ??zcl_SendReadRsp?relay; Banked call to: zcl_SendReadRsp
   \   000141   7405         MOV     A,#0x5
   \   000143   12....       LCALL   ?DEALLOC_XSTACK8
   3327          	zcl_mem_free( readRspCmd );
   \   000146                ; Setup parameters for call to function osal_mem_free
   \   000146   AA..         MOV     R2,?V0
   \   000148   AB..         MOV     R3,?V1
   \   00014A   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3328          
   3329          	return TRUE;
   \   00014D   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_2:
   \   00014F   740A         MOV     A,#0xa
   \   000151                REQUIRE ?Subroutine11
   \   000151                ; // Fall through to label ?Subroutine11
   3330          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   80..         SJMP    ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   E5..         MOV     A,?V6
   \   000002   2406         ADD     A,#0x6
   \   000004   FA           MOV     R2,A
   \   000005   E4           CLR     A
   \   000006   35..         ADDC    A,?V7
   \   000008   FB           MOV     R3,A
   \   000009   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine165_0
   \   000004                ; // Fall through to label ??Subroutine165_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   12....       LCALL   ??Subroutine145_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000003   85..82       MOV     DPL,?V6
   \   000006   85..83       MOV     DPH,?V7
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   000010   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   E5..         MOV     A,?V6
   \   000002   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   000005   35..         ADDC    A,?V7
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET
   3331          
   3332          
   3333          /*********************************************************************
   3334           * @fn      processInWriteCmd
   3335           *
   3336           * @brief   Process the "Profile" Write and Write No Response Commands
   3337           *
   3338           * @param   pInMsg - incoming message to process
   3339           *
   3340           * @return  TRUE if command processed. FALSE, otherwise.
   3341           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine147_0
   \   000006                ; // Fall through to label ??Subroutine147_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006                REQUIRE ??Subroutine158_0
   \   000006                ; // Fall through to label ??Subroutine158_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3342          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg ){
   \                     ??zclProcessInWriteCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   3343          	ZclWriteCmd *writeCmd;
   3344          	ZclWriteRspCmd writeRspCmd;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E4           CLR     A
   \   000015   F0           MOVX    @DPTR,A
   \   000016   04           INC     A
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   E4           CLR     A
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   F0           MOVX    @DPTR,A
   3345          	uint8 sendRsp = FALSE;
   \   00001E   F5..         MOV     ?V1,A
   3346          	uint8 j = 0;
   \   000020   F5..         MOV     ?V0,A
   3347          	uint8 i;
   3348          
   3349          	writeCmd = (ZclWriteCmd *)pInMsg->attrCmd;
   \   000022   EA           MOV     A,R2
   \   000023   240C         ADD     A,#0xc
   \   000025   F582         MOV     DPL,A
   \   000027   E4           CLR     A
   \   000028   35..         ADDC    A,?V5
   \   00002A   F583         MOV     DPH,A
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F5..         MOV     ?V12,A
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F5..         MOV     ?V13,A
   3350          	if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE ){
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6402         XRL     A,#0x2
   \   000041   703A         JNZ     ??zclProcessInWriteCmd_1
   3351          		writeRspCmd = ZclWriteRspCmd(writeCmd);
   \   000043                ; Setup parameters for call to function ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
   \   000043   AC..         MOV     R4,?V12
   \   000045   AD..         MOV     R5,?V13
   \   000047   7403         MOV     A,#0x3
   \   000049   12....       LCALL   ?XSTACK_DISP101_8
   \   00004C   12....       LCALL   ??ZclWriteRspCmd?relay; Banked call to: ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   AC..         MOV     R4,?XSP + 0
   \   000055   AD..         MOV     R5,?XSP + 1
   \   000057   7403         MOV     A,#0x3
   \   000059   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00005C                ; Setup parameters for call to function ZclWriteRspCmd::~ZclWriteRspCmd()
   \   00005C   7403         MOV     A,#0x3
   \   00005E   12....       LCALL   ?XSTACK_DISP101_8
   \   000061   12....       LCALL   `?~ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::~ZclWriteRspCmd()
   3352          		if (writeRspCmd.attrList == NULL){
   \   000064   7401         MOV     A,#0x1
   \   000066   12....       LCALL   ?XSTACK_DISP0_8
   \   000069   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   00006C   700C         JNZ     ??zclProcessInWriteCmd_2
   3353          			return FALSE;
   \   00006E                ; Setup parameters for call to function ZclWriteRspCmd::~ZclWriteRspCmd()
   \   00006E   AA..         MOV     R2,?XSP + 0
   \   000070   AB..         MOV     R3,?XSP + 1
   \   000072   12....       LCALL   `?~ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::~ZclWriteRspCmd()
   \   000075   7900         MOV     R1,#0x0
   \   000077   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   3354          		}
   3355          		sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_2:
   \   00007A   75..01       MOV     ?V1,#0x1
   3356          	}
   3357          
   3358          	ZclWriteRec *statusRec = writeCmd->attrList;
   \                     ??zclProcessInWriteCmd_1:
   \   00007D   85..82       MOV     DPL,?V12
   \   000080   85..83       MOV     DPH,?V13
   \   000083   A3           INC     DPTR
   \   000084   12....       LCALL   ?Subroutine114 & 0xFFFF
   3359          	for ( i = 0; i < writeCmd->numAttr; i++ ){
   \                     ??CrossCallReturnLabel_192:
   \   000087   75..00       MOV     ?V7,#0x0
   \   00008A   803A         SJMP    ??zclProcessInWriteCmd_4
   3360          		struct zclAttrRec_t attrRec;
   3361          		uint8 status;
   3362          
   3363          		if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) ) {
   3364                		if ( statusRec->dataType == attrRec.attr.dataType ) {
   3365                  		// Write the new attribute value
   3366          	        	if ( attrRec.attr.dataPtr != NULL ) {
   3367              	      		status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), &attrRec, statusRec );
   3368                  		} 	
   3369          
   3370          				// If successful, a write attribute status record shall NOT be generated
   3371          				if ( sendRsp && status != ZCL_STATUS_SUCCESS ) {
   3372          					// Attribute is read only - move on to the next write attribute record
   3373          					writeRspCmd.attrList[j].status = status;
   3374          					writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3375          				}
   3376          			} else {
   3377          				// Attribute data type is incorrect - move on to the next write attribute record
   3378          				if ( sendRsp ) {
   3379          					writeRspCmd.attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3380          					writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3381          				}
   3382          			}
   3383          		} else {
   3384                		// Attribute is not supported - move on to the next write attribute record
   3385                		if ( sendRsp ) {
   \                     ??zclProcessInWriteCmd_5:
   \   00008C   E5..         MOV     A,?V1
   \   00008E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000090   5028         JNC     ??zclProcessInWriteCmd_6
   3386                  		writeRspCmd.attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000092   7401         MOV     A,#0x1
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00009A   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteCmd_7:
   \   00009C   F0           MOVX    @DPTR,A
   3387                  		writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   \   00009D   85..82       MOV     DPL,?V2
   \   0000A0   85..83       MOV     DPH,?V3
   \   0000A3   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   3388                		}
   3389              	}
   \                     ??CrossCallReturnLabel_374:
   \   0000A6   7401         MOV     A,#0x1
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   2E           ADD     A,R6
   \   0000AD   FA           MOV     R2,A
   \   0000AE   A3           INC     DPTR
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   3F           ADDC    A,R7
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   F583         MOV     DPH,A
   \   0000B5   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   0000B8   05..         INC     ?V0
   3390          		statusRec++;
   \                     ??zclProcessInWriteCmd_6:
   \   0000BA   E5..         MOV     A,?V2
   \   0000BC   2405         ADD     A,#0x5
   \   0000BE   F5..         MOV     ?V2,A
   \   0000C0   5002         JNC     ??zclProcessInWriteCmd_8
   \   0000C2   05..         INC     ?V3
   \                     ??zclProcessInWriteCmd_8:
   \   0000C4   05..         INC     ?V7
   \                     ??zclProcessInWriteCmd_4:
   \   0000C6   85..82       MOV     DPL,?V12
   \   0000C9   85..83       MOV     DPH,?V13
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   F8           MOV     R0,A
   \   0000CE   E5..         MOV     A,?V7
   \   0000D0   C3           CLR     C
   \   0000D1   98           SUBB    A,R0
   \   0000D2   4003         JC      $+5
   \   0000D4   02....       LJMP    ??zclProcessInWriteCmd_9 & 0xFFFF
   \   0000D7   E5..         MOV     A,?V0
   \   0000D9   75F003       MOV     B,#0x3
   \   0000DC   A4           MUL     AB
   \   0000DD   FE           MOV     R6,A
   \   0000DE   AFF0         MOV     R7,B
   \   0000E0   85..82       MOV     DPL,?V4
   \   0000E3   85..83       MOV     DPH,?V5
   \   0000E6   E0           MOVX    A,@DPTR
   \   0000E7   F5..         MOV     ?V10,A
   \   0000E9   A3           INC     DPTR
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   F5..         MOV     ?V11,A
   \   0000ED                ; Setup parameters for call to function zclFindAttrRec
   \   0000ED   7406         MOV     A,#0x6
   \   0000EF   12....       LCALL   ?XSTACK_DISP100_8
   \   0000F2   88..         MOV     ?V8,R0
   \   0000F4   89..         MOV     ?V9,R1
   \   0000F6   78..         MOV     R0,#?V8
   \   0000F8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FB   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   0000FE   85..82       MOV     DPL,?V10
   \   000101   85..83       MOV     DPH,?V11
   \   000104   A3           INC     DPTR
   \   000105   A3           INC     DPTR
   \   000106   A3           INC     DPTR
   \   000107   A3           INC     DPTR
   \   000108   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   00010B   E5..         MOV     A,?V10
   \   00010D   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000110   35..         ADDC    A,?V11
   \   000112   F583         MOV     DPH,A
   \   000114   E0           MOVX    A,@DPTR
   \   000115   F9           MOV     R1,A
   \   000116   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000119   7402         MOV     A,#0x2
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011E   E9           MOV     A,R1
   \   00011F   7003         JNZ     $+5
   \   000121   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000124   85..82       MOV     DPL,?V2
   \   000127   85..83       MOV     DPH,?V3
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   F8           MOV     R0,A
   \   00012E   740A         MOV     A,#0xa
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   E0           MOVX    A,@DPTR
   \   000134   68           XRL     A,R0
   \   000135   7059         JNZ     ??zclProcessInWriteCmd_10
   \   000137   740C         MOV     A,#0xc
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   00013F   6032         JZ      ??zclProcessInWriteCmd_11
   \   000141   85..82       MOV     DPL,?V4
   \   000144   85..83       MOV     DPH,?V5
   \   000147   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   00014A                ; Setup parameters for call to function zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
   \   00014A   78..         MOV     R0,#?V2
   \   00014C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014F   7408         MOV     A,#0x8
   \   000151   12....       LCALL   ?XSTACK_DISP102_8
   \   000154   E5..         MOV     A,?V8
   \   000156   2406         ADD     A,#0x6
   \   000158   FA           MOV     R2,A
   \   000159   E4           CLR     A
   \   00015A   35..         ADDC    A,?V9
   \   00015C   FB           MOV     R3,A
   \   00015D   E5..         MOV     A,?V8
   \   00015F   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000162   35..         ADDC    A,?V9
   \   000164   F583         MOV     DPH,A
   \   000166   E0           MOVX    A,@DPTR
   \   000167   F9           MOV     R1,A
   \   000168   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
   \   00016B   7402         MOV     A,#0x2
   \   00016D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000170   E9           MOV     A,R1
   \   000171   F5..         MOV     ?V6,A
   \                     ??zclProcessInWriteCmd_11:
   \   000173   E5..         MOV     A,?V1
   \   000175   A2E0         MOV     C,0xE0 /* A   */.0
   \   000177   4003         JC      $+5
   \   000179   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   00017C   E5..         MOV     A,?V6
   \   00017E   7003         JNZ     $+5
   \   000180   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000183   7401         MOV     A,#0x1
   \   000185   12....       LCALL   ?XSTACK_DISP0_8
   \   000188   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   00018B   E5..         MOV     A,?V6
   \   00018D   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \                     ??zclProcessInWriteCmd_10:
   \   000190   E5..         MOV     A,?V1
   \   000192   A2E0         MOV     C,0xE0 /* A   */.0
   \   000194   4003         JC      $+5
   \   000196   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \   000199   7401         MOV     A,#0x1
   \   00019B   12....       LCALL   ?XSTACK_DISP0_8
   \   00019E   12....       LCALL   ?Subroutine62 & 0xFFFF
   3391            	} // for loop
   \                     ??CrossCallReturnLabel_93:
   \   0001A1   748D         MOV     A,#-0x73
   \   0001A3   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   3392          
   3393          	if ( sendRsp ){
   \                     ??zclProcessInWriteCmd_9:
   \   0001A6   E5..         MOV     A,?V1
   \   0001A8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001AA   5055         JNC     ??zclProcessInWriteCmd_12
   3394              	writeRspCmd.numAttr = j;
   \   0001AC   85..82       MOV     DPL,?XSP + 0
   \   0001AF   85..83       MOV     DPH,?XSP + 1
   \   0001B2   E5..         MOV     A,?V0
   \   0001B4   F0           MOVX    @DPTR,A
   3395              	if ( writeRspCmd.numAttr == 0 ) {
   \   0001B5   7008         JNZ     ??CrossCallReturnLabel_32
   3396                		// Since all records were written successful, include a single status record in the resonse command with the status field set to SUCCESS and the attribute ID field omitted.
   3397                		writeRspCmd.attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0001B7   7401         MOV     A,#0x1
   \   0001B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BC   12....       LCALL   ?Subroutine35 & 0xFFFF
   3398                		writeRspCmd.numAttr = 1;
   3399              	}
   3400          
   3401              	zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId, &writeRspCmd, !pInMsg->hdr.fc.direction, true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_32:
   \   0001BF   85..82       MOV     DPL,?V4
   \   0001C2   85..83       MOV     DPH,?V5
   \   0001C5   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   3402            	}
   \                     ??CrossCallReturnLabel_362:
   \   0001C8                ; Setup parameters for call to function zcl_SendWriteRsp
   \   0001C8   85..82       MOV     DPL,?V4
   \   0001CB   85..83       MOV     DPH,?V5
   \   0001CE   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   0001D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D4   75..01       MOV     ?V0,#0x1
   \   0001D7   78..         MOV     R0,#?V0
   \   0001D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001DC   85..82       MOV     DPL,?V4
   \   0001DF   85..83       MOV     DPH,?V5
   \   0001E2   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   0001E5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001E8   7403         MOV     A,#0x3
   \   0001EA   12....       LCALL   ?XSTACK_DISP100_8
   \   0001ED   88..         MOV     ?V0,R0
   \   0001EF   89..         MOV     ?V1,R1
   \   0001F1   78..         MOV     R0,#?V0
   \   0001F3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001F6   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   0001F9   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0001FC   7405         MOV     A,#0x5
   \   0001FE   12....       LCALL   ?DEALLOC_XSTACK8
   3403          
   3404            	return TRUE;
   \                     ??zclProcessInWriteCmd_12:
   \   000201                ; Setup parameters for call to function ZclWriteRspCmd::~ZclWriteRspCmd()
   \   000201   AA..         MOV     R2,?XSP + 0
   \   000203   AB..         MOV     R3,?XSP + 1
   \   000205   12....       LCALL   `?~ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::~ZclWriteRspCmd()
   \   000208   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_3:
   \   00020A   7410         MOV     A,#0x10
   \   00020C   02....       LJMP    ?Subroutine11 & 0xFFFF
   3405          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2E           ADD     A,R6
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3F           ADDC    A,R7
   \   000006   8882         MOV     DPL,R0
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine164_0
   \   000002                ; // Fall through to label ??Subroutine164_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V3,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000007   EE           MOV     A,R6
   \   000008   2406         ADD     A,#0x6
   \   00000A   FA           MOV     R2,A
   \   00000B   E4           CLR     A
   \   00000C   3F           ADDC    A,R7
   \   00000D   FB           MOV     R3,A
   \   00000E   EE           MOV     A,R6
   \   00000F   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000012   3F           ADDC    A,R7
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   04           INC     A
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET
   3406          
   3407          /*********************************************************************
   3408           * @fn      zclRevertWriteUndividedCmd
   3409           *
   3410           * @brief   Revert the "Profile" Write Undevided Command
   3411           *
   3412           * @param   pInMsg - incoming message to process
   3413           * @param   curWriteRec - old data
   3414           * @param   numAttr - number of attributes to be reverted
   3415           *
   3416           * @return  none
   3417           */
   3418          static void zclRevertWriteUndividedCmd(uint8 endpoint, uint16 clusterId,  ZclWriteRec *curWriteRec, uint16 numAttr, uint8 * oldData ){
   3419           	uint8 i;
   3420          
   3421          	struct zclAttrRec_t attrRec;
   3422           	for ( i = 0; i < numAttr; i++ ){
   3423          		if ( !zclFindAttrRec( endpoint, clusterId,  curWriteRec->attrID, &attrRec ) ) {
   3424                		break; // should never happen
   3425              	}
   3426          
   3427          		if ( attrRec.attr.dataPtr != NULL ){
   3428          			uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, curWriteRec->attrData );
   3429                		zcl_memcpy( attrRec.attr.dataPtr, curWriteRec->attrData, dataLen );
   3430              	}
   3431          		curWriteRec++;
   3432          	}
   3433          }
   3434          
   3435          /*********************************************************************
   3436           * @fn      zclProcessInWriteUndividedCmd
   3437           *
   3438           * @brief   Process the "Profile" Write Undivided Command
   3439           *
   3440           * @param   pInMsg - incoming message to process
   3441           *
   3442           * @return  TRUE if command processed. FALSE, otherwise.
   3443           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3444          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg ){
   \                     ??zclProcessInWriteUndividedCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 27
   \   000005   74E5         MOV     A,#-0x1b
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V8,R2
   \   00000C   8B..         MOV     ?V9,R3
   3445          	ZclWriteCmd *writeCmd;
   3446          
   3447          	struct zclAttrRec_t attrRec;
   3448          	uint16 dataLen;
   3449          	uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V4,#0x0
   \   000011   75..00       MOV     ?V5,#0x0
   3450          	uint8 j = 0;
   \   000014   75..00       MOV     ?V0,#0x0
   3451          	uint8 i;
   3452          
   3453          	writeCmd = (ZclWriteCmd *)pInMsg->attrCmd;
   \   000017   EA           MOV     A,R2
   \   000018   240C         ADD     A,#0xc
   \   00001A   F582         MOV     DPL,A
   \   00001C   E4           CLR     A
   \   00001D   35..         ADDC    A,?V9
   \   00001F   F583         MOV     DPH,A
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F5..         MOV     ?V12,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F5..         MOV     ?V13,A
   3454          
   3455          	ZclWriteRspCmd writeRspCmd(writeCmd);
   \   000028                ; Setup parameters for call to function ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
   \   000028   AC..         MOV     R4,?V12
   \   00002A   FD           MOV     R5,A
   \   00002B   AA..         MOV     R2,?XSP + 0
   \   00002D   AB..         MOV     R3,?XSP + 1
   \   00002F   12....       LCALL   ??ZclWriteRspCmd?relay; Banked call to: ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
   3456          	if (writeRspCmd.attrList == NULL){
   \   000032   7401         MOV     A,#0x1
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   00003A   7003         JNZ     $+5
   \   00003C   02....       LJMP    ??zclProcessInWriteUndividedCmd_1 & 0xFFFF
   3457          		return FALSE;
   3458          	}
   3459          
   3460          	// If any attribute cannot be written, no attribute values are changed. Hence, make sure all the attributes are supported and writable
   3461          	ZclWriteRec *statusRec = writeCmd->attrList;
   \   00003F   85..82       MOV     DPL,?V12
   \   000042   85..83       MOV     DPH,?V13
   \   000045   A3           INC     DPTR
   \   000046   8582..       MOV     ?V14,DPL
   \   000049   8583..       MOV     ?V15,DPH
   \   00004C   12....       LCALL   ?Subroutine90 & 0xFFFF
   3462          	for ( i = 0; i < writeCmd->numAttr; i++ ) {
   \                     ??CrossCallReturnLabel_147:
   \   00004F   803D         SJMP    ??zclProcessInWriteUndividedCmd_2
   3463          		if ( !zclFindAttrRec(pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec) ) {
   3464          			// Attribute is not supported - stop here
   3465          			writeRspCmd.attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3466          			writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3467          			break;
   3468          		}
   3469          
   3470          		if ( statusRec->dataType != attrRec.attr.dataType ) {
   3471          			// Attribute data type is incorrect - stope here
   3472          			writeRspCmd.attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3473          			writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3474                		break;
   3475          		}
   3476          
   3477              	if ( !zcl_AccessCtrlWrite(attrRec.attr.accessControl) ) {
   3478          			// Attribute is not writable - stop here
   3479          			writeRspCmd.attrList[j].status = ZCL_STATUS_READ_ONLY;
   3480          			writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3481          			break;
   3482          		}
   3483          
   3484          		if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) ) {
   3485          			// Not authorized to write - stop here
   3486          			writeRspCmd.attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   3487          			writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3488          			break;
   3489          		}
   3490          
   3491          		// Attribute Data length
   3492          		if ( attrRec.attr.dataPtr != NULL ) {
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   000051   740D         MOV     A,#0xd
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000059   600B         JZ      ??CrossCallReturnLabel_418
   3493          			dataLen = zclGetAttrDataLength( attrRec.attr.dataType, (unsigned char *) attrRec.attr.dataPtr );
   \   00005B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00005B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005E   7403         MOV     A,#0x3
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   3494          		}
   3495              
   3496          		// add padding if needed
   3497          		if ( PADDING_NEEDED( dataLen ) ) {
   \                     ??CrossCallReturnLabel_418:
   \   000066   7403         MOV     A,#0x3
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006E   5003         JNC     ??CrossCallReturnLabel_180
   3498          			dataLen++;
   \   000070   12....       LCALL   ?Subroutine104 & 0xFFFF
   3499          		}
   3500          
   3501          		curLen += dataLen;
   \                     ??CrossCallReturnLabel_180:
   \   000073   7403         MOV     A,#0x3
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   E0           MOVX    A,@DPTR
   \   000079   25..         ADD     A,?V4
   \   00007B   F5..         MOV     ?V4,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   35..         ADDC    A,?V5
   \   000081   F5..         MOV     ?V5,A
   3502          		statusRec++;
   \   000083   E5..         MOV     A,?V2
   \   000085   2405         ADD     A,#0x5
   \   000087   F5..         MOV     ?V2,A
   \   000089   5002         JNC     ??zclProcessInWriteUndividedCmd_4
   \   00008B   05..         INC     ?V3
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00008D   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00008E   85..82       MOV     DPL,?V12
   \   000091   85..83       MOV     DPH,?V13
   \   000094   E0           MOVX    A,@DPTR
   \   000095   F8           MOV     R0,A
   \   000096   EE           MOV     A,R6
   \   000097   C3           CLR     C
   \   000098   98           SUBB    A,R0
   \   000099   507E         JNC     ??zclProcessInWriteUndividedCmd_5
   \   00009B   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   00009E   12....       LCALL   ?XSTACK_DISP100_8
   \   0000A1   88..         MOV     ?V10,R0
   \   0000A3   89..         MOV     ?V11,R1
   \   0000A5   78..         MOV     R0,#?V10
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AA   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   0000AD   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000B0   7402         MOV     A,#0x2
   \   0000B2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B5   E9           MOV     A,R1
   \   0000B6   700C         JNZ     ??zclProcessInWriteUndividedCmd_6
   \   0000B8   7401         MOV     A,#0x1
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0000C0   7486         MOV     A,#-0x7a
   \   0000C2   8046         SJMP    ??zclProcessInWriteUndividedCmd_7
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   F9           MOV     R1,A
   \   0000CB   85..82       MOV     DPL,?V2
   \   0000CE   85..83       MOV     DPH,?V3
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   E0           MOVX    A,@DPTR
   \   0000D4   69           XRL     A,R1
   \   0000D5   600C         JZ      ??zclProcessInWriteUndividedCmd_8
   \   0000D7   7401         MOV     A,#0x1
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   0000DF   748D         MOV     A,#-0x73
   \   0000E1   8027         SJMP    ??zclProcessInWriteUndividedCmd_7
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   0000E3   740C         MOV     A,#0xc
   \   0000E5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   A2E1         MOV     C,0xE0 /* A   */.1
   \   0000EB   400C         JC      ??zclProcessInWriteUndividedCmd_9
   \   0000ED   7401         MOV     A,#0x1
   \   0000EF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F2   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   0000F5   7488         MOV     A,#-0x78
   \   0000F7   8011         SJMP    ??zclProcessInWriteUndividedCmd_7
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0000F9   A2E5         MOV     C,0xE0 /* A   */.5
   \   0000FB   4003         JC      $+5
   \   0000FD   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   \   000100   7401         MOV     A,#0x1
   \   000102   12....       LCALL   ?XSTACK_DISP0_8
   \   000105   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000108   747E         MOV     A,#0x7e
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   00010A   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000113   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000116   75..01       MOV     ?V0,#0x1
   3503          	} // for loop
   3504          
   3505          	writeRspCmd.numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   000119   12....       LCALL   ?Subroutine31 & 0xFFFF
   3506          	if ( writeRspCmd.numAttr ==  writeCmd->numAttr ){ // All attributes can be written
   \                     ??CrossCallReturnLabel_28:
   \   00011C   6003         JZ      $+5
   \   00011E   02....       LJMP    ??zclProcessInWriteUndividedCmd_10 & 0xFFFF
   3507           		uint8 *curDataPtr;
   3508          		uint8 *curWriteRec;
   3509          
   3510          		// Allocate space to keep a copy of the current data
   3511          		curWriteRec = (uint8 *) zcl_mem_alloc( curLen );
   \   000121                ; Setup parameters for call to function osal_mem_alloc
   \   000121   AA..         MOV     R2,?V4
   \   000123   AB..         MOV     R3,?V5
   \   000125   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000128   7405         MOV     A,#0x5
   \   00012A   12....       LCALL   ?XSTACK_DISP0_8
   \   00012D   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   3512          		if ( curWriteRec == NULL ){
   \                     ??CrossCallReturnLabel_419:
   \   000130   7405         MOV     A,#0x5
   \   000132   12....       LCALL   ?XSTACK_DISP0_8
   \   000135   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000138   700C         JNZ     ??zclProcessInWriteUndividedCmd_11
   3513          			return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00013A                ; Setup parameters for call to function ZclWriteRspCmd::~ZclWriteRspCmd()
   \   00013A   AA..         MOV     R2,?XSP + 0
   \   00013C   AB..         MOV     R3,?XSP + 1
   \   00013E   12....       LCALL   `?~ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::~ZclWriteRspCmd()
   \   000141   7900         MOV     R1,#0x0
   \   000143   02....       LJMP    ??zclProcessInWriteUndividedCmd_12 & 0xFFFF
   3514              	}
   3515          
   3516          		curDataPtr = curWriteRec;
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000146   7405         MOV     A,#0x5
   \   000148   12....       LCALL   ?XSTACK_DISP0_8
   \   00014B   12....       LCALL   ?Subroutine79 & 0xFFFF
   3517          
   3518          		// Write the new data over
   3519          		statusRec = writeCmd->attrList;
   \                     ??CrossCallReturnLabel_122:
   \   00014E   85..82       MOV     DPL,?V14
   \   000151   85..83       MOV     DPH,?V15
   \   000154   12....       LCALL   ?Subroutine90 & 0xFFFF
   3520          		for ( i = 0; i < writeCmd->numAttr; i++ ) {
   \                     ??CrossCallReturnLabel_148:
   \   000157   802A         SJMP    ??zclProcessInWriteUndividedCmd_13
   3521          			uint8 status;
   3522          			
   3523          			if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, statusRec->attrID, &attrRec ) ) {
   3524          				break; // should never happen
   3525          			}
   3526          			if ( attrRec.attr.dataPtr != NULL ) {
   3527          				zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   3528                  		status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), &attrRec, statusRec );
   3529          			}
   3530          			if ( status != ZCL_STATUS_SUCCESS ) {
   3531          				// error, so a attribute status record are generated
   3532          				writeRspCmd.attrList[j].status = status;
   3533          				writeRspCmd.attrList[j++].attrID = statusRec->attrID;
   3534          
   3535          				// Since this write failed, we need to revert all the pervious writes
   3536          				zclRevertWriteUndividedCmd(  pInMsg->msg->endPoint,  pInMsg->msg->clusterId,writeCmd->attrList, i, curWriteRec);
   3537          				break;
   3538          			}
   3539          
   3540          			// add padding if needed
   3541          			if ( PADDING_NEEDED( dataLen ) ) {
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   000159   7403         MOV     A,#0x3
   \   00015B   12....       LCALL   ?XSTACK_DISP0_8
   \   00015E   E0           MOVX    A,@DPTR
   \   00015F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000161   5003         JNC     ??CrossCallReturnLabel_181
   3542          				dataLen++;
   \   000163   12....       LCALL   ?Subroutine104 & 0xFFFF
   3543          			}
   3544          
   3545          			curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_181:
   \   000166   7403         MOV     A,#0x3
   \   000168   12....       LCALL   ?XSTACK_DISP0_8
   \   00016B   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   00016E   E5..         MOV     A,?V4
   \   000170   28           ADD     A,R0
   \   000171   F5..         MOV     ?V4,A
   \   000173   E5..         MOV     A,?V5
   \   000175   39           ADDC    A,R1
   \   000176   F5..         MOV     ?V5,A
   3546          			statusRec++;
   \   000178   E5..         MOV     A,?V2
   \   00017A   2405         ADD     A,#0x5
   \   00017C   F5..         MOV     ?V2,A
   \   00017E   5002         JNC     ??zclProcessInWriteUndividedCmd_15
   \   000180   05..         INC     ?V3
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   000182   0E           INC     R6
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000183   85..82       MOV     DPL,?V12
   \   000186   85..83       MOV     DPH,?V13
   \   000189   E0           MOVX    A,@DPTR
   \   00018A   F8           MOV     R0,A
   \   00018B   EE           MOV     A,R6
   \   00018C   C3           CLR     C
   \   00018D   98           SUBB    A,R0
   \   00018E   4003         JC      $+5
   \   000190   02....       LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   \   000193   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000196   12....       LCALL   ?XSTACK_DISP100_8
   \   000199   88..         MOV     ?V10,R0
   \   00019B   89..         MOV     ?V11,R1
   \   00019D   78..         MOV     R0,#?V10
   \   00019F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A2   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   0001A5   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0001A8   7402         MOV     A,#0x2
   \   0001AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001AD   E9           MOV     A,R1
   \   0001AE   7003         JNZ     $+5
   \   0001B0   02....       LJMP    ??zclProcessInWriteUndividedCmd_16 & 0xFFFF
   \   0001B3   740D         MOV     A,#0xd
   \   0001B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B8   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   0001BB   603F         JZ      ??zclProcessInWriteUndividedCmd_17
   \   0001BD                ; Setup parameters for call to function zclReadAttrData
   \   0001BD   7403         MOV     A,#0x3
   \   0001BF   12....       LCALL   ?XSTACK_DISP100_8
   \   0001C2   88..         MOV     ?V6,R0
   \   0001C4   89..         MOV     ?V7,R1
   \   0001C6   78..         MOV     R0,#?V6
   \   0001C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001CB   7409         MOV     A,#0x9
   \   0001CD   12....       LCALL   ?XSTACK_DISP102_8
   \   0001D0   AA..         MOV     R2,?V4
   \   0001D2   AB..         MOV     R3,?V5
   \   0001D4   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   0001D7   7402         MOV     A,#0x2
   \   0001D9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001DC   85..82       MOV     DPL,?V8
   \   0001DF   85..83       MOV     DPH,?V9
   \   0001E2   12....       LCALL   ??Subroutine165_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   0001E5                ; Setup parameters for call to function zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
   \   0001E5   78..         MOV     R0,#?V2
   \   0001E7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001EA   7409         MOV     A,#0x9
   \   0001EC   12....       LCALL   ?XSTACK_DISP102_8
   \   0001EF   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   0001F2   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
   \   0001F5   7402         MOV     A,#0x2
   \   0001F7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FA   E9           MOV     A,R1
   \   0001FB   FF           MOV     R7,A
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   0001FC   EF           MOV     A,R7
   \   0001FD   7003         JNZ     $+5
   \   0001FF   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000202   E5..         MOV     A,?V0
   \   000204   75F003       MOV     B,#0x3
   \   000207   A4           MUL     AB
   \   000208   F8           MOV     R0,A
   \   000209   A9F0         MOV     R1,B
   \   00020B   7401         MOV     A,#0x1
   \   00020D   12....       LCALL   ?XSTACK_DISP0_8
   \   000210   E0           MOVX    A,@DPTR
   \   000211   28           ADD     A,R0
   \   000212   FA           MOV     R2,A
   \   000213   A3           INC     DPTR
   \   000214   E0           MOVX    A,@DPTR
   \   000215   39           ADDC    A,R1
   \   000216   8A82         MOV     DPL,R2
   \   000218   F583         MOV     DPH,A
   \   00021A   EF           MOV     A,R7
   \   00021B   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00021E   12....       LCALL   ?XSTACK_DISP0_8
   \   000221   E0           MOVX    A,@DPTR
   \   000222   28           ADD     A,R0
   \   000223   FC           MOV     R4,A
   \   000224   A3           INC     DPTR
   \   000225   E0           MOVX    A,@DPTR
   \   000226   39           ADDC    A,R1
   \   000227   8C82         MOV     DPL,R4
   \   000229   F583         MOV     DPH,A
   \   00022B   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_422:
   \   00022E   05..         INC     ?V0
   \   000230   85..82       MOV     DPL,?V14
   \   000233   85..83       MOV     DPH,?V15
   \   000236   12....       LCALL   ?Subroutine114 & 0xFFFF
   3547          		}
   \                     ??CrossCallReturnLabel_193:
   \   000239   85..82       MOV     DPL,?V8
   \   00023C   85..83       MOV     DPH,?V9
   \   00023F   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000242   E0           MOVX    A,@DPTR
   \   000243   F5..         MOV     ?V14,A
   \   000245   A3           INC     DPTR
   \   000246   E0           MOVX    A,@DPTR
   \   000247   F5..         MOV     ?V15,A
   \   000249   E8           MOV     A,R0
   \   00024A   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   00024D   39           ADDC    A,R1
   \   00024E   F583         MOV     DPH,A
   \   000250   E0           MOVX    A,@DPTR
   \   000251   F5..         MOV     ?V7,A
   \   000253   75..00       MOV     ?V1,#0x0
   \   000256   8057         SJMP    ??zclProcessInWriteUndividedCmd_18
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   000258   7417         MOV     A,#0x17
   \   00025A   12....       LCALL   ?XSTACK_DISP0_8
   \   00025D   12....       LCALL   ??Subroutine153_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   000260   6041         JZ      ??zclProcessInWriteUndividedCmd_20
   \   000262   E5..         MOV     A,?V2
   \   000264   2403         ADD     A,#0x3
   \   000266   F5..         MOV     ?V4,A
   \   000268   E4           CLR     A
   \   000269   35..         ADDC    A,?V3
   \   00026B   F5..         MOV     ?V5,A
   \   00026D                ; Setup parameters for call to function zclGetAttrDataLength
   \   00026D   85..82       MOV     DPL,?V4
   \   000270   F583         MOV     DPH,A
   \   000272   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000275   7415         MOV     A,#0x15
   \   000277   12....       LCALL   ?XSTACK_DISP0_8
   \   00027A   E0           MOVX    A,@DPTR
   \   00027B   F9           MOV     R1,A
   \   00027C   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00027F   8A..         MOV     ?V10,R2
   \   000281   8B..         MOV     ?V11,R3
   \   000283   AC..         MOV     R4,?V10
   \   000285   AD..         MOV     R5,?V11
   \   000287                ; Setup parameters for call to function osal_memcpy
   \   000287   85..82       MOV     DPL,?V4
   \   00028A   85..83       MOV     DPH,?V5
   \   00028D   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000290   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000293   741A         MOV     A,#0x1a
   \   000295   12....       LCALL   ?XSTACK_DISP0_8
   \   000298   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   00029B   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00029E   7403         MOV     A,#0x3
   \   0002A0   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclProcessInWriteUndividedCmd_20:
   \   0002A3   E5..         MOV     A,?V2
   \   0002A5   2405         ADD     A,#0x5
   \   0002A7   F5..         MOV     ?V2,A
   \   0002A9   5002         JNC     ??zclProcessInWriteUndividedCmd_21
   \   0002AB   05..         INC     ?V3
   \                     ??zclProcessInWriteUndividedCmd_21:
   \   0002AD   05..         INC     ?V1
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0002AF   EE           MOV     A,R6
   \   0002B0   F8           MOV     R0,A
   \   0002B1   E5..         MOV     A,?V1
   \   0002B3   C3           CLR     C
   \   0002B4   98           SUBB    A,R0
   \   0002B5   5025         JNC     ??zclProcessInWriteUndividedCmd_16
   \   0002B7                ; Setup parameters for call to function zclFindAttrRec
   \   0002B7   7411         MOV     A,#0x11
   \   0002B9   12....       LCALL   ?XSTACK_DISP100_8
   \   0002BC   88..         MOV     ?V4,R0
   \   0002BE   89..         MOV     ?V5,R1
   \   0002C0   78..         MOV     R0,#?V4
   \   0002C2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002C5   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_351:
   \   0002C8   AA..         MOV     R2,?V14
   \   0002CA   AB..         MOV     R3,?V15
   \   0002CC   A9..         MOV     R1,?V7
   \   0002CE   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0002D1   7402         MOV     A,#0x2
   \   0002D3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002D6   E9           MOV     A,R1
   \   0002D7   6003         JZ      $+5
   \   0002D9   02....       LJMP    ??zclProcessInWriteUndividedCmd_19 & 0xFFFF
   3548          
   3549              	writeRspCmd.numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0002DC   12....       LCALL   ?Subroutine31 & 0xFFFF
   3550              	if ( writeRspCmd.numAttr  ==  writeCmd->numAttr ) {
   \                     ??CrossCallReturnLabel_29:
   \   0002DF   7008         JNZ     ??CrossCallReturnLabel_33
   3551                		// Since all records were written successful, include a single status record in the resonse command with the status field set to SUCCESS and the attribute ID field omitted.
   3552          			writeRspCmd.attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002E1   7401         MOV     A,#0x1
   \   0002E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E6   12....       LCALL   ?Subroutine35 & 0xFFFF
   3553              		writeRspCmd.numAttr = 1;
   3554          		}
   3555          
   3556          		zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_33:
   \   0002E9                ; Setup parameters for call to function osal_mem_free
   \   0002E9   7405         MOV     A,#0x5
   \   0002EB   12....       LCALL   ?XSTACK_DISP0_8
   \   0002EE   12....       LCALL   ??Subroutine144_0 & 0xFFFF
   3557          	}
   \                     ??CrossCallReturnLabel_268:
   \   0002F1   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3558          
   3559          	zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId, &writeRspCmd, !pInMsg->hdr.fc.direction,  true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   0002F4   85..82       MOV     DPL,?V8
   \   0002F7   85..83       MOV     DPH,?V9
   \   0002FA   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   0002FD                ; Setup parameters for call to function zcl_SendWriteRsp
   \   0002FD   85..82       MOV     DPL,?V8
   \   000300   85..83       MOV     DPH,?V9
   \   000303   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   000306   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000309   75..01       MOV     ?V0,#0x1
   \   00030C   78..         MOV     R0,#?V0
   \   00030E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000311   85..82       MOV     DPL,?V8
   \   000314   85..83       MOV     DPH,?V9
   \   000317   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   00031A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00031D   7403         MOV     A,#0x3
   \   00031F   12....       LCALL   ?XSTACK_DISP100_8
   \   000322   88..         MOV     ?V0,R0
   \   000324   89..         MOV     ?V1,R1
   \   000326   78..         MOV     R0,#?V0
   \   000328   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00032B   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   00032E   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   000331   7405         MOV     A,#0x5
   \   000333   12....       LCALL   ?DEALLOC_XSTACK8
   3560          	return TRUE;
   \   000336                ; Setup parameters for call to function ZclWriteRspCmd::~ZclWriteRspCmd()
   \   000336   AA..         MOV     R2,?XSP + 0
   \   000338   AB..         MOV     R3,?XSP + 1
   \   00033A   12....       LCALL   `?~ZclWriteRspCmd?relay`; Banked call to: ZclWriteRspCmd::~ZclWriteRspCmd()
   \   00033D   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   00033F   741B         MOV     A,#0x1b
   \   000341   02....       LJMP    ??Subroutine169_0 & 0xFFFF
   3561          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000003   7E00         MOV     R6,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V6,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7407         MOV     A,#0x7
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006                REQUIRE ??Subroutine167_0
   \   000006                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E5..         MOV     A,?V0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   F8           MOV     R0,A
   \   00000A   85..82       MOV     DPL,?V12
   \   00000D   85..83       MOV     DPH,?V13
   \   000010   E0           MOVX    A,@DPTR
   \   000011   68           XRL     A,R0
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   00000A   7401         MOV     A,#0x1
   \   00000C   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     `?~BufferData?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    `?~BufferData`

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??isValid?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??isValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `?~ZclWriteRspCmd?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    `?~ZclWriteRspCmd`

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_HandleExternal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getParsedTransSeqNum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclCalcHdrSize?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclCalcHdrSize

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAnalogDataType?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_BuildAnalogData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ??zclProcessInWriteUndividedCmd
   3562          
   3563          #ifdef ZCL_DISCOVER
   3564          /*********************************************************************
   3565           * @fn      zclProcessInDiscAttrs
   3566           *
   3567           * @brief   Process the "Profile" Discover Attributes Commands
   3568           *
   3569           * @param   pInMsg - incoming message to process
   3570           *
   3571           * @return  TRUE if command processed. FALSE, otherwise.
   3572           */
   3573          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   3574          {
   3575            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3576            zclAttrRec_t attrRec;
   3577            uint16 attrID;
   3578            uint8 numAttrs;
   3579            uint8 i;
   3580          
   3581            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   3582          
   3583            // Find out the number of attributes supported within the specified range
   3584            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   3585            {
   3586              // finds the next attribute on this endpoint/cluster after the range.
   3587              // attributes must be in numerical order in the list.
   3588              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3589              {
   3590                break;
   3591              }
   3592            }
   3593          
   3594            numAttrs = i;  // store range of attributes in buffer
   3595          
   3596              // Process message for either attributes or extended attributes
   3597            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   3598            {
   3599              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   3600            }
   3601            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   3602            {
   3603              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   3604            }
   3605          
   3606            return TRUE;
   3607          }
   3608          
   3609          /*********************************************************************
   3610           * @fn      zclProcessInDiscAttrsCmd
   3611           *
   3612           * @brief   Process the Discover Attributes Command
   3613           *
   3614           * @param   pInMsg - incoming message to process
   3615           *
   3616           * @param   pDiscoverCmd - structure from requesting command
   3617           *
   3618           * @param   attrLenBuf - describes the amount of attributes to be processed
   3619           *
   3620           * @return  none
   3621           */
   3622          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   3623          {
   3624            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   3625            uint8 discComplete = TRUE;
   3626            zclAttrRec_t attrRec;
   3627            uint16 attrID;
   3628            uint8 i;
   3629          
   3630            // Allocate space for the response command
   3631            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   3632                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   3633            if ( pDiscoverRsp == NULL )
   3634            {
   3635              return; // EMBEDDED RETURN
   3636            }
   3637          
   3638            if ( numAttrs != 0 )
   3639            {
   3640              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   3641              {
   3642                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3643                {
   3644                  break; // should not happen, as numAttrs already calculated
   3645                }
   3646          
   3647                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   3648                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   3649              }
   3650          
   3651              // Are there more attributes to be discovered?
   3652              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3653              {
   3654                discComplete = FALSE;
   3655              }
   3656            }
   3657          
   3658            pDiscoverRsp->discComplete = discComplete;
   3659            pDiscoverRsp->numAttr = numAttrs;
   3660          
   3661            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3662                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   3663                                         true, pInMsg->hdr.transSeqNum );
   3664            zcl_mem_free( pDiscoverRsp );
   3665          
   3666            return;
   3667          }
   3668          
   3669          /*********************************************************************
   3670           * @fn      zclProcessInDiscAttrsExtCmd
   3671           *
   3672           * @brief   Process the Discover Attributes Extended Command
   3673           *
   3674           * @param   pInMsg - incoming message to process
   3675           *
   3676           * @param   pDiscoverCmd - structure from requesting command
   3677           *
   3678           * @param   attrLenBuf - describes the amount of attributes to be processed
   3679           *
   3680           * @return  none
   3681           */
   3682          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   3683          {
   3684            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   3685            uint8 discComplete = TRUE;
   3686            zclAttrRec_t attrRec;
   3687            uint16 attrID;
   3688            uint8 i;
   3689          
   3690              // Allocate space for the response command
   3691            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   3692                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   3693            if ( pDiscoverExtRsp == NULL )
   3694            {
   3695              return; // EMBEDDED RETURN
   3696            }
   3697          
   3698          
   3699            if ( numAttrs != 0 )
   3700            {
   3701              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   3702              {
   3703                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3704                {
   3705                  break; // Should not happen, as numAttrs already calculated
   3706                }
   3707          
   3708                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   3709                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   3710                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   3711              }
   3712          
   3713              // Are there more attributes to be discovered?
   3714              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3715              {
   3716                discComplete = FALSE;
   3717              }
   3718            }
   3719          
   3720            pDiscoverExtRsp->discComplete = discComplete;
   3721            pDiscoverExtRsp->numAttr = numAttrs;
   3722          
   3723            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3724                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   3725                                         true, pInMsg->hdr.transSeqNum );
   3726          
   3727            zcl_mem_free( pDiscoverExtRsp );
   3728          
   3729            return;
   3730          }
   3731          
   3732          /*********************************************************************
   3733           * @fn      zclProcessInDiscCmd
   3734           *
   3735           * @brief   Process the "Profile" Discover Command
   3736           *
   3737           * @param   pInMsg - incoming message to process
   3738           *
   3739           * @return  TRUE if command processed. FALSE, otherwise.
   3740           */
   3741          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3742          {
   3743            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   3744            zclDiscoverCmdsCmdRsp_t cmdRsp;
   3745            ZStatus_t status;
   3746            zclCommandRec_t cmdRec;
   3747            uint8 cmdID;
   3748            uint8 i;
   3749            uint8 j;
   3750          
   3751            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   3752          
   3753            // Find out the number of commands supported within the specified range
   3754            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   3755            {
   3756              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   3757              {
   3758                break;  // Command not supported
   3759              }
   3760            }
   3761          
   3762            // Allocate space for the response command
   3763            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   3764          
   3765            if ( cmdRsp.pCmdID == NULL )
   3766            {
   3767              return FALSE; // EMBEDDED RETURN
   3768            }
   3769          
   3770            if ( i != 0 )
   3771            {
   3772              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   3773              {
   3774                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   3775                {
   3776                  break; // Attribute not supported
   3777                }
   3778          
   3779                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   3780              }
   3781            }
   3782          
   3783            // Are there more commands to be discovered?
   3784            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   3785            {
   3786              cmdRsp.discComplete = FALSE;
   3787            }
   3788            else
   3789            {
   3790              cmdRsp.discComplete = TRUE;
   3791            }
   3792          
   3793            // pass the command requested
   3794            cmdRsp.cmdType = pInMsg->hdr.commandID;
   3795          
   3796            // store number of commands returned
   3797            cmdRsp.numCmd = j;
   3798          
   3799            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3800                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   3801                                                true, pInMsg->hdr.transSeqNum );
   3802          
   3803            zcl_mem_free( cmdRsp.pCmdID );
   3804          
   3805            if ( status == ZSuccess )
   3806            {
   3807              return TRUE;
   3808            }
   3809            else
   3810            {
   3811              return FALSE;
   3812            }
   3813          }
   3814          
   3815          #endif // ZCL_DISCOVER
   3816          
   3817          /*********************************************************************
   3818          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     18   BufferData::isValid()
      2     18   BufferData::~BufferData()
        2      0   -> operator delete(void *)
      2     51   ZclWriteRspCmd::~ZclWriteRspCmd()
        2      0   -> operator delete(void *)
      2     24   zclAnalogDataType
      1     42   zclBuildHdr(zclFrameHdr_t *, unsigned char *)
      2     30   zclCalcHdrSize(zclFrameHdr_t *)
      0     19   zclFindClusterOption(uint8, uint16)
      0     47   zclGetClusterOption(uint8, uint16)
        0     10   -> zclFindClusterOption(uint8, uint16)
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
      1     11   zclParseInConfigReportRspCmd(zclParseCmd_t *)
        0     11   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd(zclParseCmd_t *)
        0     10   -> osal_mem_alloc
      2      0   zclParseInReadCmd
        2      0   -> zclReadCmd_t::new zclReadCmd_t(zclParseCmd_t *)
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd(zclParseCmd_t *)
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
      1     25   zclParseInReadRspCmd(zclParseCmd_t *)
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      2      0   zclParseInWriteCmd
        2      0   -> ZclWriteCmd::new ZclWriteCmd(zclParseCmd_t *)
      2      0   zclParseInWriteRspCmd(zclParseCmd_t *)
        2      0   -> ZclWriteRspCmd::new ZclWriteRspCmd(zclParseCmd_t *)
      1     37   zclProcessInReadCmd(zclIncoming_t *)
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     37   -> zcl_SendReadRsp
      1     43   zclProcessInWriteCmd(zclIncoming_t *)
        0     38   -> ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
        0     38   -> ZclWriteRspCmd::~ZclWriteRspCmd()
        0     40   -> zclFindAttrRec
        0     40   -> zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
        0     43   -> zcl_SendWriteRsp
      1     56   zclProcessInWriteUndividedCmd(zclIncoming_t *)
        0     51   -> ZclWriteRspCmd::ZclWriteRspCmd(ZclWriteCmd *)
        0     51   -> ZclWriteRspCmd::~ZclWriteRspCmd()
        0     51   -> osal_mem_alloc
        0     51   -> osal_mem_free
        0     54   -> osal_memcpy
        0     53   -> zclFindAttrRec
        0     51   -> zclGetAttrDataLength
        0     53   -> zclReadAttrData
        0     53   -> zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
        0     56   -> zcl_SendWriteRsp
      0     71   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      1     66   zclSendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     30   -> zclBuildHdr(zclFrameHdr_t *, unsigned char *)
        0     30   -> zclCalcHdrSize(zclFrameHdr_t *)
        0     30   -> zclGetClusterOption(uint8, uint16)
        0     32   -> zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
      0     47   zclSetSecurityOption(uint8, uint16, uint8)
        0     10   -> zclFindClusterOption(uint8, uint16)
      0     71   zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      1     36   zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
        0     16   -> zclGetAttrDataLength
      0     64   zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
        0     25   -> zclFindAttrRec
        0     25   -> zclReadAttrData
      1     10   zcl_HandleExternal
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption(uint8, uint16)
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption(uint8, uint16, uint8)
        0     39   -> zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
        0     44   -> zcl_SendDefaultRspCmd
      0     26   zcl_ReadAttrData
        0     22   -> zclFindAttrRec
        0     22   -> zclReadAttrData
      1     74   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     33   -> zclBuildHdr(zclFrameHdr_t *, unsigned char *)
        0     30   -> zclCalcHdrSize(zclFrameHdr_t *)
        0     30   -> zclGetClusterOption(uint8, uint16)
        0     32   -> zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
      1     40   zcl_SendConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      0     32   zcl_SendRead
        0     18   -> BufferData::isValid()
        0     18   -> BufferData::~BufferData()
        0     18   -> zclReadCmd_t::getBufferFromAttribute()
        0     27   -> zclSendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     40   zcl_SendReadReportCfgRspCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     68   zcl_SendReadRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      0     33   zcl_SendWriteRequest
        0     18   -> BufferData::isValid()
        0     18   -> BufferData::~BufferData()
        0     18   -> ZclWriteCmd::getBufferFromAttribute()
        0     27   -> zclSendCommand
      0     83   zcl_SendWriteRsp
        0     18   -> BufferData::isValid()
        0     18   -> BufferData::~BufferData()
        0     18   -> ZclWriteRspCmd::getBufferData()
        0     27   -> zclSendCommand
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      2      0   zcl_registerForMsg
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       6  ??Subroutine133_0
       6  ??Subroutine134_0
       8  ??Subroutine135_0
      12  ??Subroutine136_0
      11  ??Subroutine137_0
       5  ??Subroutine138_0
       6  ??Subroutine139_0
       4  ??Subroutine140_0
      12  ??Subroutine141_0
       9  ??Subroutine142_0
       4  ??Subroutine143_0
       4  ??Subroutine144_0
       6  ??Subroutine145_0
       8  ??Subroutine146_0
       6  ??Subroutine147_0
       5  ??Subroutine148_0
       1  ??Subroutine149_0
       5  ??Subroutine150_0
       7  ??Subroutine151_0
       5  ??Subroutine152_0
       6  ??Subroutine153_0
       4  ??Subroutine154_0
       7  ??Subroutine155_0
      13  ??Subroutine156_0
       9  ??Subroutine157_0
       4  ??Subroutine158_0
       7  ??Subroutine159_0
       5  ??Subroutine160_0
       4  ??Subroutine161_0
       4  ??Subroutine162_0
       6  ??Subroutine163_0
       8  ??Subroutine164_0
       8  ??Subroutine165_0
       6  ??Subroutine166_0
      20  ??Subroutine167_0
       6  ??Subroutine168_0
       3  ??Subroutine169_0
       5  ??Subroutine170_0
       6  ??isValid?relay
       6  ??zclAnalogDataType?relay
       6  ??zclBuildHdr?relay
       6  ??zclCalcHdrSize?relay
       6  ??zclFindClusterOption?relay
       6  ??zclGetClusterOption?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInConfigReportCmd?relay
       6  ??zclParseInConfigReportRspCmd?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadReportCfgCmd?relay
       6  ??zclParseInReadReportCfgRspCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInReportCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclReadAttrData?relay
       6  ??zclSendCommand?relay
       6  ??zclSetSecurityOption?relay
       6  ??zclWriteAttrData?relay
       6  ??zcl_BuildAnalogData?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_HandleExternal?relay
       6  ??zcl_Init?relay
       6  ??zcl_ProcessMessageMSG?relay
       6  ??zcl_ReadAttrData?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendConfigReportCmd?relay
       6  ??zcl_SendConfigReportRspCmd?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadReportCfgCmd?relay
       6  ??zcl_SendReadReportCfgRspCmd?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendReportCmd?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getParsedTransSeqNum?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerValidateAttrData?relay
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
      13  ?Subroutine100
      15  ?Subroutine101
      12  ?Subroutine102
      10  ?Subroutine103
       9  ?Subroutine104
       9  ?Subroutine105
       3  ?Subroutine106
      11  ?Subroutine107
      11  ?Subroutine108
       7  ?Subroutine109
       5  ?Subroutine11
       6  ?Subroutine110
      12  ?Subroutine111
       6  ?Subroutine112
       8  ?Subroutine113
       8  ?Subroutine114
       3  ?Subroutine115
       4  ?Subroutine116
       7  ?Subroutine117
      11  ?Subroutine118
      10  ?Subroutine119
      37  ?Subroutine12
       1  ?Subroutine120
       4  ?Subroutine121
       6  ?Subroutine122
       5  ?Subroutine123
       5  ?Subroutine124
      16  ?Subroutine125
      16  ?Subroutine126
      12  ?Subroutine127
       3  ?Subroutine128
       8  ?Subroutine129
      12  ?Subroutine13
      13  ?Subroutine130
       6  ?Subroutine131
       8  ?Subroutine132
       8  ?Subroutine14
       6  ?Subroutine15
       4  ?Subroutine16
      22  ?Subroutine17
      19  ?Subroutine18
       8  ?Subroutine19
       3  ?Subroutine2
      15  ?Subroutine20
      20  ?Subroutine21
      15  ?Subroutine22
      13  ?Subroutine23
      14  ?Subroutine24
      15  ?Subroutine25
      10  ?Subroutine26
      10  ?Subroutine27
       3  ?Subroutine28
       9  ?Subroutine29
       2  ?Subroutine3
       7  ?Subroutine30
      19  ?Subroutine31
      14  ?Subroutine32
       1  ?Subroutine33
       7  ?Subroutine34
      14  ?Subroutine35
      10  ?Subroutine36
      10  ?Subroutine37
       1  ?Subroutine38
      11  ?Subroutine39
      11  ?Subroutine4
       5  ?Subroutine40
       6  ?Subroutine41
       6  ?Subroutine42
       5  ?Subroutine43
       9  ?Subroutine44
       6  ?Subroutine45
       2  ?Subroutine46
       3  ?Subroutine47
      24  ?Subroutine48
       2  ?Subroutine49
       4  ?Subroutine5
      18  ?Subroutine50
       6  ?Subroutine51
       9  ?Subroutine52
      10  ?Subroutine53
       9  ?Subroutine54
       4  ?Subroutine55
      20  ?Subroutine56
      23  ?Subroutine57
       6  ?Subroutine58
       6  ?Subroutine59
       5  ?Subroutine6
      11  ?Subroutine60
       1  ?Subroutine61
      11  ?Subroutine62
       6  ?Subroutine63
      22  ?Subroutine64
      15  ?Subroutine65
      15  ?Subroutine66
      22  ?Subroutine67
       8  ?Subroutine68
       8  ?Subroutine69
       5  ?Subroutine7
       1  ?Subroutine70
       6  ?Subroutine71
      14  ?Subroutine72
      13  ?Subroutine73
      12  ?Subroutine74
       9  ?Subroutine75
       5  ?Subroutine76
      10  ?Subroutine77
       6  ?Subroutine78
       4  ?Subroutine79
       4  ?Subroutine8
       8  ?Subroutine80
      12  ?Subroutine81
      11  ?Subroutine82
       8  ?Subroutine83
       9  ?Subroutine84
      15  ?Subroutine85
       2  ?Subroutine86
       6  ?Subroutine87
      16  ?Subroutine88
       4  ?Subroutine89
       5  ?Subroutine9
       6  ?Subroutine90
      13  ?Subroutine91
      12  ?Subroutine92
      13  ?Subroutine93
       4  ?Subroutine94
      13  ?Subroutine95
      22  ?Subroutine96
      13  ?Subroutine97
      10  ?Subroutine98
      12  ?Subroutine99
       6  ?~BufferData?relay
       6  ?~ZclWriteRspCmd?relay
      34  BufferData::isValid()
      25  BufferData::~BufferData()
      24  ZclWriteRspCmd::~ZclWriteRspCmd()
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
      85  zclBuildHdr(zclFrameHdr_t *, unsigned char *)
      17  zclCalcHdrSize(zclFrameHdr_t *)
      92  zclCmdTable
     103  zclFindClusterOption(uint8, uint16)
      30  zclGetClusterOption(uint8, uint16)
     199  zclParseHdr
     344  zclParseInConfigReportCmd
     122  zclParseInConfigReportRspCmd(zclParseCmd_t *)
      44  zclParseInDefaultRspCmd(zclParseCmd_t *)
      10  zclParseInReadCmd
      92  zclParseInReadReportCfgCmd
     345  zclParseInReadReportCfgRspCmd(zclParseCmd_t *)
     279  zclParseInReadRspCmd(zclParseCmd_t *)
     282  zclParseInReportCmd
      10  zclParseInWriteCmd
      10  zclParseInWriteRspCmd(zclParseCmd_t *)
     337  zclProcessInReadCmd(zclIncoming_t *)
     527  zclProcessInWriteCmd(zclIncoming_t *)
     836  zclProcessInWriteUndividedCmd(zclIncoming_t *)
      91  zclReadAttrData
     399  zclSendCommand
      45  zclSetSecurityOption(uint8, uint16, uint8)
     146  zclWriteAttrData(uint8, afAddrType_t *, zclAttrRec_t *, ZclWriteRec *)
     131  zcl_BuildAnalogData(uint8, unsigned char *, unsigned char *)
     123  zcl_DeviceOperational(uint8, uint16, uint8, uint8, uint16)
     171  zcl_HandleExternal
      12  zcl_Init
    1088  zcl_ProcessMessageMSG
      86  zcl_ReadAttrData
       1  zcl_RegisteredMsgTaskID
     388  zcl_SendCommand
     337  zcl_SendConfigReportCmd
     255  zcl_SendConfigReportRspCmd
     137  zcl_SendDefaultRspCmd
     140  zcl_SendRead
     221  zcl_SendReadReportCfgCmd
     378  zcl_SendReadReportCfgRspCmd
     318  zcl_SendReadRsp
     260  zcl_SendReportCmd
     146  zcl_SendWriteRequest
     140  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
      12  zcl_getParsedTransSeqNum
      13  zcl_getRawAFMsg
      85  zcl_registerClusterOptionList
      24  zcl_registerForMsg
      93  zcl_registerPlugin
      15  zcl_registerValidateAttrData

 
 10 650 bytes in segment BANKED_CODE
    300 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     12 bytes in segment XDATA_Z
 
 10 942 bytes of CODE  memory (+ 101 bytes shared)
     13 bytes of XDATA memory

Errors: none
Warnings: none
