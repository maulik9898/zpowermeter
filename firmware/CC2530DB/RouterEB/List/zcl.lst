###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             14/Oct/2015  08:15:16 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c                      #
#    Command line       =  -f C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\..\Tools\f8wRouter.cfg (-DCPU32MHZ  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wConfig.cfg (-DZIGBEEPRO    #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wZCL.cfg                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c -D SECURE=0 -D       #
#                          OSC32K_CRYSTAL_INSTALLED=FALSE -D HAL_KEY=FALSE    #
#                          -D HAL_BOARD_CC2530EB_REV17 -D TC_LINKKEY_JOIN -D  #
#                          NV_INIT -D xNV_RESTORE -D MULTICAST_ENABLED=FALSE  #
#                          -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D          #
#                          FEATURE_SYSTEM_STATS -lC                           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ -lA                     #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ --diag_suppress         #
#                          Pe001,Pa010 -o C:\Users\paolo\Documents\GitHub\zpo #
#                          wermeter\firmware\CC2530DB\RouterEB\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\ -I C:\Users\paolo\Documents\GitHub #
#                          \zpowermeter\firmware\CC2530DB\..\Source\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\ha\ -I                       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\zmain\ -I                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\target\CC2530EB\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\high_level\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\sing #
#                          le_chip\ -I C:\Users\paolo\Documents\GitHub\zpower #
#                          meter\firmware\CC2530DB\..\Components\mt\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\osal\include\ -I         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\saddr\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\sdata\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\af\ -I             #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\nwk\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sapi\ -I           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sec\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sys\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zcl\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zdo\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\ -I                 #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\f8w\ -Ohz           #
#                          --require_prototypes                               #
#    List file          =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\zcl.lst                  #
#    Object file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\Obj\zcl.r51                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\paolo\Documents\GitHub\zpowermeter\firmware\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2014-06-25 18:07:01 -0700 (Wed, 25 Jun 2014) $
      4            Revision:       $Revision: 39221 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          
     49          #if defined ( INTER_PAN )
     50            #include "stub_aps.h"
     51          #endif
     52          
     53          /*********************************************************************
     54           * MACROS
     55           */
     56          /*** Frame Control ***/
     57          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     58          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     59          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     60          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     61          
     62          /*** Attribute Access Control ***/
     63          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     64          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     65          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     66          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     67          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     68          
     69          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     70          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     71          
     72          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     73                                                  (zclHdr).fc.manuSpecific == 0          && \
     74                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     75          
     76          // Commands that have corresponding responses
     77          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     78                                                  (cmd) == ZCL_CMD_WRITE                  || \
     79                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     80                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     81                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     82                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     83                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Command record list
    104          typedef struct zclCmdRecsList
    105          {
    106            struct zclCmdRecsList *pNext;
    107            uint8                 endpoint;
    108            uint8                 numCommands;
    109            CONST zclCommandRec_t *pCmdRecs;
    110          } zclCmdRecsList_t;
    111          
    112          // Attribute record list item
    113          typedef struct zclAttrRecsList
    114          {
    115            struct zclAttrRecsList *next;
    116            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    117            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    118            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    119            CONST zclAttrRec_t     *attrs;        // attribute records
    120          } zclAttrRecsList;
    121          
    122          // Cluster option list item
    123          typedef struct zclClusterOptionList
    124          {
    125            struct zclClusterOptionList *next;
    126            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    127            uint8                       numOptions; // Number of the following records
    128            zclOptionRec_t              *options;   // option records
    129          } zclClusterOptionList;
    130          
    131          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    132          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    133          
    134          typedef struct
    135          {
    136            zclParseInProfileCmd_t   pfnParseInProfile;
    137            zclProcessInProfileCmd_t pfnProcessInProfile;
    138          } zclCmdItems_t;
    139          
    140          
    141          /*********************************************************************
    142           * GLOBAL VARIABLES
    143           */
    144          
    145          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    146            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    147          
    148            // The task Id of the Application where the unprocessed Foundation
    149            // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    150            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    151          #endif
    152          
    153          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    154          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    155          
    156          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    157          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    158          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    159          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    160          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    162          
    163          /*********************************************************************
    164           * EXTERNAL VARIABLES
    165           */
    166          
    167          /*********************************************************************
    168           * EXTERNAL FUNCTIONS
    169           */
    170          
    171          /*********************************************************************
    172           * LOCAL VARIABLES
    173           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    174          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    175          
    176          #if defined ( ZCL_DISCOVER )
    177            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    178          #endif
    179          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    180          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
   \                     attrList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    181          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          
    185          /*********************************************************************
    186           * LOCAL FUNCTIONS
    187           */
    188          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    189          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    190          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    191          
    192          #if defined ( ZCL_DISCOVER )
    193            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    194          #endif
    195          
    196          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    197          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    198          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    199          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    200          
    201          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    202          
    203          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    204          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    205          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    206          #endif // ZCL_READ || ZCL_WRITE
    207          
    208          #ifdef ZCL_READ
    209          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    210          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    211          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    212                                                   uint8 *pAttrData, uint16 *pDataLen );
    213          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    214          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    215          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    216          #endif // ZCL_READ
    217          
    218          #ifdef ZCL_WRITE
    219          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    220                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    221          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    222                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    223          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    224          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    225          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    226          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    227          #endif // ZCL_WRITE
    228          
    229          #ifdef ZCL_REPORT
    230          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    231          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    232          #endif // ZCL_REPORT
    233          
    234          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    235          
    236          #ifdef ZCL_DISCOVER
    237          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    238          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    239          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    240          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    241          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    242          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    243          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    244          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    245          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    246          #endif // ZCL_DISCOVER
    247          
    248          /*********************************************************************
    249           * Parse Profile Command Function Table
    250           */
    251          

   \                                 In  segment CODE_C, align 1
    252          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zcl_HandleExternal?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zcl_HandleExternal?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   ....         DW ??zclParseInConfigReportCmd?relay
   \   00001A   ....         DW ??zcl_HandleExternal?relay
   \   00001C   ....         DW ??zclParseInConfigReportRspCmd?relay
   \   00001E   ....         DW ??zcl_HandleExternal?relay
   \   000020   ....         DW ??zclParseInReadReportCfgCmd?relay
   \   000022   ....         DW ??zcl_HandleExternal?relay
   \   000024   ....         DW ??zclParseInReadReportCfgRspCmd?relay
   \   000026   ....         DW ??zcl_HandleExternal?relay
   \   000028   ....         DW ??zclParseInReportCmd?relay
   \   00002A   ....         DW ??zcl_HandleExternal?relay
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zcl_HandleExternal?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    253          {
    254          #ifdef ZCL_READ
    255            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    256            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    257          #else
    258            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    259            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    260          #endif // ZCL_READ
    261          
    262          #ifdef ZCL_WRITE
    263            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    264            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    265            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    266            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    267          #else
    268            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    269            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    270            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    271            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    272          #endif // ZCL_WRITE
    273          
    274          #ifdef ZCL_REPORT
    275            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    276            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    277            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    278            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    279            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    280          #else
    281            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    282            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    283            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    284            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    285            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    286          #endif // ZCL_REPORT
    287          
    288            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    289          
    290          #ifdef ZCL_DISCOVER
    291            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    292            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    293            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    294            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    295            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    296            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    297            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    298            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    299            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    300            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    301            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    302          #else
    303            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    304            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    305            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    306            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    307            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    308            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    309            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    310            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    311            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    312            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    313            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    314          #endif // ZCL_DISCOVER
    315          };
    316          
    317          /*********************************************************************
    318           * PUBLIC FUNCTIONS
    319           *********************************************************************/
    320          
    321          #if !defined ( ZCL_STANDALONE )
    322          /*********************************************************************
    323           * @fn          zcl_Init
    324           *
    325           * @brief       Initialization function for the zcl layer.
    326           *
    327           * @param       task_id - ZCL task id
    328           *
    329           * @return      none
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    332          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    333            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    334          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    335          #endif
    336          
    337          #if !defined ( ZCL_STANDALONE )
    338          /*********************************************************************
    339           * @fn          zcl_event_loop
    340           *
    341           * @brief       Event Loop Processor for zcl.
    342           *
    343           * @param       task_id - task id
    344           * @param       events - event bitmap
    345           *
    346           * @return      unprocessed events
    347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    348          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    349          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    350            uint8 *msgPtr;
    351          
    352            (void)task_id;  // Intentionally unreferenced parameter
    353          
    354            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    355            {
    356              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    357              while ( msgPtr != NULL )
    358              {
    359                uint8 dealloc = TRUE;
    360          
    361                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    362                {
    363                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??zcl_ProcessMessageMSG?relay; Banked call to: zcl_ProcessMessageMSG
    364                }
    365                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    366                {
    367                  // send it to another task to process.
    368                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    369                  dealloc = FALSE;
    370                }
    371          
    372                // Release the memory
    373                if ( dealloc )
    374                {
    375                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    376                }
    377          
    378                // Next
    379                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_msg_receive?relay; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    380              }
    381          
    382              // return unprocessed events
    383              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0
   \   00004F   E5..         MOV     A,?V1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    384            }
    385          
    386            // Discard unknown events
    387            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    388          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    389          #endif
    390          
    391          #if !defined ( ZCL_STANDALONE )
    392          /*********************************************************************
    393           * @fn      zcl_registerForMsg
    394           *
    395           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    396           *          messages that aren't processed to one task (if a task is
    397           *          registered).
    398           *
    399           * @param   taskId - task Id of the Application where commands will be sent to
    400           *
    401           * @return  TRUE if task registeration successful, FALSE otherwise
    402           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    403          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    404          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    405            // Allow only the first task
    406            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    407            {
    408              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    409          
    410              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    411            }
    412          
    413            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    414          }
    415          #endif
    416          
    417          #if !defined ( ZCL_STANDALONE )
    418          /*********************************************************************
    419           * @fn      zcl_HandleExternal
    420           *
    421           * @brief
    422           *
    423           * @param   pInMsg - incoming message to process
    424           *
    425           * @return  TRUE
    426           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    427          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    428          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    429            zclIncomingMsg_t *pCmd;
    430          
    431            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    432            {
    433              return ( TRUE );
    434            }
    435          
    436            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_msg_allocate?relay; Banked call to: osal_msg_allocate
    437            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   7003         JNZ     $+5
   \   00001E   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    438            {
    439              // fill in the message
    440              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   7434         MOV     A,#0x34
   \   000027   12....       LCALL   ??Subroutine178_0 & 0xFFFF
    441              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_311:
   \   00002A   A3           INC     DPTR
   \   00002B   EA           MOV     A,R2
   \   00002C   2402         ADD     A,#0x2
   \   00002E   FC           MOV     R4,A
   \   00002F   E4           CLR     A
   \   000030   3B           ADDC    A,R3
   \   000031   FD           MOV     R5,A
   \   000032   7406         MOV     A,#0x6
   \   000034   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    442              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000037   8E82         MOV     DPL,R6
   \   000039   8F83         MOV     DPH,R7
   \   00003B   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00003E   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_500:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   EC           MOV     A,R4
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   ED           MOV     A,R5
   \   000051   12....       LCALL   ?Subroutine31 & 0xFFFF
    443              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_26:
   \   000054   EA           MOV     A,R2
   \   000055   240A         ADD     A,#0xa
   \   000057   FC           MOV     R4,A
   \   000058   E4           CLR     A
   \   000059   3B           ADDC    A,R3
   \   00005A   FD           MOV     R5,A
   \   00005B   740C         MOV     A,#0xc
   \   00005D   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    444              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000060   8E82         MOV     DPL,R6
   \   000062   8F83         MOV     DPH,R7
   \   000064   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   000067   C8           XCH     A,R0
   \   000068   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00006B   38           ADDC    A,R0
   \   00006C   F583         MOV     DPH,A
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   C0E0         PUSH    A
   \   000071   EA           MOV     A,R2
   \   000072   2416         ADD     A,#0x16
   \   000074   F582         MOV     DPL,A
   \   000076   E4           CLR     A
   \   000077   3B           ADDC    A,R3
   \   000078   F583         MOV     DPH,A
   \   00007A   D0E0         POP     A
   \   00007C   F0           MOVX    @DPTR,A
    445              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00007D   EE           MOV     A,R6
   \   00007E   240C         ADD     A,#0xc
   \   000080   F8           MOV     R0,A
   \   000081   E4           CLR     A
   \   000082   3F           ADDC    A,R7
   \   000083   F9           MOV     R1,A
   \   000084   8882         MOV     DPL,R0
   \   000086   8983         MOV     DPH,R1
   \   000088   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_493:
   \   00008B   EA           MOV     A,R2
   \   00008C   2417         ADD     A,#0x17
   \   00008E   F582         MOV     DPL,A
   \   000090   E4           CLR     A
   \   000091   3B           ADDC    A,R3
   \   000092   F583         MOV     DPH,A
   \   000094   EC           MOV     A,R4
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   ED           MOV     A,R5
   \   000098   F0           MOVX    @DPTR,A
    446          
    447              // Application will free the attrCmd buffer
    448              pInMsg->attrCmd = NULL;
   \   000099   8882         MOV     DPL,R0
   \   00009B   8983         MOV     DPH,R1
   \   00009D   E4           CLR     A
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   F0           MOVX    @DPTR,A
    449          
    450              /* send message through task message */
    451              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   0000A1                ; Setup parameters for call to function osal_msg_send
   \   0000A1   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   F9           MOV     R1,A
   \   0000A6   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
    452            }
    453          
    454            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   0000A9   7901         MOV     R1,#0x1
   \   0000AB   02....       LJMP    ?Subroutine2 & 0xFFFF
    455          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_422:
   \   000003   F9           MOV     R1,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine163:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine165:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine155:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine212_0
   \   000001                ; // Fall through to label ??Subroutine212_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine212_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine213_0
   \   000001                ; // Fall through to label ??Subroutine213_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine213_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine214_0
   \   000002                ; // Fall through to label ??Subroutine214_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine214_0:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_513:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine217_0:
   \   000000   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_519:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET
    456          #endif
    457          
    458          
    459          /*********************************************************************
    460           * @fn          zcl_getRawAFMsg
    461           *
    462           * @brief       Call to get original unprocessed AF message
    463           *              (not parsed by ZCL).
    464           *
    465           *   NOTE:  This function can only be called during a ZCL callback function
    466           *          and the calling function must NOT change any data in the message.
    467           *
    468           * @param       none
    469           *
    470           * @return      pointer to original AF message, NULL if not processing
    471           *              AF message.
    472           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    473          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    474          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    475            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   00000A   80..         SJMP    ?Subroutine0
    476          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    477          
    478          /*********************************************************************
    479           * @fn          zcl_getParsedTransSeqNum
    480           *
    481           * @brief       Call to the get the transaction sequence number from 
    482           *              the incoming message.
    483           *
    484           *   NOTE:  This function can only be called during a ZCL callback function
    485           *          and the calling function must NOT change any data in the message.
    486           *
    487           * @param       none
    488           *
    489           * @return      transaction sequence number.
    490           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    491          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    492          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    493            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    494          }
    495          
    496          /*********************************************************************
    497           * @fn          zcl_registerPlugin
    498           *
    499           * @brief       Add a Cluster Library handler
    500           *
    501           * @param       startClusterID - starting cluster ID
    502           * @param       endClusterID - ending cluster ID
    503           * @param       pfnHdlr - function pointer to incoming message handler
    504           *
    505           * @return      ZSuccess if OK
    506           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    507          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    508                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    509          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    510            zclLibPlugin_t *pNewItem;
    511            zclLibPlugin_t *pLoop;
    512          
    513            // Fill in the new profile list
    514            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    515            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    516            {
    517              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8042         SJMP    ??CrossCallReturnLabel_40
    518            }
    519          
    520            // Fill in the plugin record.
    521            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine42 & 0xFFFF
    522            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_45:
   \   00002E   A3           INC     DPTR
   \   00002F   E5..         MOV     A,?V0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine26 & 0xFFFF
    523            pNewItem->endClusterID = endClusterID;
    524            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_20:
   \   000036   740C         MOV     A,#0xc
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   EA           MOV     A,R2
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   EB           MOV     A,R3
   \   000046   F0           MOVX    @DPTR,A
    525          
    526            // Find spot in list
    527            if (  plugins == NULL )
   \   000047   90....       MOV     DPTR,#plugins
   \   00004A   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   00004D   90....       MOV     DPTR,#plugins
   \   000050   6011         JZ      ??zcl_registerPlugin_1
    528            {
    529              plugins = pNewItem;
    530            }
    531            else
    532            {
    533              // Look for end of list
    534              pLoop = plugins;
   \   000052   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_514:
   \   000055   8003         SJMP    ??zcl_registerPlugin_2
    535              while ( pLoop->next != NULL )
    536              {
    537                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_3:
   \   000057   EA           MOV     A,R2
   \   000058   FC           MOV     R4,A
   \   000059   EB           MOV     A,R3
    538              }
   \                     ??zcl_registerPlugin_2:
   \   00005A   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_271:
   \   00005D   70F8         JNZ     ??zcl_registerPlugin_3
    539          
    540              // Put new item at end of list
    541              pLoop->next = pNewItem;
   \   00005F   8C82         MOV     DPL,R4
   \   000061   8D83         MOV     DPH,R5
    542            }
   \                     ??zcl_registerPlugin_1:
   \   000063   12....       LCALL   ?Subroutine39 & 0xFFFF
    543          
    544            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_40:
   \   000066   02....       LJMP    ?Subroutine1 & 0xFFFF
    545          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   E5..         MOV     A,?V1
   \   000002   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000005   EE           MOV     A,R6
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   EF           MOV     A,R7
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine167_0
   \   000005                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_240:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
    546          
    547          #ifdef ZCL_DISCOVER
    548          /*********************************************************************
    549           * @fn          zcl_registerCmdList
    550           *
    551           * @brief       Register a Command List with ZCL Foundation
    552           *
    553           * @param       endpoint - endpoint the attribute list belongs to
    554           * @param       newCmdList - array of command records
    555           *
    556           * @return      ZSuccess if OK
    557           */
    558          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    559          {
    560            zclCmdRecsList_t *pNewItem;
    561            zclCmdRecsList_t *pLoop;
    562          
    563            // Fill in the new profile list
    564            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    565            if ( pNewItem == NULL )
    566            {
    567              return (ZMemError);
    568            }
    569          
    570            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    571            pNewItem->endpoint = endpoint;
    572            pNewItem->numCommands = cmdListSize;
    573            pNewItem->pCmdRecs = newCmdList;
    574          
    575            // Find spot in list
    576            if ( gpCmdList == NULL )
    577            {
    578              gpCmdList = pNewItem;
    579            }
    580            else
    581            {
    582              // Look for end of list
    583              pLoop = gpCmdList;
    584              while ( pLoop->pNext != NULL )
    585              {
    586                pLoop = pLoop->pNext;
    587              }
    588          
    589              // Put new item at end of list
    590              pLoop->pNext = pNewItem;
    591            }
    592          
    593            return ( ZSuccess );
    594          }
    595          #endif  // ZCL_DISCOVER
    596          
    597          /*********************************************************************
    598           * @fn          zcl_registerAttrList
    599           *
    600           * @brief       Register an Attribute List with ZCL Foundation
    601           *
    602           * @param       endpoint - endpoint the attribute list belongs to
    603           * @param       numAttr - number of attributes in list
    604           * @param       newAttrList - array of Attribute records.
    605           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    606           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    607           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    608           *
    609           * @return      ZSuccess if OK
    610           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    611          ZStatus_t zcl_registerAttrList( uint8 endpoint, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    612          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EA           MOV     A,R2
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   FF           MOV     R7,A
    613            zclAttrRecsList *pNewItem;
    614            zclAttrRecsList *pLoop;
    615          
    616            // Fill in the new profile list
    617            pNewItem = zcl_mem_alloc( sizeof( zclAttrRecsList ) );
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A09         MOV     R2,#0x9
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   A8..         MOV     R0,?V2
   \   000018   A9..         MOV     R1,?V3
    618            if ( pNewItem == NULL )  {
   \   00001A   E8           MOV     A,R0
   \   00001B   49           ORL     A,R1
   \   00001C   7004         JNZ     ??zcl_registerAttrList_0
    619              return (ZMemError);
   \   00001E   7910         MOV     R1,#0x10
   \   000020   802E         SJMP    ??CrossCallReturnLabel_41
    620            }
    621          
    622            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_0:
   \   000022   12....       LCALL   ?Subroutine22 & 0xFFFF
    623            pNewItem->endpoint = endpoint;
    624            pNewItem->pfnReadWriteCB = NULL;
   \                     ??CrossCallReturnLabel_12:
   \   000025   E4           CLR     A
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   12....       LCALL   ?Subroutine31 & 0xFFFF
    625            pNewItem->attrs = newAttrList;
   \                     ??CrossCallReturnLabel_27:
   \   00002B   A3           INC     DPTR
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
    626          
    627            // Find spot in list
    628          	if ( attrList == NULL ){
   \   000031   90....       MOV     DPTR,#attrList
   \   000034   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000037   90....       MOV     DPTR,#attrList
   \   00003A   6011         JZ      ??zcl_registerAttrList_1
    629          		attrList = pNewItem;
    630           	}  else  {
    631              	// Look for end of list
    632              	pLoop = attrList;
   \   00003C   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_515:
   \   00003F   8003         SJMP    ??zcl_registerAttrList_2
    633              	while ( pLoop->next != NULL ){
    634          			pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_3:
   \   000041   EA           MOV     A,R2
   \   000042   FC           MOV     R4,A
   \   000043   EB           MOV     A,R3
    635              	}
   \                     ??zcl_registerAttrList_2:
   \   000044   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000047   70F8         JNZ     ??zcl_registerAttrList_3
    636          
    637              	// Put new item at end of list
    638              	pLoop->next = pNewItem;
   \   000049   8C82         MOV     DPL,R4
   \   00004B   8D83         MOV     DPH,R5
    639          	}
   \                     ??zcl_registerAttrList_1:
   \   00004D   12....       LCALL   ?Subroutine39 & 0xFFFF
    640          
    641          	return ( ZSuccess );
   \                     ??CrossCallReturnLabel_41:
   \   000050   02....       LJMP    ?Subroutine1 & 0xFFFF
    642          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00000A   A3           INC     DPTR
   \   00000B   E5..         MOV     A,?V0
   \   00000D   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   22           RET
    643          
    644          /*********************************************************************
    645           * @fn          zcl_registerClusterOptionList
    646           *
    647           * @brief       Register a Cluster Option List with ZCL Foundation
    648           *
    649           * @param       endpoint - endpoint the option list belongs to
    650           * @param       numOption - number of options in list
    651           * @param       optionList - array of cluster option records.
    652           *
    653           *              NOTE: This API should be called to enable 'Application
    654           *                    Link Key' security and/or 'APS ACK' for a specific
    655           *                    Cluster. The 'Application Link Key' is discarded
    656           *                    if security isn't enabled on the device.
    657           *                    The default behavior is 'Network Key' when security
    658           *                    is enabled and no 'APS ACK' for the ZCL messages.
    659           *
    660           * @return      ZSuccess if OK
    661           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    662          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    663          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    664            zclClusterOptionList *pNewItem;
    665            zclClusterOptionList *pLoop;
    666          
    667            // Fill in the new profile list
    668            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    669            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    670            {
    671              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8025         SJMP    ??CrossCallReturnLabel_42
    672            }
    673          
    674            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine22 & 0xFFFF
    675            pNewItem->endpoint = endpoint;
    676            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_13:
   \   000027   12....       LCALL   ?Subroutine26 & 0xFFFF
    677            pNewItem->options = optionList;
    678          
    679            // Find spot in list
    680            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_21:
   \   00002A   90....       MOV     DPTR,#clusterOptionList
   \   00002D   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   6011         JZ      ??zcl_registerClusterOptionList_1
    681            {
    682              clusterOptionList = pNewItem;
    683            }
    684            else
    685            {
    686              // Look for end of list
    687              pLoop = clusterOptionList;
   \   000035   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_516:
   \   000038   8003         SJMP    ??zcl_registerClusterOptionList_2
    688              while ( pLoop->next != NULL )
    689              {
    690                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_3:
   \   00003A   EA           MOV     A,R2
   \   00003B   FC           MOV     R4,A
   \   00003C   EB           MOV     A,R3
    691              }
   \                     ??zcl_registerClusterOptionList_2:
   \   00003D   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   000040   70F8         JNZ     ??zcl_registerClusterOptionList_3
    692          
    693              // Put new item at end of list
    694              pLoop->next = pNewItem;
   \   000042   8C82         MOV     DPL,R4
   \   000044   8D83         MOV     DPH,R5
    695            }
   \                     ??zcl_registerClusterOptionList_1:
   \   000046   12....       LCALL   ?Subroutine39 & 0xFFFF
    696          
    697            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_42:
   \   000049   02....       LJMP    ?Subroutine1 & 0xFFFF
    698          }
    699          
    700          /*********************************************************************
    701           * @fn          zcl_registerValidateAttrData
    702           *
    703           * @brief       Add a validation function for attribute data
    704           *
    705           * @param       pfnValidateAttrData - function pointer to validate routine
    706           *
    707           * @return      ZSuccess if OK
    708           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    709          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    710          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    711            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    712          
    713            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   02....       LJMP    ?Subroutine0 & 0xFFFF
    714          }
    715          
    716          /*********************************************************************
    717           * @fn          zcl_registerReadWriteCB
    718           *
    719           * @brief       Register the application's callback function to read/write
    720           *              attribute data, and authorize read/write operation.
    721           *
    722           *              Note: The pfnReadWriteCB callback function is only required
    723           *                    when the attribute data format is unknown to ZCL. The
    724           *                    callback function gets called when the pointer 'dataPtr'
    725           *                    to the attribute value is NULL in the attribute database
    726           *                    registered with the ZCL.
    727           *
    728           *              Note: The pfnAuthorizeCB callback function is only required
    729           *                    when the Read/Write operation on an attribute requires
    730           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    731           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    732           *
    733           * @param       endpoint - application's endpoint
    734           * @param       pfnReadWriteCB - function pointer to read/write routine
    735           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    736           *
    737           * @return      ZSuccess if successful. ZFailure, otherwise.
    738           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    739          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    740                                             zclAuthorizeCB_t pfnAuthorizeCB )
    741          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
    742            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000010   8A..         MOV     ?V4,R2
   \   000012   8B..         MOV     ?V5,R3
   \   000014   A8..         MOV     R0,?V4
   \   000016   A9..         MOV     R1,?V5
    743          
    744            if ( pRec != NULL )
   \   000018   E8           MOV     A,R0
   \   000019   49           ORL     A,R1
   \   00001A   601D         JZ      ??zcl_registerReadWriteCB_0
    745            {
    746              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00001C   8882         MOV     DPL,R0
   \   00001E   8983         MOV     DPH,R1
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   12....       LCALL   ?Subroutine42 & 0xFFFF
    747              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \                     ??CrossCallReturnLabel_46:
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   E5..         MOV     A,?V0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E5..         MOV     A,?V1
   \   000034   F0           MOVX    @DPTR,A
    748          
    749              return ( ZSuccess );
   \   000035   7900         MOV     R1,#0x0
   \   000037   8002         SJMP    ??zcl_registerReadWriteCB_1
    750            }
    751          
    752            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000039   7901         MOV     R1,#0x1
   \                     ??zcl_registerReadWriteCB_1:
   \   00003B   02....       LJMP    ?Subroutine3 & 0xFFFF
    753          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    754          
    755          /*********************************************************************
    756           * @fn      zcl_DeviceOperational
    757           *
    758           * @brief   Used to see whether or not the device can send or respond
    759           *          to application level commands.
    760           *
    761           * @param   srcEP - source endpoint
    762           * @param   clusterID - cluster ID
    763           * @param   frameType - command type
    764           * @param   cmd - command ID
    765           *
    766           * @return  TRUE if device is operational, FALSE otherwise
    767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    768          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    769                                              uint8 frameType, uint8 cmd, uint16 profileID )
    770          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FF           MOV     R7,A
    771            zclAttrRec_t attrRec;
    772            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7401         MOV     A,#0x1
   \   000016   F0           MOVX    @DPTR,A
    773          
    774            (void)profileID;  // Intentionally unreferenced parameter
    775          
    776            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    777            // cannot send or respond to application level commands, other than commands
    778            // to read or write attributes. Note that the Identify cluster cannot be
    779            // disabled, and remains functional regardless of this setting.
    780            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000017   EF           MOV     A,R7
   \   000018   7006         JNZ     ??zcl_DeviceOperational_0
   \   00001A   ED           MOV     A,R5
   \   00001B   C3           CLR     C
   \   00001C   9406         SUBB    A,#0x6
   \   00001E   4050         JC      ??zcl_DeviceOperational_1
    781            {
    782              return ( TRUE );
    783            }
    784          
    785            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_0:
   \   000020   7403         MOV     A,#0x3
   \   000022   6A           XRL     A,R2
   \   000023   4B           ORL     A,R3
   \   000024   604A         JZ      ??zcl_DeviceOperational_1
    786            {
    787              return ( TRUE );
    788            }
    789          
    790            // Is device enabled?
    791            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    792                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000026                ; Setup parameters for call to function zclFindAttrRec
   \   000026   7401         MOV     A,#0x1
   \   000028   12....       LCALL   ?XSTACK_DISP100_8
   \   00002B   88..         MOV     ?V2,R0
   \   00002D   89..         MOV     ?V3,R1
   \   00002F   78..         MOV     R0,#?V2
   \   000031   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000034   7C12         MOV     R4,#0x12
   \   000036   7D00         MOV     R5,#0x0
   \   000038   7A00         MOV     R2,#0x0
   \   00003A   7B00         MOV     R3,#0x0
   \   00003C   EE           MOV     A,R6
   \   00003D   F9           MOV     R1,A
   \   00003E   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?DEALLOC_XSTACK8
   \   000046   E9           MOV     A,R1
   \   000047   601C         JZ      ??zcl_DeviceOperational_2
    793            {
    794          #ifdef ZCL_READ
    795              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000049                ; Setup parameters for call to function zclReadAttrData
   \   000049   E4           CLR     A
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   F5..         MOV     ?V3,A
   \   00004E   78..         MOV     R0,#?V2
   \   000050   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000053   7403         MOV     A,#0x3
   \   000055   12....       LCALL   ?XSTACK_DISP102_8
   \   000058   7402         MOV     A,#0x2
   \   00005A   12....       LCALL   ?XSTACK_DISP101_8
   \   00005D   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   000060   7402         MOV     A,#0x2
   \   000062   12....       LCALL   ?DEALLOC_XSTACK8
    796          #endif
    797            }
    798          
    799            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_2:
   \   000065   85..82       MOV     DPL,?XSP + 0
   \   000068   85..83       MOV     DPH,?XSP + 1
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   6401         XRL     A,#0x1
   \   00006E   7004         JNZ     ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_1:
   \   000070   7901         MOV     R1,#0x1
   \   000072   8002         SJMP    ??zcl_DeviceOperational_4
   \                     ??zcl_DeviceOperational_3:
   \   000074   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_4:
   \   000076   740B         MOV     A,#0xb
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B                REQUIRE ?Subroutine1
   \   00007B                ; // Fall through to label ?Subroutine1
    800          }
    801          
    802          /*********************************************************************
    803           * @fn      zcl_SendCommand
    804           *
    805           * @brief   Used to send Profile and Cluster Specific Command messages.
    806           *
    807           *          NOTE: The calling application is responsible for incrementing
    808           *                the Sequence Number.
    809           *
    810           * @param   srcEp - source endpoint
    811           * @param   destAddr - destination address
    812           * @param   clusterID - cluster ID
    813           * @param   cmd - command ID
    814           * @param   specific - whether the command is Cluster Specific
    815           * @param   direction - client/server direction of the command
    816           * @param   disableDefaultRsp - disable Default Response command
    817           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    818           * @param   seqNumber - identification number for the transaction
    819           * @param   cmdFormatLen - length of the command to be sent
    820           * @param   cmdFormat - command to be sent
    821           *
    822           * @return  ZSuccess if OK
    823           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    824          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    825                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    826                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    827                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    828          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V2,R4
   \   000012   8D..         MOV     ?V3,R5
    829            endPointDesc_t *epDesc;
    830            zclFrameHdr_t hdr;
    831            uint8 *msgBuf;
    832            uint16 msgLen;
    833            uint8 *pBuf;
    834            uint8 options;
    835            ZStatus_t status;
    836          
    837            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    838            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    839            {
    840              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    841            }
    842          
    843          #if defined ( INTER_PAN )
    844            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    845            {
    846              options = AF_TX_OPTIONS_NONE;
    847            }
    848            else
    849          #endif
    850            {
    851              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V2
   \   000027   AB..         MOV     R3,?V3
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    852          
    853              // The cluster might not have been defined to use security but if this message
    854              // is in response to another message that was using APS security this message
    855              // will be sent with APS security
    856              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
    857              {
    858                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine180_0 & 0xFFFF
    859          
    860                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_322:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
    861                {
    862                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
    863                }
    864              }
    865            }
    866          
    867            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    868          
    869            // Not Profile wide command (like READ, WRITE)
    870            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000066   6015         JZ      ??zcl_SendCommand_3
    871            {
    872              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   4401         ORL     A,#0x1
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   8003         SJMP    ??zcl_SendCommand_4
    873            }
    874            else
    875            {
    876              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   54FC         ANL     A,#0xfc
    877            }
   \                     ??zcl_SendCommand_4:
   \   000080   12....       LCALL   ?Subroutine38 & 0xFFFF
    878          
    879            if ( ( epDesc->simpleDesc == NULL ) ||
    880                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    881                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_38:
   \   000083   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   000086   602B         JZ      ??zcl_SendCommand_5
   \   000088   741E         MOV     A,#0x1e
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   FE           MOV     R6,A
   \   00008F                ; Setup parameters for call to function zcl_DeviceOperational
   \   00008F   8882         MOV     DPL,R0
   \   000091   8983         MOV     DPH,R1
   \   000093   A3           INC     DPTR
   \   000094   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000097   EE           MOV     A,R6
   \   000098   FD           MOV     R5,A
   \   000099   7402         MOV     A,#0x2
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   5403         ANL     A,#0x3
   \   0000A1   FC           MOV     R4,A
   \   0000A2   AA..         MOV     R2,?V2
   \   0000A4   AB..         MOV     R3,?V3
   \   0000A6   A9..         MOV     R1,?V10
   \   0000A8   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B0   E9           MOV     A,R1
   \   0000B1   7005         JNZ     ??zcl_SendCommand_6
    882            {
    883              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000B3   7901         MOV     R1,#0x1
   \   0000B5   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    884            }
   \                     ??zcl_SendCommand_6:
   \   0000B8   7422         MOV     A,#0x22
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   12....       LCALL   ??Subroutine180_0 & 0xFFFF
    885          
    886            // Fill in the Maufacturer Code
    887            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_323:
   \   0000C0   6012         JZ      ??CrossCallReturnLabel_462
    888            {
    889              hdr.fc.manuSpecific = 1;
   \   0000C2   85..82       MOV     DPL,?XSP + 0
   \   0000C5   85..83       MOV     DPH,?XSP + 1
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   4404         ORL     A,#0x4
   \   0000CB   F0           MOVX    @DPTR,A
    890              hdr.manuCode = manuCode;
   \   0000CC   7402         MOV     A,#0x2
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   12....       LCALL   ??Subroutine206_0 & 0xFFFF
    891            }
    892          
    893            // Set the Command Direction
    894            if ( direction )
   \                     ??CrossCallReturnLabel_462:
   \   0000D4   7420         MOV     A,#0x20
   \   0000D6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D9   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   0000DC   6005         JZ      ??zcl_SendCommand_7
    895            {
    896              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000DE   E0           MOVX    A,@DPTR
   \   0000DF   4408         ORL     A,#0x8
   \   0000E1   8003         SJMP    ??zcl_SendCommand_8
    897            }
    898            else
    899            {
    900              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000E6   F0           MOVX    @DPTR,A
    901            }
    902          
    903            // Set the Disable Default Response field
    904            if ( disableDefaultRsp )
   \   0000E7   7421         MOV     A,#0x21
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   0000EF   6005         JZ      ??zcl_SendCommand_9
    905            {
    906              hdr.fc.disableDefaultRsp = 1;
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   4410         ORL     A,#0x10
   \   0000F4   8003         SJMP    ??zcl_SendCommand_10
    907            }
    908            else
    909            {
    910              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000F6   E0           MOVX    A,@DPTR
   \   0000F7   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000F9   F0           MOVX    @DPTR,A
    911            }
    912          
    913            // Fill in the Transaction Sequence Number
    914            hdr.transSeqNum = seqNum;
   \   0000FA   7424         MOV     A,#0x24
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   C0E0         PUSH    A
   \   000102   7404         MOV     A,#0x4
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   D0E0         POP     A
   \   000109   F0           MOVX    @DPTR,A
    915          
    916            // Fill in the command
    917            hdr.commandID = cmd;
   \   00010A   7405         MOV     A,#0x5
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   EE           MOV     A,R6
   \   000110   F0           MOVX    @DPTR,A
    918          
    919            // calculate the needed buffer size
    920            msgLen = zclCalcHdrSize( &hdr );
   \   000111   75..03       MOV     ?V0,#0x3
   \   000114   85..82       MOV     DPL,?XSP + 0
   \   000117   85..83       MOV     DPH,?XSP + 1
   \   00011A   E0           MOVX    A,@DPTR
   \   00011B   5404         ANL     A,#0x4
   \   00011D   6003         JZ      ??zcl_SendCommand_11
   \   00011F   75..05       MOV     ?V0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000122   7425         MOV     A,#0x25
   \   000124   12....       LCALL   ?XSTACK_DISP0_8
   \   000127   12....       LCALL   ?Subroutine108 & 0xFFFF
    921            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_178:
   \   00012A   E5..         MOV     A,?V0
   \   00012C   2E           ADD     A,R6
   \   00012D   F5..         MOV     ?V0,A
   \   00012F   E4           CLR     A
   \   000130   3F           ADDC    A,R7
   \   000131   F5..         MOV     ?V1,A
    922          
    923            // Allocate the buffer needed
    924            msgBuf = zcl_mem_alloc( msgLen );
   \   000133                ; Setup parameters for call to function osal_mem_alloc
   \   000133   AA..         MOV     R2,?V0
   \   000135   FB           MOV     R3,A
   \   000136   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000139   8A..         MOV     ?V8,R2
   \   00013B   8B..         MOV     ?V9,R3
    925            if ( msgBuf != NULL )
   \   00013D   EA           MOV     A,R2
   \   00013E   45..         ORL     A,?V9
   \   000140   6062         JZ      ??zcl_SendCommand_12
    926            {
    927              // Fill in the ZCL Header
    928              pBuf = zclBuildHdr( &hdr, msgBuf );
    929          
    930              // Fill in the command frame
    931              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000142                ; Setup parameters for call to function osal_memcpy
   \   000142   7427         MOV     A,#0x27
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00014D                ; Setup parameters for call to function zclBuildHdr
   \   00014D   AC..         MOV     R4,?V8
   \   00014F   AD..         MOV     R5,?V9
   \   000151   7403         MOV     A,#0x3
   \   000153   12....       LCALL   ?XSTACK_DISP101_8
   \   000156   12....       LCALL   ??zclBuildHdr?relay  ; Banked call to: zclBuildHdr
   \   000159   EE           MOV     A,R6
   \   00015A   FC           MOV     R4,A
   \   00015B   EF           MOV     A,R7
   \   00015C   FD           MOV     R5,A
   \   00015D   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000160   7403         MOV     A,#0x3
   \   000162   12....       LCALL   ?DEALLOC_XSTACK8
    932          
    933              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    934                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   000165                ; Setup parameters for call to function AF_DataRequest
   \   000165   75..1E       MOV     ?V4,#0x1e
   \   000168   78..         MOV     R0,#?V4
   \   00016A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016D   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000170   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000173   78..         MOV     R0,#?V4
   \   000175   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000178   78..         MOV     R0,#?V8
   \   00017A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017D   78..         MOV     R0,#?V0
   \   00017F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000182   78..         MOV     R0,#?V2
   \   000184   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000187   A9..         MOV     R1,?V7
   \   000189   AC..         MOV     R4,?V12
   \   00018B   AD..         MOV     R5,?V13
   \   00018D   AA..         MOV     R2,?V14
   \   00018F   AB..         MOV     R3,?V15
   \   000191   12....       LCALL   ??AF_DataRequest?relay; Banked call to: AF_DataRequest
   \   000194   7409         MOV     A,#0x9
   \   000196   12....       LCALL   ?DEALLOC_XSTACK8
   \   000199   E9           MOV     A,R1
   \   00019A   FE           MOV     R6,A
    935              zcl_mem_free ( msgBuf );
   \   00019B                ; Setup parameters for call to function osal_mem_free
   \   00019B   AA..         MOV     R2,?V8
   \   00019D   AB..         MOV     R3,?V9
   \   00019F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0001A2   8002         SJMP    ??zcl_SendCommand_13
    936            }
    937            else
    938            {
    939              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   0001A4   7E10         MOV     R6,#0x10
    940            }
    941          
    942            return ( status );
   \                     ??zcl_SendCommand_13:
   \   0001A6   EE           MOV     A,R6
   \   0001A7   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   0001A8   7406         MOV     A,#0x6
   \   0001AA   02....       LJMP    ?Subroutine4 & 0xFFFF
    943          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine158:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000003   75..00       MOV     ?V6,#0x0
   \   000006   78..         MOV     R0,#?V4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine206_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine210_0
   \   000003                ; // Fall through to label ??Subroutine210_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine210_0:
   \   000000   7F10         MOV     R7,#0x10
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_417:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET
    944          
    945          #ifdef ZCL_READ
    946          /*********************************************************************
    947           * @fn      zcl_SendRead
    948           *
    949           * @brief   Send a Read command
    950           *
    951           * @param   srcEP - Application's endpoint
    952           * @param   dstAddr - destination address
    953           * @param   clusterID - cluster ID
    954           * @param   readCmd - read command to be sent
    955           * @param   direction - direction of the command
    956           * @param   seqNum - transaction sequence number
    957           *
    958           * @return  ZSuccess if OK
    959           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    960          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    961                                  uint16 clusterID, zclReadCmd_t *readCmd,
    962                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    963          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine82 & 0xFFFF
    964            uint16 dataLen;
    965            uint8 *buf;
    966            uint8 *pBuf;
    967            ZStatus_t status;
    968          
    969            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_131:
   \   000017   E0           MOVX    A,@DPTR
   \   000018   25E0         ADD     A,0xE0 /* A   */
   \   00001A   F5..         MOV     ?V6,A
   \   00001C   E4           CLR     A
   \   00001D   33           RLC     A
   \   00001E   F5..         MOV     ?V7,A
    970          
    971            buf = zcl_mem_alloc( dataLen );
   \   000020                ; Setup parameters for call to function osal_mem_alloc
   \   000020   AA..         MOV     R2,?V6
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000026   8A..         MOV     ?V0,R2
   \   000028   8B..         MOV     ?V1,R3
    972            if ( buf != NULL )
   \   00002A   EA           MOV     A,R2
   \   00002B   45..         ORL     A,?V1
   \   00002D   7003         JNZ     $+5
   \   00002F   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
    973            {
    974              uint8 i;
    975          
    976              // Load the buffer - serially
    977              pBuf = buf;
   \   000032   A8..         MOV     R0,?V0
   \   000034   A9..         MOV     R1,?V1
    978              for (i = 0; i < readCmd->numAttr; i++)
   \   000036   75..00       MOV     ?V3,#0x0
   \   000039   801F         SJMP    ??zcl_SendRead_1
    979              {
    980                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   00003B   AA..         MOV     R2,?V3
   \   00003D   EA           MOV     A,R2
   \   00003E   2A           ADD     A,R2
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   33           RLC     A
   \   000042   FB           MOV     R3,A
   \   000043   E5..         MOV     A,?V4
   \   000045   2A           ADD     A,R2
   \   000046   F582         MOV     DPL,A
   \   000048   E5..         MOV     A,?V5
   \   00004A   3B           ADDC    A,R3
   \   00004B   F583         MOV     DPH,A
   \   00004D   A3           INC     DPTR
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ?Subroutine141 & 0xFFFF
    981                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_237:
   \   000055   12....       LCALL   ?Subroutine134 & 0xFFFF
    982              }
   \                     ??CrossCallReturnLabel_269:
   \   000058   05..         INC     ?V3
   \                     ??zcl_SendRead_1:
   \   00005A   85..82       MOV     DPL,?V4
   \   00005D   85..83       MOV     DPH,?V5
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   E5..         MOV     A,?V3
   \   000064   C3           CLR     C
   \   000065   9A           SUBB    A,R2
   \   000066   40D3         JC      ??zcl_SendRead_2
    983          
    984              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    985                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000068                ; Setup parameters for call to function zcl_SendCommand
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   78..         MOV     R0,#?V6
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741C         MOV     A,#0x1c
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   E4           CLR     A
   \   00007E   F5..         MOV     ?V4,A
   \   000080   F5..         MOV     ?V5,A
   \   000082   78..         MOV     R0,#?V4
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   741E         MOV     A,#0x1e
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000092   741E         MOV     A,#0x1e
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009D   75..00       MOV     ?V3,#0x0
   \   0000A0   78..         MOV     R0,#?V3
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A5   78..         MOV     R0,#?V3
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FC           MOV     R4,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FD           MOV     R5,A
   \   0000AE   AA..         MOV     R2,?V8
   \   0000B0   AB..         MOV     R3,?V9
   \   0000B2   A9..         MOV     R1,?V2
   \   0000B4   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B7   740B         MOV     A,#0xb
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FE           MOV     R6,A
    986              zcl_mem_free( buf );
   \   0000BE                ; Setup parameters for call to function osal_mem_free
   \   0000BE   AA..         MOV     R2,?V0
   \   0000C0   AB..         MOV     R3,?V1
   \   0000C2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C5   8002         SJMP    ??zcl_SendRead_3
    987            }
    988            else
    989            {
    990              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000C7   7E10         MOV     R6,#0x10
    991            }
    992          
    993            return ( status );
   \                     ??zcl_SendRead_3:
   \   0000C9   02....       LJMP    ?Subroutine10 & 0xFFFF
    994          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine166_0
   \   000005                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   08           INC     R0
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine168_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   F583         MOV     DPH,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   A882         MOV     R0,DPL
   \   000007   A983         MOV     R1,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine161:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET
    995          
    996          /*********************************************************************
    997           * @fn      zcl_SendReadRsp
    998           *
    999           * @brief   Send a Read Response command.
   1000           *
   1001           * @param   srcEP - Application's endpoint
   1002           * @param   dstAddr - destination address
   1003           * @param   clusterID - cluster ID
   1004           * @param   readRspCmd - read response command to be sent
   1005           * @param   direction - direction of the command
   1006           * @param   seqNum - transaction sequence number
   1007           *
   1008           * @return  ZSuccess if OK
   1009           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1010          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
   1011                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
   1012                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1013          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V3,R1
   \   00000C   8A..         MOV     ?V12,R2
   \   00000E   8B..         MOV     ?V13,R3
   \   000010   8C..         MOV     ?V6,R4
   \   000012   8D..         MOV     ?V7,R5
   1014            uint8 *buf;
   1015            uint16 len = 0;
   \   000014   7E00         MOV     R6,#0x0
   \   000016   7F00         MOV     R7,#0x0
   1016            ZStatus_t status;
   1017            uint8 i;
   1018          
   1019            // calculate the size of the command
   1020            for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   000018   8E..         MOV     ?V2,R6
   \   00001A   7418         MOV     A,#0x18
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_474:
   \   000022   8011         SJMP    ??zcl_SendReadRsp_0
   1021            {
   1022              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1023          
   1024              len += 2 + 1; // Attribute ID + Status
   1025          
   1026              if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1027              {
   1028                len++; // Attribute Data Type length
   1029          
   1030                // Attribute Data length
   1031                if ( statusRec->data != NULL )
   1032                {
   1033                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   1034                }
   1035                else
   1036                {
   1037                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000024                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000024   12....       LCALL   ?Subroutine87 & 0xFFFF
   1038                }
   \                     ??CrossCallReturnLabel_141:
   \   000027   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_2:
   \   00002A   8B..         MOV     ?V1,R3
   \   00002C   EE           MOV     A,R6
   \   00002D   2A           ADD     A,R2
   \   00002E   FE           MOV     R6,A
   \   00002F   EF           MOV     A,R7
   \   000030   35..         ADDC    A,?V1
   \   000032   FF           MOV     R7,A
   \                     ??zcl_SendReadRsp_3:
   \   000033   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000035   85..82       MOV     DPL,?V8
   \   000038   85..83       MOV     DPH,?V9
   \   00003B   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   00003E   5033         JNC     ??zcl_SendReadRsp_4
   \   000040   E5..         MOV     A,?V2
   \   000042   75F006       MOV     B,#0x6
   \   000045   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000048   2403         ADD     A,#0x3
   \   00004A   FE           MOV     R6,A
   \   00004B   E4           CLR     A
   \   00004C   3F           ADDC    A,R7
   \   00004D   FF           MOV     R7,A
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   70E0         JNZ     ??zcl_SendReadRsp_3
   \   000053   0E           INC     R6
   \   000054   EE           MOV     A,R6
   \   000055   7001         JNZ     ??zcl_SendReadRsp_5
   \   000057   0F           INC     R7
   \                     ??zcl_SendReadRsp_5:
   \   000058   8882         MOV     DPL,R0
   \   00005A   8983         MOV     DPH,R1
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000063   8882         MOV     DPL,R0
   \   000065   8983         MOV     DPH,R1
   \   000067   60BB         JZ      ??zcl_SendReadRsp_1
   \   000069                ; Setup parameters for call to function zclGetAttrDataLength
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F9           MOV     R1,A
   \   00006E   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000071   80B7         SJMP    ??zcl_SendReadRsp_2
   1039              }
   1040            }
   1041          
   1042            buf = zcl_mem_alloc( len );
   \                     ??zcl_SendReadRsp_4:
   \   000073                ; Setup parameters for call to function osal_mem_alloc
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00007A   8A..         MOV     ?V0,R2
   \   00007C   8B..         MOV     ?V1,R3
   \   00007E   8A..         MOV     ?V4,R2
   \   000080   8B..         MOV     ?V5,R3
   1043            if ( buf != NULL )
   \   000082   EA           MOV     A,R2
   \   000083   45..         ORL     A,?V5
   \   000085   7003         JNZ     $+5
   \   000087   02....       LJMP    ??zcl_SendReadRsp_6 & 0xFFFF
   1044            {
   1045              // Load the buffer - serially
   1046              uint8 *pBuf = buf;
   1047          
   1048              for ( i = 0; i < readRspCmd->numAttr; i++ )
   \   00008A   75..00       MOV     ?V2,#0x0
   \   00008D   8036         SJMP    ??zcl_SendReadRsp_7
   1049              {
   1050                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   1051          
   1052                *pBuf++ = LO_UINT16( statusRec->attrID );
   1053                *pBuf++ = HI_UINT16( statusRec->attrID );
   1054                *pBuf++ = statusRec->status;
   1055          
   1056                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   1057                {
   1058                  *pBuf++ = statusRec->dataType;
   1059          
   1060                  if ( statusRec->data != NULL )
   1061                  {
   1062                    // Copy attribute data to the buffer to be sent out
   1063                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   1064                  }
   1065                  else
   1066                  {
   1067                    uint16 dataLen;
   1068          
   1069                    // Read attribute data directly into the buffer to be sent out
   1070                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_8:
   \   00008F                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   00008F   A8..         MOV     R0,?XSP + 0
   \   000091   A9..         MOV     R1,?XSP + 1
   \   000093   88..         MOV     ?V10,R0
   \   000095   89..         MOV     ?V11,R1
   \   000097   78..         MOV     R0,#?V10
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   8A82         MOV     DPL,R2
   \   0000A3   8B83         MOV     DPH,R3
   \   0000A5   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   0000A8   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?DEALLOC_XSTACK8
   1071                    pBuf += dataLen;
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   1072                  }
   \                     ??CrossCallReturnLabel_404:
   \   0000B9   E5..         MOV     A,?V0
   \   0000BB   28           ADD     A,R0
   \   0000BC   F5..         MOV     ?V0,A
   \   0000BE   E5..         MOV     A,?V1
   \   0000C0   39           ADDC    A,R1
   \   0000C1   F5..         MOV     ?V1,A
   \                     ??zcl_SendReadRsp_9:
   \   0000C3   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_7:
   \   0000C5   85..82       MOV     DPL,?V8
   \   0000C8   85..83       MOV     DPH,?V9
   \   0000CB   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_454:
   \   0000CE   505B         JNC     ??zcl_SendReadRsp_10
   \   0000D0   E5..         MOV     A,?V2
   \   0000D2   75F006       MOV     B,#0x6
   \   0000D5   A4           MUL     AB
   \   0000D6   F8           MOV     R0,A
   \   0000D7   A9F0         MOV     R1,B
   \   0000D9   E5..         MOV     A,?V8
   \   0000DB   28           ADD     A,R0
   \   0000DC   F582         MOV     DPL,A
   \   0000DE   E5..         MOV     A,?V9
   \   0000E0   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   0000E3   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000E6   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0000E9   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   0000EC   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000EF   8882         MOV     DPL,R0
   \   0000F1   8983         MOV     DPH,R1
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   70CD         JNZ     ??zcl_SendReadRsp_9
   \   0000F6   EA           MOV     A,R2
   \   0000F7   2403         ADD     A,#0x3
   \   0000F9   08           INC     R0
   \   0000FA   E4           CLR     A
   \   0000FB   3B           ADDC    A,R3
   \   0000FC   F9           MOV     R1,A
   \   0000FD   8882         MOV     DPL,R0
   \   0000FF   8983         MOV     DPH,R1
   \   000101   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000104   12....       LCALL   ??Subroutine212_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_499:
   \   000107   8C82         MOV     DPL,R4
   \   000109   8D83         MOV     DPH,R5
   \   00010B   E582         MOV     A,DPL
   \   00010D   4583         ORL     A,DPH
   \   00010F   7003         JNZ     $+5
   \   000111   02....       LJMP    ??zcl_SendReadRsp_8 & 0xFFFF
   \   000114                ; Setup parameters for call to function zclSerializeData
   \   000114   AC..         MOV     R4,?V0
   \   000116   AD..         MOV     R5,?V1
   \   000118   AA82         MOV     R2,DPL
   \   00011A   AB83         MOV     R3,DPH
   \   00011C   8882         MOV     DPL,R0
   \   00011E   8983         MOV     DPH,R1
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000125   8A..         MOV     ?V0,R2
   \   000127   8B..         MOV     ?V1,R3
   \   000129   8098         SJMP    ??zcl_SendReadRsp_9
   1073                }
   1074              } // for loop
   1075          
   1076              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
   1077                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_10:
   \   00012B                ; Setup parameters for call to function zcl_SendCommand
   \   00012B   78..         MOV     R0,#?V4
   \   00012D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000130   8E..         MOV     ?V0,R6
   \   000132   8F..         MOV     ?V1,R7
   \   000134   78..         MOV     R0,#?V0
   \   000136   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000139   7420         MOV     A,#0x20
   \   00013B   12....       LCALL   ?XSTACK_DISP0_8
   \   00013E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000141   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000144   E4           CLR     A
   \   000145   F5..         MOV     ?V0,A
   \   000147   F5..         MOV     ?V1,A
   \   000149   78..         MOV     R0,#?V0
   \   00014B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00014E   7422         MOV     A,#0x22
   \   000150   12....       LCALL   ?XSTACK_DISP0_8
   \   000153   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   000156   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000159   7422         MOV     A,#0x22
   \   00015B   12....       LCALL   ?XSTACK_DISP0_8
   \   00015E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   000161   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000164   75..00       MOV     ?V0,#0x0
   \   000167   78..         MOV     R0,#?V0
   \   000169   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016C   75..01       MOV     ?V0,#0x1
   \   00016F   78..         MOV     R0,#?V0
   \   000171   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000174   AC..         MOV     R4,?V6
   \   000176   AD..         MOV     R5,?V7
   \   000178   AA..         MOV     R2,?V12
   \   00017A   AB..         MOV     R3,?V13
   \   00017C   A9..         MOV     R1,?V3
   \   00017E   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000181   740B         MOV     A,#0xb
   \   000183   12....       LCALL   ?DEALLOC_XSTACK8
   \   000186   E9           MOV     A,R1
   \   000187   FE           MOV     R6,A
   1078              zcl_mem_free( buf );
   \   000188                ; Setup parameters for call to function osal_mem_free
   \   000188   AA..         MOV     R2,?V4
   \   00018A   AB..         MOV     R3,?V5
   \   00018C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00018F   8002         SJMP    ??zcl_SendReadRsp_11
   1079            }
   1080            else
   1081            {
   1082              status = ZMemError;
   \                     ??zcl_SendReadRsp_6:
   \   000191   7E10         MOV     R6,#0x10
   1083            }
   1084          
   1085            return ( status );
   \                     ??zcl_SendReadRsp_11:
   \   000193   EE           MOV     A,R6
   \   000194   F9           MOV     R1,A
   \   000195   7402         MOV     A,#0x2
   \   000197                REQUIRE ?Subroutine11
   \   000197                ; // Fall through to label ?Subroutine11
   1086          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine199_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_510:
   \   000003   AA..         MOV     R2,?V6
   \   000005   AB..         MOV     R3,?V7
   \   000007   A9..         MOV     R1,?V3
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0
   \   000004   85..83       MOV     DPH,?V1
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   8582..       MOV     ?V0,DPL
   \   00000C   8583..       MOV     ?V1,DPH
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   00000E   EE           MOV     A,R6
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3B           ADDC    A,R3
   \   000006   F9           MOV     R1,A
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   7F0E         MOV     R7,#0xe
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   000003   AA82         MOV     R2,DPL
   \   000005   AB83         MOV     R3,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine205_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine207_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET
   1087          #endif // ZCL_READ
   1088          
   1089          #ifdef ZCL_WRITE
   1090          /*********************************************************************
   1091           * @fn      sendWriteRequest
   1092           *
   1093           * @brief   Send a Write command
   1094           *
   1095           * @param   dstAddr - destination address
   1096           * @param   clusterID - cluster ID
   1097           * @param   writeCmd - write command to be sent
   1098           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
   1099           * @param   direction - direction of the command
   1100           * @param   seqNum - transaction sequence number
   1101           *
   1102           * @return  ZSuccess if OK
   1103           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1104          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
   1105                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
   1106                                          uint8 disableDefaultRsp, uint8 seqNum )
   1107          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1108            uint8 *buf;
   1109            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1110            ZStatus_t status;
   1111            uint8 i;
   1112          
   1113            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   00001D   8009         SJMP    ??CrossCallReturnLabel_211
   1114            {
   1115              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   00001F   12....       LCALL   ?Subroutine78 & 0xFFFF
   1116          
   1117              dataLen += 2 + 1; // Attribute ID + Attribute Type
   1118          
   1119              // Attribute Data
   1120              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   1121            }
   \                     ??CrossCallReturnLabel_125:
   \   000022   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000025   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000028   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   00002B   40F2         JC      ??zcl_SendWriteRequest_0
   1122          
   1123            buf = zcl_mem_alloc( dataLen );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000034   8A..         MOV     ?V0,R2
   \   000036   8B..         MOV     ?V1,R3
   1124            if ( buf != NULL )
   \   000038   EA           MOV     A,R2
   \   000039   45..         ORL     A,?V1
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
   1125            {
   1126              // Load the buffer - serially
   1127              uint8 *pBuf = buf;
   \   000040   AC..         MOV     R4,?V0
   \   000042   AD..         MOV     R5,?V1
   1128              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   8010         SJMP    ??zcl_SendWriteRequest_2
   1129              {
   1130                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   000049   12....       LCALL   ?Subroutine13 & 0xFFFF
   1131          
   1132                *pBuf++ = LO_UINT16( statusRec->attrID );
   1133                *pBuf++ = HI_UINT16( statusRec->attrID );
   1134                *pBuf++ = statusRec->dataType;
   1135          
   1136                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   1137              }
   \                     ??CrossCallReturnLabel_0:
   \   00004C   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   00004F   8A..         MOV     ?V10,R2
   \   000051   8B..         MOV     ?V11,R3
   \   000053   AC..         MOV     R4,?V10
   \   000055   AD..         MOV     R5,?V11
   \   000057   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000059   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   00005C   40EB         JC      ??zcl_SendWriteRequest_3
   1138          
   1139              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
   1140                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00005E                ; Setup parameters for call to function zcl_SendCommand
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   8E..         MOV     ?V4,R6
   \   000065   8F..         MOV     ?V5,R7
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   741D         MOV     A,#0x1d
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   E4           CLR     A
   \   000078   F5..         MOV     ?V4,A
   \   00007A   F5..         MOV     ?V5,A
   \   00007C   78..         MOV     R0,#?V4
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   741F         MOV     A,#0x1f
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   741F         MOV     A,#0x1f
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000097   75..00       MOV     ?V2,#0x0
   \   00009A   78..         MOV     R0,#?V2
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009F   7420         MOV     A,#0x20
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   AC..         MOV     R4,?V6
   \   0000AC   AD..         MOV     R5,?V7
   \   0000AE   AA..         MOV     R2,?V8
   \   0000B0   AB..         MOV     R3,?V9
   \   0000B2   A9..         MOV     R1,?V3
   \   0000B4   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B7   740B         MOV     A,#0xb
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FE           MOV     R6,A
   1141              zcl_mem_free( buf );
   \   0000BE                ; Setup parameters for call to function osal_mem_free
   \   0000BE   AA..         MOV     R2,?V0
   \   0000C0   AB..         MOV     R3,?V1
   \   0000C2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C5   8002         SJMP    ??zcl_SendWriteRequest_4
   1142            }
   1143            else
   1144            {
   1145              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000C7   7E10         MOV     R6,#0x10
   1146            }
   1147          
   1148            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000C9   02....       LJMP    ?Subroutine10 & 0xFFFF
   1149          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   F8           MOV     R0,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V1
   \   000009   F9           MOV     R1,A
   \   00000A   EE           MOV     A,R6
   \   00000B   28           ADD     A,R0
   \   00000C   FE           MOV     R6,A
   \   00000D   EF           MOV     A,R7
   \   00000E   39           ADDC    A,R1
   \   00000F   FF           MOV     R7,A
   \   000010   05..         INC     ?V2
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   12....       LCALL   ?Subroutine158 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   E5..         MOV     A,?V2
   \   000002   75F005       MOV     B,#0x5
   \   000005   A4           MUL     AB
   \   000006   F8           MOV     R0,A
   \   000007   A9F0         MOV     R1,B
   \   000009   E5..         MOV     A,?V4
   \   00000B   28           ADD     A,R0
   \   00000C   F582         MOV     DPL,A
   \   00000E   E5..         MOV     A,?V5
   \   000010                REQUIRE ??Subroutine176_0
   \   000010                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000003   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   8882         MOV     DPL,R0
   \   00000C   8983         MOV     DPH,R1
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000012   E8           MOV     A,R0
   \   000013   2402         ADD     A,#0x2
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   39           ADDC    A,R1
   \   000018   FB           MOV     R3,A
   \   000019   8A..         MOV     ?V10,R2
   \   00001B   8B..         MOV     ?V11,R3
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000024                ; Setup parameters for call to function zclSerializeData
   \   000024                ; Setup parameters for call to function zclSerializeData
   \   000024   8882         MOV     DPL,R0
   \   000026   8983         MOV     DPH,R1
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   00002E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V10
   \   000008   85..83       MOV     DPH,?V11
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine159:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ?Subroutine159 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000003   0C           INC     R4
   \   000004   AD83         MOV     R5,DPH
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine203_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine205_0
   \   000006                ; // Fall through to label ??Subroutine205_0
   1150          
   1151          /*********************************************************************
   1152           * @fn      zcl_SendWriteRsp
   1153           *
   1154           * @brief   Send a Write Response command
   1155           *
   1156           * @param   dstAddr - destination address
   1157           * @param   clusterID - cluster ID
   1158           * @param   wrtieRspCmd - write response command to be sent
   1159           * @param   direction - direction of the command
   1160           * @param   seqNum - transaction sequence number
   1161           *
   1162           * @return  ZSuccess if OK
   1163           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1164          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1165                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1166                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1167          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine59 & 0xFFFF
   1168            uint16 dataLen;
   1169            uint8 *buf;
   1170            ZStatus_t status;
   1171          
   1172            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1173          
   1174            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_79:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1175            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1176            {
   1177              // Load the buffer - serially
   1178              uint8 i;
   1179              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1180              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_10
   1181              {
   1182                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_1:
   \   00002E   12....       LCALL   ?Subroutine36 & 0xFFFF
   1183                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1184                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1185              }
   \                     ??CrossCallReturnLabel_34:
   \   000031   5001         JNC     ??zcl_SendWriteRsp_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendWriteRsp_2:
   \   000034   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendWriteRsp_1
   1186          
   1187              // If there's only a single status record and its status field is set to
   1188              // SUCCESS then omit the attribute ID field.
   1189              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000044   7401         MOV     A,#0x1
   \   000046   6A           XRL     A,R2
   \   000047   700A         JNZ     ??zcl_SendWriteRsp_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   7006         JNZ     ??zcl_SendWriteRsp_3
   1190              {
   1191                dataLen = 1;
   \   00004D   75..01       MOV     ?V6,#0x1
   \   000050   75..00       MOV     ?V7,#0x0
   1192              }
   1193          
   1194              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1195                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   000053                ; Setup parameters for call to function zcl_SendCommand
   \   000053   78..         MOV     R0,#?V0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   78..         MOV     R0,#?V6
   \   00005A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005D   741C         MOV     A,#0x1c
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   E4           CLR     A
   \   000069   F5..         MOV     ?V4,A
   \   00006B   F5..         MOV     ?V5,A
   \   00006D   78..         MOV     R0,#?V4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741E         MOV     A,#0x1e
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   741E         MOV     A,#0x1e
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000088   75..00       MOV     ?V3,#0x0
   \   00008B   78..         MOV     R0,#?V3
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..04       MOV     ?V3,#0x4
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   EE           MOV     A,R6
   \   000099   FC           MOV     R4,A
   \   00009A   EF           MOV     A,R7
   \   00009B   FD           MOV     R5,A
   \   00009C   AA..         MOV     R2,?V8
   \   00009E   AB..         MOV     R3,?V9
   \   0000A0   A9..         MOV     R1,?V2
   \   0000A2   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000A5   740B         MOV     A,#0xb
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FE           MOV     R6,A
   1196              zcl_mem_free( buf );
   \   0000AC                ; Setup parameters for call to function osal_mem_free
   \   0000AC   AA..         MOV     R2,?V0
   \   0000AE   AB..         MOV     R3,?V1
   \   0000B0   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000B3   8002         SJMP    ??zcl_SendWriteRsp_4
   1197            }
   1198            else
   1199            {
   1200              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000B5   7E10         MOV     R6,#0x10
   1201            }
   1202          
   1203            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0000B7   02....       LJMP    ?Subroutine10 & 0xFFFF
   1204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   75F003       MOV     B,#0x3
   \   000007   A4           MUL     AB
   \   000008   F5..         MOV     ?V6,A
   \   00000A   E5F0         MOV     A,B
   \   00000C   F5..         MOV     ?V7,A
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E   AA..         MOV     R2,?V6
   \   000010   FB           MOV     R3,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   EC           MOV     A,R4
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   FA           MOV     R2,A
   \   000006   ABF0         MOV     R3,B
   \   000008   E5..         MOV     A,?V4
   \   00000A   2A           ADD     A,R2
   \   00000B   FA           MOV     R2,A
   \   00000C   E5..         MOV     A,?V5
   \   00000E   3B           ADDC    A,R3
   \   00000F   FB           MOV     R3,A
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000018   EA           MOV     A,R2
   \   000019   2402         ADD     A,#0x2
   \   00001B   FA           MOV     R2,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000007   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   00000A   0C           INC     R4
   \   00000B   22           RET
   1205          #endif // ZCL_WRITE
   1206          
   1207          #ifdef ZCL_REPORT
   1208          /*********************************************************************
   1209           * @fn      zcl_SendConfigReportCmd
   1210           *
   1211           * @brief   Send a Configure Reporting command
   1212           *
   1213           * @param   dstAddr - destination address
   1214           * @param   clusterID - cluster ID
   1215           * @param   cfgReportCmd - configure reporting command to be sent
   1216           * @param   direction - direction of the command
   1217           * @param   seqNum - transaction sequence number
   1218           *
   1219           * @return  ZSuccess if OK
   1220           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1221          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1222                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1223                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1224          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1225            uint8 *buf;
   1226            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1227            ZStatus_t status;
   1228            uint8 i;
   1229          
   1230            // Find out the data length
   1231            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_475:
   \   00001D   8009         SJMP    ??zcl_SendConfigReportCmd_0
   1232            {
   1233              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1234          
   1235              dataLen += 1 + 2; // Direction + Attribute ID
   1236          
   1237              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1238              {
   1239                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1240          
   1241                // Find out the size of the Reportable Change field (for Analog data types)
   1242                if ( zclAnalogDataType( reportRec->dataType ) )
   1243                {
   1244                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1245                }
   1246              }
   1247              else
   1248              {
   1249                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1250              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   000028   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   00002B   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00C       MOV     B,#0xc
   \   000032   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   00003F   EE           MOV     A,R6
   \   000040   2405         ADD     A,#0x5
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E582         MOV     A,DPL
   \   000048   2403         ADD     A,#0x3
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   E4           CLR     A
   \   00004D   3583         ADDC    A,DPH
   \   00004F   F5..         MOV     ?V3,A
   \   000051                ; Setup parameters for call to function zclAnalogDataType
   \   000051   85..82       MOV     DPL,?V2
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005B   E9           MOV     A,R1
   \   00005C   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   00005E                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005E   85..82       MOV     DPL,?V2
   \   000061   85..83       MOV     DPH,?V3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000069   EE           MOV     A,R6
   \   00006A   29           ADD     A,R1
   \   00006B   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1251            }
   1252          
   1253            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   00006D                ; Setup parameters for call to function osal_mem_alloc
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000074   8A..         MOV     ?V2,R2
   \   000076   8B..         MOV     ?V3,R3
   1254            if ( buf != NULL )
   \   000078   EA           MOV     A,R2
   \   000079   45..         ORL     A,?V3
   \   00007B   7003         JNZ     $+5
   \   00007D   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1255            {
   1256              // Load the buffer - serially
   1257              uint8 *pBuf = buf;
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   1258          
   1259              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000084   75..00       MOV     ?V0,#0x0
   \   000087   8009         SJMP    ??zcl_SendConfigReportCmd_6
   1260              {
   1261                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1262          
   1263                *pBuf++ = reportRec->direction;
   1264                *pBuf++ = LO_UINT16( reportRec->attrID );
   1265                *pBuf++ = HI_UINT16( reportRec->attrID );
   1266          
   1267                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1268                {
   1269                  *pBuf++ = reportRec->dataType;
   1270                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1271                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1272                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1273                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1274          
   1275                  if ( zclAnalogDataType( reportRec->dataType ) )
   1276                  {
   1277                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1278                  }
   1279                }
   1280                else
   1281                {
   1282                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   000089   E5..         MOV     A,?V4
   \   00008B   2408         ADD     A,#0x8
   \   00008D   12....       LCALL   ?Subroutine23 & 0xFFFF
   1283                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1284                }
   \                     ??CrossCallReturnLabel_14:
   \   000090   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   000092   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000095   5054         JNC     ??zcl_SendConfigReportCmd_8
   \   000097   E5..         MOV     A,?V0
   \   000099   75F00C       MOV     B,#0xc
   \   00009C   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00009F   A882         MOV     R0,DPL
   \   0000A1   A983         MOV     R1,DPH
   \   0000A3   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000A6   A3           INC     DPTR
   \   0000A7   A882         MOV     R0,DPL
   \   0000A9   A983         MOV     R1,DPH
   \   0000AB   85..82       MOV     DPL,?V4
   \   0000AE   85..83       MOV     DPH,?V5
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   70D5         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000B4   E5..         MOV     A,?V4
   \   0000B6   2403         ADD     A,#0x3
   \   0000B8   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   0000BB   2404         ADD     A,#0x4
   \   0000BD   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000C0   2406         ADD     A,#0x6
   \   0000C2   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000C5   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000C8   E9           MOV     A,R1
   \   0000C9   60C5         JZ      ??CrossCallReturnLabel_14
   \   0000CB                ; Setup parameters for call to function zclSerializeData
   \   0000CB   AC..         MOV     R4,?V6
   \   0000CD   AD..         MOV     R5,?V7
   \   0000CF   85..82       MOV     DPL,?V4
   \   0000D2   85..83       MOV     DPH,?V5
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   12....       LCALL   ?Subroutine79 & 0xFFFF
   1285              } // for loop
   \                     ??CrossCallReturnLabel_127:
   \   0000E2   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000E5   8A..         MOV     ?V6,R2
   \   0000E7   8B..         MOV     ?V7,R3
   \   0000E9   80A5         SJMP    ??CrossCallReturnLabel_14
   1286          
   1287              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1288                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_8:
   \   0000EB                ; Setup parameters for call to function zcl_SendCommand
   \   0000EB   78..         MOV     R0,#?V2
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   8E..         MOV     ?V4,R6
   \   0000F2   8F..         MOV     ?V5,R7
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   7420         MOV     A,#0x20
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000104   E4           CLR     A
   \   000105   F5..         MOV     ?V4,A
   \   000107   F5..         MOV     ?V5,A
   \   000109   78..         MOV     R0,#?V4
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   7422         MOV     A,#0x22
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000119   7422         MOV     A,#0x22
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000121   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000124   75..00       MOV     ?V0,#0x0
   \   000127   78..         MOV     R0,#?V0
   \   000129   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012C   75..06       MOV     ?V0,#0x6
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000134   AC..         MOV     R4,?V12
   \   000136   AD..         MOV     R5,?V13
   \   000138   AA..         MOV     R2,?V14
   \   00013A   AB..         MOV     R3,?V15
   \   00013C   A9..         MOV     R1,?V1
   \   00013E   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000141   740B         MOV     A,#0xb
   \   000143   12....       LCALL   ?DEALLOC_XSTACK8
   \   000146   E9           MOV     A,R1
   \   000147   FE           MOV     R6,A
   1289              zcl_mem_free( buf );
   \   000148                ; Setup parameters for call to function osal_mem_free
   \   000148   AA..         MOV     R2,?V2
   \   00014A   AB..         MOV     R3,?V3
   \   00014C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00014F   8002         SJMP    ??zcl_SendConfigReportCmd_9
   1290            }
   1291            else
   1292            {
   1293              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   000151   7E10         MOV     R6,#0x10
   1294            }
   1295          
   1296            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   000153                REQUIRE ?Subroutine12
   \   000153                ; // Fall through to label ?Subroutine12
   1297          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine210_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine169_0
   \   000006                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000003                REQUIRE ??Subroutine173_0
   \   000003                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   F5..         MOV     ?V10,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V5
   \   000005   F5..         MOV     ?V11,A
   \   000007   85..82       MOV     DPL,?V10
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00000F   88..         MOV     ?V6,R0
   \   000011   89..         MOV     ?V7,R1
   \   000013   E5..         MOV     A,?V4
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   00000C   85..82       MOV     DPL,?V4
   \   00000F   85..83       MOV     DPH,?V5
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   FA           MOV     R2,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   FB           MOV     R3,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   000014   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine164:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   E5..         MOV     A,?V4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine174_0
   \   000009                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine157 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine157:
   \   000000   12....       LCALL   ?Subroutine164 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   000003                REQUIRE ??Subroutine175_0
   \   000003                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   8582..       MOV     ?V6,DPL
   \   000005   8583..       MOV     ?V7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003   85..82       MOV     DPL,?V10
   \   000006   85..83       MOV     DPH,?V11
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B                REQUIRE ??Subroutine201_0
   \   00000B                ; // Fall through to label ??Subroutine201_0
   1298          
   1299          /*********************************************************************
   1300           * @fn      zcl_SendConfigReportRspCmd
   1301           *
   1302           * @brief   Send a Configure Reporting Response command
   1303           *
   1304           * @param   dstAddr - destination address
   1305           * @param   clusterID - cluster ID
   1306           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1307           * @param   direction - direction of the command
   1308           * @param   seqNum - transaction sequence number
   1309           *
   1310           * @return  ZSuccess if OK
   1311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1312          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1313                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1314                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1315          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine82 & 0xFFFF
   1316            uint16 dataLen;
   1317            uint8 *buf;
   1318            ZStatus_t status;
   1319          
   1320            // Atrribute list (Status, Direction and Attribute ID)
   1321            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_132:
   \   000017   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   85....       MOV     ?V6,?V0
   \   000020   85....       MOV     ?V7,?V1
   1322          
   1323            buf = zcl_mem_alloc( dataLen );
   \   000023                ; Setup parameters for call to function osal_mem_alloc
   \   000023   AA..         MOV     R2,?V6
   \   000025   AB..         MOV     R3,?V7
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   1324            if ( buf != NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1325            {
   1326              // Load the buffer - serially
   1327              uint8 *pBuf = buf;
   1328              uint8 i;
   1329          
   1330              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000036   7C00         MOV     R4,#0x0
   \   000038   8041         SJMP    ??zcl_SendConfigReportRspCmd_1
   1331              {
   1332                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   00003A   8C..         MOV     ?V10,R4
   \   00003C   75..00       MOV     ?V11,#0x0
   \   00003F   7402         MOV     A,#0x2
   \   000041   78..         MOV     R0,#?V10
   \   000043   12....       LCALL   ?S_SHL
   \   000046   E5..         MOV     A,?V4
   \   000048   25..         ADD     A,?V10
   \   00004A   F8           MOV     R0,A
   \   00004B   E5..         MOV     A,?V5
   \   00004D   35..         ADDC    A,?V11
   \   00004F   F9           MOV     R1,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000058   A3           INC     DPTR
   \   000059   AA82         MOV     R2,DPL
   \   00005B   AB83         MOV     R3,DPH
   1333                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   00005D   8882         MOV     DPL,R0
   \   00005F   8983         MOV     DPH,R1
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine30 & 0xFFFF
   1334                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_289:
   \   000065   E8           MOV     A,R0
   \   000066   2403         ADD     A,#0x3
   \   000068   F8           MOV     R0,A
   \   000069   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   00006B   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00006C   8882         MOV     DPL,R0
   \   00006E   8983         MOV     DPH,R1
   \   000070   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   1335                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_288:
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   12....       LCALL   ?Subroutine30 & 0xFFFF
   1336              }
   \                     ??CrossCallReturnLabel_290:
   \   00007A   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007B   85..82       MOV     DPL,?V4
   \   00007E   85..83       MOV     DPH,?V5
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F8           MOV     R0,A
   \   000083   EC           MOV     A,R4
   \   000084   C3           CLR     C
   \   000085   98           SUBB    A,R0
   \   000086   40B2         JC      ??zcl_SendConfigReportRspCmd_2
   1337          
   1338              // If there's only a single status record and its status field is set to
   1339              // SUCCESS then omit the attribute ID field.
   1340              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000088   7401         MOV     A,#0x1
   \   00008A   68           XRL     A,R0
   \   00008B   700A         JNZ     ??zcl_SendConfigReportRspCmd_4
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   7006         JNZ     ??zcl_SendConfigReportRspCmd_4
   1341              {
   1342                dataLen = 1;
   \   000091   75..01       MOV     ?V6,#0x1
   \   000094   75..00       MOV     ?V7,#0x0
   1343              }
   1344          
   1345              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1346                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1347                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   78..         MOV     R0,#?V6
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   741C         MOV     A,#0x1c
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AC   E4           CLR     A
   \   0000AD   F5..         MOV     ?V4,A
   \   0000AF   F5..         MOV     ?V5,A
   \   0000B1   78..         MOV     R0,#?V4
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   741E         MOV     A,#0x1e
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   741E         MOV     A,#0x1e
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CC   75..00       MOV     ?V3,#0x0
   \   0000CF   78..         MOV     R0,#?V3
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   75..07       MOV     ?V3,#0x7
   \   0000D7   78..         MOV     R0,#?V3
   \   0000D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DC   EE           MOV     A,R6
   \   0000DD   FC           MOV     R4,A
   \   0000DE   EF           MOV     A,R7
   \   0000DF   FD           MOV     R5,A
   \   0000E0   AA..         MOV     R2,?V8
   \   0000E2   AB..         MOV     R3,?V9
   \   0000E4   A9..         MOV     R1,?V2
   \   0000E6   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000E9   740B         MOV     A,#0xb
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EE   E9           MOV     A,R1
   \   0000EF   FE           MOV     R6,A
   1348              zcl_mem_free( buf );
   \   0000F0                ; Setup parameters for call to function osal_mem_free
   \   0000F0   AA..         MOV     R2,?V0
   \   0000F2   AB..         MOV     R3,?V1
   \   0000F4   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000F7   8002         SJMP    ??zcl_SendConfigReportRspCmd_5
   1349            }
   1350            else
   1351            {
   1352              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F9   7E10         MOV     R6,#0x10
   1353            }
   1354          
   1355            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   0000FB                REQUIRE ?Subroutine10
   \   0000FB                ; // Fall through to label ?Subroutine10
   1356          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine170_0
   \   000001                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine171_0
   \   000001                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine172_0
   \   000004                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   0A           INC     R2
   \   000003   AB83         MOV     R3,DPH
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   75..00       MOV     ?V1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET
   1357          
   1358          /*********************************************************************
   1359           * @fn      zcl_SendReadReportCfgCmd
   1360           *
   1361           * @brief   Send a Read Reporting Configuration command
   1362           *
   1363           * @param   dstAddr - destination address
   1364           * @param   clusterID - cluster ID
   1365           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1366           * @param   direction - direction of the command
   1367           * @param   seqNum - transaction sequence number
   1368           *
   1369           * @return  ZSuccess if OK
   1370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1371          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1372                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1373                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1374          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine59 & 0xFFFF
   1375            uint16 dataLen;
   1376            uint8 *buf;
   1377            ZStatus_t status;
   1378          
   1379            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1380          
   1381            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_80:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1382            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
   1383            {
   1384              // Load the buffer - serially
   1385              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1386              uint8 i;
   1387          
   1388              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_11
   1389              {
   1390                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   00002E   12....       LCALL   ?Subroutine36 & 0xFFFF
   1391                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1392                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1393              }
   \                     ??CrossCallReturnLabel_35:
   \   000031   5001         JNC     ??zcl_SendReadReportCfgCmd_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000034   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendReadReportCfgCmd_1
   1394          
   1395              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1396                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000044                ; Setup parameters for call to function zcl_SendCommand
   \   000044   78..         MOV     R0,#?V0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   78..         MOV     R0,#?V6
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741C         MOV     A,#0x1c
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   E4           CLR     A
   \   00005A   F5..         MOV     ?V4,A
   \   00005C   F5..         MOV     ?V5,A
   \   00005E   78..         MOV     R0,#?V4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   741E         MOV     A,#0x1e
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   741E         MOV     A,#0x1e
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000079   75..00       MOV     ?V3,#0x0
   \   00007C   78..         MOV     R0,#?V3
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000081   75..08       MOV     ?V3,#0x8
   \   000084   78..         MOV     R0,#?V3
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000089   EE           MOV     A,R6
   \   00008A   FC           MOV     R4,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FD           MOV     R5,A
   \   00008D   AA..         MOV     R2,?V8
   \   00008F   AB..         MOV     R3,?V9
   \   000091   A9..         MOV     R1,?V2
   \   000093   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000096   740B         MOV     A,#0xb
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009B   E9           MOV     A,R1
   \   00009C   FE           MOV     R6,A
   1397              zcl_mem_free( buf );
   \   00009D                ; Setup parameters for call to function osal_mem_free
   \   00009D   AA..         MOV     R2,?V0
   \   00009F   AB..         MOV     R3,?V1
   \   0000A1   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000A4   8002         SJMP    ??zcl_SendReadReportCfgCmd_3
   1398            }
   1399            else
   1400            {
   1401              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   0000A6   7E10         MOV     R6,#0x10
   1402            }
   1403          
   1404            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   0000A8   02....       LJMP    ?Subroutine10 & 0xFFFF
   1405          }
   1406          
   1407          /*********************************************************************
   1408           * @fn      zcl_SendReadReportCfgRspCmd
   1409           *
   1410           * @brief   Send a Read Reporting Configuration Response command
   1411           *
   1412           * @param   dstAddr - destination address
   1413           * @param   clusterID - cluster ID
   1414           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1415           * @param   direction - direction of the command
   1416           * @param   seqNum - transaction sequence number
   1417           *
   1418           * @return  ZSuccess if OK
   1419           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1420          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1421                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1422                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1423          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1424            uint8 *buf;
   1425            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1426            ZStatus_t status;
   1427            uint8 i;
   1428          
   1429            // Find out the data length
   1430            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   00001D   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1431            {
   1432              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1433          
   1434              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1435          
   1436              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1437              {
   1438                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1439                {
   1440                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1441          
   1442                  // Find out the size of the Reportable Change field (for Analog data types)
   1443                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1444                  {
   1445                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1446                  }
   1447                }
   1448                else
   1449                {
   1450                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1451                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   000028   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   00002B   5041         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00D       MOV     B,#0xd
   \   000032   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000035   2404         ADD     A,#0x4
   \   000037   FE           MOV     R6,A
   \   000038   E4           CLR     A
   \   000039   3F           ADDC    A,R7
   \   00003A   FF           MOV     R7,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   70E8         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   000042   EE           MOV     A,R6
   \   000043   2405         ADD     A,#0x5
   \   000045   FE           MOV     R6,A
   \   000046   E4           CLR     A
   \   000047   3F           ADDC    A,R7
   \   000048   FF           MOV     R7,A
   \   000049   E8           MOV     A,R0
   \   00004A   2404         ADD     A,#0x4
   \   00004C   F5..         MOV     ?V2,A
   \   00004E   E4           CLR     A
   \   00004F   39           ADDC    A,R1
   \   000050   F5..         MOV     ?V3,A
   \   000052                ; Setup parameters for call to function zclAnalogDataType
   \   000052   85..82       MOV     DPL,?V2
   \   000055   F583         MOV     DPH,A
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005C   E9           MOV     A,R1
   \   00005D   60C7         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   00005F                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005F   85..82       MOV     DPL,?V2
   \   000062   85..83       MOV     DPH,?V3
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F9           MOV     R1,A
   \   000067   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006A   EE           MOV     A,R6
   \   00006B   29           ADD     A,R1
   \   00006C   80B4         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1452              }
   1453            }
   1454          
   1455            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   00006E                ; Setup parameters for call to function osal_mem_alloc
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000075   8A..         MOV     ?V2,R2
   \   000077   8B..         MOV     ?V3,R3
   1456            if ( buf != NULL )
   \   000079   EA           MOV     A,R2
   \   00007A   45..         ORL     A,?V3
   \   00007C   7003         JNZ     $+5
   \   00007E   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1457            {
   1458              // Load the buffer - serially
   1459              uint8 *pBuf = buf;
   \   000081   8A..         MOV     ?V6,R2
   \   000083   8B..         MOV     ?V7,R3
   1460          
   1461              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000085   75..00       MOV     ?V0,#0x0
   \   000088   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1462              {
   1463                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1464          
   1465                *pBuf++ = reportRspRec->status;
   1466                *pBuf++ = reportRspRec->direction;
   1467                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1468                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1469          
   1470                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1471                {
   1472                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1473                  {
   1474                    *pBuf++ = reportRspRec->dataType;
   1475                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1476                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1477                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1478                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1479          
   1480                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1481                    {
   1482                      pBuf = zclSerializeData( reportRspRec->dataType,
   1483                                               reportRspRec->reportableChange, pBuf );
   1484                    }
   1485                  }
   1486                  else
   1487                  {
   1488                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   00008A   E5..         MOV     A,?V4
   \   00008C   2409         ADD     A,#0x9
   \   00008E   12....       LCALL   ?Subroutine23 & 0xFFFF
   1489                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1490                  }
   \                     ??CrossCallReturnLabel_15:
   \   000091   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   000093   12....       LCALL   ?Subroutine72 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000096   506C         JNC     ??zcl_SendReadReportCfgRspCmd_8
   \   000098   E5..         MOV     A,?V0
   \   00009A   75F00D       MOV     B,#0xd
   \   00009D   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   0000A7   E5..         MOV     A,?V4
   \   0000A9   2402         ADD     A,#0x2
   \   0000AB   F8           MOV     R0,A
   \   0000AC   E4           CLR     A
   \   0000AD   35..         ADDC    A,?V5
   \   0000AF   F9           MOV     R1,A
   \   0000B0   8882         MOV     DPL,R0
   \   0000B2   8983         MOV     DPH,R1
   \   0000B4   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000B7   85..82       MOV     DPL,?V4
   \   0000BA   85..83       MOV     DPH,?V5
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   70D1         JNZ     ??CrossCallReturnLabel_15
   \   0000C0   85..82       MOV     DPL,?V6
   \   0000C3   85..83       MOV     DPH,?V7
   \   0000C6   A3           INC     DPTR
   \   0000C7   A882         MOV     R0,DPL
   \   0000C9   A983         MOV     R1,DPH
   \   0000CB   8A82         MOV     DPL,R2
   \   0000CD   8B83         MOV     DPH,R3
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   70B8         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000D2   E5..         MOV     A,?V4
   \   0000D4   2404         ADD     A,#0x4
   \   0000D6   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000D9   2405         ADD     A,#0x5
   \   0000DB   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000DE   2407         ADD     A,#0x7
   \   0000E0   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000E3   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000E6   E9           MOV     A,R1
   \   0000E7   60A8         JZ      ??CrossCallReturnLabel_15
   \   0000E9                ; Setup parameters for call to function zclSerializeData
   \   0000E9   AC..         MOV     R4,?V6
   \   0000EB   AD..         MOV     R5,?V7
   \   0000ED   E5..         MOV     A,?V4
   \   0000EF   240B         ADD     A,#0xb
   \   0000F1   F582         MOV     DPL,A
   \   0000F3   E4           CLR     A
   \   0000F4   35..         ADDC    A,?V5
   \   0000F6   F583         MOV     DPH,A
   \   0000F8   12....       LCALL   ?Subroutine79 & 0xFFFF
   1491                }
   1492              }
   \                     ??CrossCallReturnLabel_128:
   \   0000FB   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000FE   8A..         MOV     ?V6,R2
   \   000100   8B..         MOV     ?V7,R3
   \   000102   808D         SJMP    ??CrossCallReturnLabel_15
   1493          
   1494              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1495                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1496                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   000104                ; Setup parameters for call to function zcl_SendCommand
   \   000104   78..         MOV     R0,#?V2
   \   000106   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000109   8E..         MOV     ?V4,R6
   \   00010B   8F..         MOV     ?V5,R7
   \   00010D   78..         MOV     R0,#?V4
   \   00010F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000112   7420         MOV     A,#0x20
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00011D   E4           CLR     A
   \   00011E   F5..         MOV     ?V4,A
   \   000120   F5..         MOV     ?V5,A
   \   000122   78..         MOV     R0,#?V4
   \   000124   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000127   7422         MOV     A,#0x22
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000132   7422         MOV     A,#0x22
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00013D   75..00       MOV     ?V0,#0x0
   \   000140   78..         MOV     R0,#?V0
   \   000142   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000145   75..09       MOV     ?V0,#0x9
   \   000148   78..         MOV     R0,#?V0
   \   00014A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014D   AC..         MOV     R4,?V12
   \   00014F   AD..         MOV     R5,?V13
   \   000151   AA..         MOV     R2,?V14
   \   000153   AB..         MOV     R3,?V15
   \   000155   A9..         MOV     R1,?V1
   \   000157   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00015A   740B         MOV     A,#0xb
   \   00015C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00015F   E9           MOV     A,R1
   \   000160   FE           MOV     R6,A
   1497              zcl_mem_free( buf );
   \   000161                ; Setup parameters for call to function osal_mem_free
   \   000161   AA..         MOV     R2,?V2
   \   000163   AB..         MOV     R3,?V3
   \   000165   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000168   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_9
   1498            }
   1499            else
   1500            {
   1501              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   00016A   7E10         MOV     R6,#0x10
   1502            }
   1503          
   1504            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   00016C   02....       LJMP    ?Subroutine12 & 0xFFFF
   1505          }
   1506          
   1507          /*********************************************************************
   1508           * @fn      zcl_SendReportCmd
   1509           *
   1510           * @brief   Send a Report command
   1511           *
   1512           * @param   dstAddr - destination address
   1513           * @param   clusterID - cluster ID
   1514           * @param   reportCmd - report command to be sent
   1515           * @param   direction - direction of the command
   1516           * @param   seqNum - transaction sequence number
   1517           *
   1518           * @return  ZSuccess if OK
   1519           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1520          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1521                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1522                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1523          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1524            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1525            uint8 *buf;
   1526            ZStatus_t status;
   1527            uint8 i;
   1528          
   1529            // calculate the size of the command
   1530            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   00001D   8009         SJMP    ??CrossCallReturnLabel_212
   1531            {
   1532              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   00001F   12....       LCALL   ?Subroutine78 & 0xFFFF
   1533          
   1534              dataLen += 2 + 1; // Attribute ID + data type
   1535          
   1536              // Attribute Data
   1537              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1538            }
   \                     ??CrossCallReturnLabel_126:
   \   000022   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000025   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000028   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   00002B   40F2         JC      ??zcl_SendReportCmd_0
   1539          
   1540            buf = zcl_mem_alloc( dataLen );
   \   00002D                ; Setup parameters for call to function osal_mem_alloc
   \   00002D   EE           MOV     A,R6
   \   00002E   FA           MOV     R2,A
   \   00002F   EF           MOV     A,R7
   \   000030   FB           MOV     R3,A
   \   000031   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000034   8A..         MOV     ?V0,R2
   \   000036   8B..         MOV     ?V1,R3
   1541            if ( buf != NULL )
   \   000038   EA           MOV     A,R2
   \   000039   45..         ORL     A,?V1
   \   00003B   7003         JNZ     $+5
   \   00003D   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1542            {
   1543              // Load the buffer - serially
   1544              uint8 *pBuf = buf;
   \   000040   AC..         MOV     R4,?V0
   \   000042   AD..         MOV     R5,?V1
   1545          
   1546              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   8010         SJMP    ??zcl_SendReportCmd_2
   1547              {
   1548                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   000049   12....       LCALL   ?Subroutine13 & 0xFFFF
   1549          
   1550                *pBuf++ = LO_UINT16( reportRec->attrID );
   1551                *pBuf++ = HI_UINT16( reportRec->attrID );
   1552                *pBuf++ = reportRec->dataType;
   1553          
   1554                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1555              }
   \                     ??CrossCallReturnLabel_1:
   \   00004C   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   00004F   8A..         MOV     ?V10,R2
   \   000051   8B..         MOV     ?V11,R3
   \   000053   AC..         MOV     R4,?V10
   \   000055   AD..         MOV     R5,?V11
   \   000057   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000059   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   00005C   40EB         JC      ??zcl_SendReportCmd_3
   1556          
   1557              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1558                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00005E                ; Setup parameters for call to function zcl_SendCommand
   \   00005E   78..         MOV     R0,#?V0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   8E..         MOV     ?V4,R6
   \   000065   8F..         MOV     ?V5,R7
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   741C         MOV     A,#0x1c
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   E4           CLR     A
   \   000078   F5..         MOV     ?V4,A
   \   00007A   F5..         MOV     ?V5,A
   \   00007C   78..         MOV     R0,#?V4
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000081   741E         MOV     A,#0x1e
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000089   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00008C   741E         MOV     A,#0x1e
   \   00008E   12....       LCALL   ?XSTACK_DISP0_8
   \   000091   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   000094   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000097   75..00       MOV     ?V2,#0x0
   \   00009A   78..         MOV     R0,#?V2
   \   00009C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009F   75..0A       MOV     ?V2,#0xa
   \   0000A2   78..         MOV     R0,#?V2
   \   0000A4   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A7   AC..         MOV     R4,?V6
   \   0000A9   AD..         MOV     R5,?V7
   \   0000AB   AA..         MOV     R2,?V8
   \   0000AD   AB..         MOV     R3,?V9
   \   0000AF   A9..         MOV     R1,?V3
   \   0000B1   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B4   740B         MOV     A,#0xb
   \   0000B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B9   E9           MOV     A,R1
   \   0000BA   FE           MOV     R6,A
   1559              zcl_mem_free( buf );
   \   0000BB                ; Setup parameters for call to function osal_mem_free
   \   0000BB   AA..         MOV     R2,?V0
   \   0000BD   AB..         MOV     R3,?V1
   \   0000BF   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C2   8002         SJMP    ??zcl_SendReportCmd_4
   1560            }
   1561            else
   1562            {
   1563              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000C4   7E10         MOV     R6,#0x10
   1564            }
   1565          
   1566            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000C6   02....       LJMP    ?Subroutine10 & 0xFFFF
   1567          }
   1568          #endif // ZCL_REPORT
   1569          
   1570          /*********************************************************************
   1571           * @fn      zcl_SendDefaultRspCmd
   1572           *
   1573           * @brief   Send a Default Response command
   1574           *
   1575           *          Note: The manufacturer code field should be set if this
   1576           *          command is being sent in response to a manufacturer specific
   1577           *          command.
   1578           *
   1579           * @param   dstAddr - destination address
   1580           * @param   clusterID - cluster ID
   1581           * @param   defaultRspCmd - default response command to be sent
   1582           * @param   direction - direction of the command
   1583           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1584           * @param   seqNum - transaction sequence number
   1585           *
   1586           * @return  ZSuccess if OK
   1587           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1588          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1589                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1590                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1591          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine97 & 0xFFFF
   1592            uint8 buf[2]; // Command ID and Status;
   1593          
   1594            // Load the buffer - serially
   1595            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_160:
   \   000014   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000017   12....       LCALL   ?Subroutine42 & 0xFFFF
   1596            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_47:
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   C0E0         PUSH    A
   \   00001D   7401         MOV     A,#0x1
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
   1597          
   1598            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1599                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000025                ; Setup parameters for call to function zcl_SendCommand
   \   000025   A8..         MOV     R0,?XSP + 0
   \   000027   A9..         MOV     R1,?XSP + 1
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D   78..         MOV     R0,#?V0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..02       MOV     ?V0,#0x2
   \   000035   75..00       MOV     ?V1,#0x0
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7416         MOV     A,#0x16
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000048   7415         MOV     A,#0x15
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000050   7416         MOV     A,#0x16
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005B   7416         MOV     A,#0x16
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000066   75..00       MOV     ?V0,#0x0
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   75..0B       MOV     ?V0,#0xb
   \   000071   78..         MOV     R0,#?V0
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000076   EE           MOV     A,R6
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   02....       LJMP    ?Subroutine2 & 0xFFFF
   1600          }
   1601          
   1602          #ifdef ZCL_DISCOVER
   1603          /*********************************************************************
   1604           * @fn      zcl_SendDiscoverCmdsCmd
   1605           *
   1606           * @brief   Send a Discover Commands command
   1607           *
   1608           * @param   dstAddr - destination address
   1609           * @param   clusterID - cluster ID
   1610           * @param   cmdType - requesting command ID
   1611           * @param   pDiscoverCmd - discover command to be sent
   1612           * @param   direction - direction of the command
   1613           * @param   seqNum - transaction sequence number
   1614           *
   1615           * @return  ZSuccess if OK
   1616           */
   1617          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1618                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1619                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1620          {
   1621            uint8 payload[2]; // size of startCmdID and maxCmdID
   1622            ZStatus_t status;
   1623          
   1624            payload[0] = pDiscoverCmd->startCmdID;
   1625            payload[1] = pDiscoverCmd->maxCmdID;
   1626          
   1627            // Send message for either commands received or generated
   1628            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1629            {
   1630              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1631                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1632            }
   1633            else  // generated
   1634            {
   1635              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1636                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1637            }
   1638          
   1639            return ( status );
   1640          }
   1641          
   1642          /*********************************************************************
   1643           * @fn      zcl_SendDiscoverCmdsRspCmd
   1644           *
   1645           * @brief   Send a Discover Commands Response command
   1646           *
   1647           * @param   dstAddr - destination address
   1648           * @param   clusterID - cluster ID
   1649           * @param   pDiscoverRspCmd - response command to be sent
   1650           * @param   direction - direction of the command
   1651           * @param   seqNum - transaction sequence number
   1652           *
   1653           * @return  ZSuccess if OK
   1654           */
   1655          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1656                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1657                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1658          {
   1659            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1660            uint8 *pCmdBuf;
   1661            uint8 i;
   1662            ZStatus_t status = ZSuccess;
   1663          
   1664            // allocate memory
   1665            pCmdBuf = zcl_mem_alloc( payloadSize );
   1666            if ( pCmdBuf != NULL )
   1667            {
   1668              uint8 *pBuf = pCmdBuf;
   1669          
   1670              // Load the buffer - serially
   1671              *pBuf++ = pDiscoverRspCmd->discComplete;
   1672              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1673              {
   1674                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1675              }
   1676          
   1677              // Send response message for either commands received or generated
   1678              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1679              {
   1680                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1681                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1682              }
   1683              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1684              {
   1685                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1686                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1687              }
   1688          
   1689              zcl_mem_free( pCmdBuf );
   1690            }
   1691            else
   1692            {
   1693              status = ZMemError;
   1694            }
   1695          
   1696            return ( status );
   1697          }
   1698          
   1699          /*********************************************************************
   1700           * @fn      zcl_SendDiscoverAttrsCmd
   1701           *
   1702           * @brief   Send a Discover Attributes command
   1703           *
   1704           * @param   dstAddr - destination address
   1705           * @param   clusterID - cluster ID
   1706           * @param   pDiscoverCmd - discover command to be sent
   1707           * @param   direction - direction of the command
   1708           * @param   seqNum - transaction sequence number
   1709           *
   1710           * @return  ZSuccess if OK
   1711           */
   1712          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1713                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1714                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1715          {
   1716            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1717            uint8 *buf;
   1718            ZStatus_t status;
   1719          
   1720            buf = zcl_mem_alloc( dataLen );
   1721            if ( buf != NULL )
   1722            {
   1723              // Load the buffer - serially
   1724              uint8 *pBuf = buf;
   1725              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1726              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1727              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1728          
   1729              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1730                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1731              zcl_mem_free( buf );
   1732            }
   1733            else
   1734            {
   1735              status = ZMemError;
   1736            }
   1737          
   1738            return ( status );
   1739          }
   1740          
   1741          /*********************************************************************
   1742           * @fn      zcl_SendDiscoverAttrsRspCmd
   1743           *
   1744           * @brief   Send a Discover Attributes Response command
   1745           *
   1746           * @param   dstAddr - destination address
   1747           * @param   clusterID - cluster ID
   1748           * @param   reportRspCmd - report response command to be sent
   1749           * @param   direction - direction of the command
   1750           * @param   seqNum - transaction sequence number
   1751           *
   1752           * @return  ZSuccess if OK
   1753           */
   1754          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1755                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1756                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1757          {
   1758            uint16 dataLen = 1; // Discovery complete
   1759            uint8 *buf;
   1760            ZStatus_t status;
   1761          
   1762            // calculate the size of the command
   1763            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1764          
   1765            buf = zcl_mem_alloc( dataLen );
   1766            if ( buf != NULL )
   1767            {
   1768              // Load the buffer - serially
   1769              uint8 i;
   1770              uint8 *pBuf = buf;
   1771          
   1772              *pBuf++ = pDiscoverRspCmd->discComplete;
   1773          
   1774              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1775              {
   1776                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1777                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1778                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1779              }
   1780          
   1781              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1782                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1783              zcl_mem_free( buf );
   1784            }
   1785            else
   1786            {
   1787              status = ZMemError;
   1788            }
   1789          
   1790            return ( status );
   1791          }
   1792          
   1793          /*********************************************************************
   1794           * @fn      zcl_SendDiscoverAttrsExt
   1795           *
   1796           * @brief   Send a Discover Attributes Extended command
   1797           *
   1798           * @param   dstAddr - destination address
   1799           * @param   clusterID - cluster ID
   1800           * @param   pDiscoverAttrsExt:
   1801           *            - startAttrID: the first attribute to be selected
   1802           *            - maxAttrIDs: maximum number of returned attributes
   1803           * @param   direction - direction of the command
   1804           * @param   seqNum - transaction sequence number
   1805           *
   1806           * @return  ZSuccess if OK
   1807           */
   1808          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1809                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1810                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1811          {
   1812            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1813            ZStatus_t status;
   1814          
   1815            // Load the buffer - serially
   1816            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1817            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1818            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1819          
   1820            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1821                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1822          
   1823            return ( status );
   1824          }
   1825          
   1826          /*********************************************************************
   1827           * @fn      zcl_SendDiscoverAttrsExtRsp
   1828           *
   1829           * @brief   Send a Discover Attributes Extended Response command
   1830           *
   1831           * @param   dstAddr - destination address
   1832           * @param   clusterID - cluster ID
   1833           * @param   pDiscoverRspCmd:
   1834           *            - discComplete: indicates whether all requested attributes returned
   1835           *            - attrID: attribute ID
   1836           *            - attrDataType: data type of the given attribute
   1837           *            - attrAccessControl: access control of the given attribute
   1838           * @param   direction - direction of the command
   1839           * @param   seqNum - transaction sequence number
   1840           *
   1841           * @return  ZSuccess if OK
   1842           */
   1843          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1844                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1845                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1846          {
   1847            uint8 *buf;
   1848            uint8 i;
   1849            uint16 dataLen = 1; // Discovery complete
   1850            ZStatus_t status;
   1851          
   1852            // calculate the size of the command
   1853            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1854          
   1855            buf = zcl_mem_alloc( dataLen );
   1856            if ( buf != NULL )
   1857            {
   1858              // Load the buffer - serially
   1859              uint8 *pBuf = buf;
   1860              *pBuf++ = pDiscoverRspCmd->discComplete;
   1861              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1862              {
   1863                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1864                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1865                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1866                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1867              }
   1868          
   1869              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1870                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1871              zcl_mem_free( buf );
   1872            }
   1873            else
   1874            {
   1875              status = ZMemError;
   1876            }
   1877          
   1878            return ( status );
   1879          }
   1880          #endif // ZCL_DISCOVER
   1881          
   1882          /*********************************************************************
   1883           * @fn      zcl_ProcessMessageMSG
   1884           *
   1885           * @brief   Data message processor callback.  This function processes
   1886           *          any incoming data - probably from other devices.  So, based
   1887           *          on cluster ID, perform the intended action.
   1888           *
   1889           * @param   pkt - incoming message
   1890           *
   1891           * @return  zclProcMsgStatus_t
   1892           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1893          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1894          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1895            endPointDesc_t *epDesc;
   1896            zclIncoming_t inMsg;
   1897            zclLibPlugin_t *pInPlugin;
   1898            zclDefaultRspCmd_t defautlRspCmd;
   1899            uint8 options;
   1900            uint8 securityEnable;
   1901            uint8 interPanMsg;
   1902            ZStatus_t status = ZFailure;
   1903            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   1904          
   1905            if ( pkt->cmd.DataLength == 0 )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000017   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   00001A   7005         JNZ     ??zcl_ProcessMessageMSG_0
   1906            {
   1907              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   00001C   7901         MOV     R1,#0x1
   \   00001E   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1908            }
   1909          
   1910            // Initialize
   1911            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000021   90....       MOV     DPTR,#rawAFMsg
   \   000024   EE           MOV     A,R6
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EF           MOV     A,R7
   \   000028   F0           MOVX    @DPTR,A
   1912            inMsg.msg = pkt;
   \   000029   7402         MOV     A,#0x2
   \   00002B   12....       LCALL   ?XSTACK_DISP0_8
   \   00002E   EE           MOV     A,R6
   \   00002F   F0           MOVX    @DPTR,A
   \   000030   A3           INC     DPTR
   \   000031   EF           MOV     A,R7
   \   000032   F0           MOVX    @DPTR,A
   1913            inMsg.attrCmd = NULL;
   \   000033   740E         MOV     A,#0xe
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   F0           MOVX    @DPTR,A
   1914            inMsg.pData = NULL;
   \   00003C   740A         MOV     A,#0xa
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E4           CLR     A
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   F0           MOVX    @DPTR,A
   1915            inMsg.pDataLen = 0;
   \   000045   740C         MOV     A,#0xc
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   F0           MOVX    @DPTR,A
   1916          
   1917            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00004E   EE           MOV     A,R6
   \   00004F   2422         ADD     A,#0x22
   \   000051   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   000054   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_494:
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   12....       LCALL   ??zclParseHdr?relay  ; Banked call to: zclParseHdr
   \   000063   8A..         MOV     ?V6,R2
   \   000065   8B..         MOV     ?V7,R3
   \   000067   A8..         MOV     R0,?V6
   \   000069   A9..         MOV     R1,?V7
   \   00006B   740A         MOV     A,#0xa
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   1918            inMsg.pDataLen = pkt->cmd.DataLength;
   1919            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_463:
   \   000073   85..82       MOV     DPL,?V4
   \   000076   85..83       MOV     DPH,?V5
   \   000079   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   00007C   EA           MOV     A,R2
   \   00007D   C3           CLR     C
   \   00007E   98           SUBB    A,R0
   \   00007F   F8           MOV     R0,A
   \   000080   EB           MOV     A,R3
   \   000081   99           SUBB    A,R1
   \   000082   F9           MOV     R1,A
   \   000083   85..82       MOV     DPL,?V0
   \   000086   85..83       MOV     DPH,?V1
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   28           ADD     A,R0
   \   00008B   F8           MOV     R0,A
   \   00008C   A3           INC     DPTR
   \   00008D   E0           MOVX    A,@DPTR
   \   00008E   39           ADDC    A,R1
   \   00008F   F9           MOV     R1,A
   \   000090   740C         MOV     A,#0xc
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   1920          
   1921            // Temporary workaround to allow callback functions access to the 
   1922            // transaction sequence number.  Callback functions will call 
   1923            // zcl_getParsedTransSeqNum() to retrieve this number.
   1924            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_464:
   \   000098   7408         MOV     A,#0x8
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A1   F0           MOVX    @DPTR,A
   1925            
   1926            // Find the wanted endpoint
   1927            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A2   EE           MOV     A,R6
   \   0000A3   2414         ADD     A,#0x14
   \   0000A5   12....       LCALL   ?Subroutine114 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   F9           MOV     R1,A
   \   0000AA   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   0000AD   8A82         MOV     DPL,R2
   \   0000AF   8B83         MOV     DPH,R3
   1928            if ( epDesc == NULL )
   \   0000B1   E582         MOV     A,DPL
   \   0000B3   4583         ORL     A,DPH
   \   0000B5   700C         JNZ     ??zcl_ProcessMessageMSG_2
   1929            {
   1930              rawAFMsg = NULL;
   \   0000B7   90....       MOV     DPTR,#rawAFMsg
   \   0000BA   E4           CLR     A
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   A3           INC     DPTR
   \   0000BD   F0           MOVX    @DPTR,A
   1931              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000BE   7902         MOV     R1,#0x2
   \   0000C0   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1932            }
   1933          
   1934            if ( ( epDesc->simpleDesc == NULL ) ||
   1935                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1936                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C3   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_307:
   \   0000C6   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000C8   EE           MOV     A,R6
   \   0000C9   2404         ADD     A,#0x4
   \   0000CB   F5..         MOV     ?V4,A
   \   0000CD   E4           CLR     A
   \   0000CE   3F           ADDC    A,R7
   \   0000CF   F5..         MOV     ?V5,A
   \   0000D1                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D1   A3           INC     DPTR
   \   0000D2   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D5   740B         MOV     A,#0xb
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   FD           MOV     R5,A
   \   0000DC   7406         MOV     A,#0x6
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   5403         ANL     A,#0x3
   \   0000E4   FC           MOV     R4,A
   \   0000E5   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0000E8   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000EB   7402         MOV     A,#0x2
   \   0000ED   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F0   E9           MOV     A,R1
   \   0000F1   700C         JNZ     ??zcl_ProcessMessageMSG_4
   1937            {
   1938              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F3   90....       MOV     DPTR,#rawAFMsg
   \   0000F6   E4           CLR     A
   \   0000F7   F0           MOVX    @DPTR,A
   \   0000F8   A3           INC     DPTR
   \   0000F9   F0           MOVX    @DPTR,A
   1939              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FA   7903         MOV     R1,#0x3
   \   0000FC   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1940            }
   1941          
   1942          #if defined ( INTER_PAN )
   1943            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1944            {
   1945              // No foundation command is supported thru Inter-PAN communication.
   1946              // But the Light Link cluster uses a different Frame Control format
   1947              // for it's Inter-PAN messages, where the messages could be confused
   1948              // with the foundation commands.
   1949              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1950              {
   1951                rawAFMsg = NULL;
   1952                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   1953              }
   1954          
   1955              interPanMsg = TRUE;
   1956              options = AF_TX_OPTIONS_NONE;
   1957            }
   1958            else
   1959          #endif
   1960            {
   1961              interPanMsg = FALSE;
   1962              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   0000FF                ; Setup parameters for call to function zclGetClusterOption
   \   0000FF   12....       LCALL   ?Subroutine63 & 0xFFFF
   1963            }
   \                     ??CrossCallReturnLabel_96:
   \   000102   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   000105   E9           MOV     A,R1
   \   000106   F5..         MOV     ?V3,A
   1964          
   1965            // Find the appropriate plugin
   1966            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   000108   85..82       MOV     DPL,?V4
   \   00010B   85..83       MOV     DPH,?V5
   \   00010E   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   000111   EA           MOV     A,R2
   \   000112   FC           MOV     R4,A
   \   000113   EB           MOV     A,R3
   \   000114   FD           MOV     R5,A
   \   000115   90....       MOV     DPTR,#plugins
   \   000118   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   00011A   8882         MOV     DPL,R0
   \   00011C   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00011E   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   000121   7003         JNZ     $+5
   \   000123   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000126   8882         MOV     DPL,R0
   \   000128   8983         MOV     DPH,R1
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   00012F   C3           CLR     C
   \   000130   EC           MOV     A,R4
   \   000131   95..         SUBB    A,?V6
   \   000133   ED           MOV     A,R5
   \   000134   95..         SUBB    A,?V7
   \   000136   40E2         JC      ??zcl_ProcessMessageMSG_6
   \   000138   8882         MOV     DPL,R0
   \   00013A   8983         MOV     DPH,R1
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   C3           CLR     C
   \   000141   E0           MOVX    A,@DPTR
   \   000142   9C           SUBB    A,R4
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   9D           SUBB    A,R5
   \   000146   40D2         JC      ??zcl_ProcessMessageMSG_6
   \   000148   E8           MOV     A,R0
   \   000149   FC           MOV     R4,A
   \   00014A   E9           MOV     A,R1
   \   00014B   FD           MOV     R5,A
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   5407         ANL     A,#0x7
   \   000154   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000156   7409         MOV     A,#0x9
   \   000158   12....       LCALL   ?XSTACK_DISP0_8
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   640B         XRL     A,#0xb
   \   00015E   7003         JNZ     $+5
   \   000160   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1967          
   1968            // Local and remote Security options must match except for Default Response command
   1969            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1970            {
   1971              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000163   E5..         MOV     A,?V3
   \   000165   A2E6         MOV     C,0xE0 /* A   */.6
   \   000167   4003         JC      $+5
   \   000169   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   00016C   EE           MOV     A,R6
   \   00016D   2419         ADD     A,#0x19
   \   00016F   F582         MOV     DPL,A
   \   000171   E4           CLR     A
   \   000172   3F           ADDC    A,R7
   \   000173   F583         MOV     DPH,A
   \   000175   E0           MOVX    A,@DPTR
   \   000176   6003         JZ      $+5
   \   000178   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1972          
   1973              // Make sure that Clusters specifically defined to use security are received secure,
   1974              // any other cluster that wants to use APS security will be allowed
   1975              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1976              {
   1977                if ( UNICAST_MSG( inMsg.msg ) )
   \   00017B   7402         MOV     A,#0x2
   \   00017D   12....       LCALL   ?XSTACK_DISP0_8
   \   000180   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   000183   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   000185   7402         MOV     A,#0x2
   \   000187   12....       LCALL   ?XSTACK_DISP0_8
   \   00018A   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   00018D   7073         JNZ     ??zcl_ProcessMessageMSG_10
   1978                {
   1979                  // Send a Default Response command back with no Application Link Key security
   1980                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00018F                ; Setup parameters for call to function zclSetSecurityOption
   \   00018F   7C00         MOV     R4,#0x0
   \   000191   85..82       MOV     DPL,?V0
   \   000194   85..83       MOV     DPH,?V1
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F9           MOV     R1,A
   \   000199   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1981          
   1982                  defautlRspCmd.statusCode = status;
   \   00019C   7401         MOV     A,#0x1
   \   00019E   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A1   7401         MOV     A,#0x1
   \   0001A3   F0           MOVX    @DPTR,A
   1983                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A4   7409         MOV     A,#0x9
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   12....       LCALL   ?Subroutine94 & 0xFFFF
   1984                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1985                                         inMsg.msg->clusterId, &defautlRspCmd,
   1986                                         !inMsg.hdr.fc.direction, true,
   1987                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_152:
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   12....       LCALL   ??Subroutine203_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   0001B2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B5   7407         MOV     A,#0x7
   \   0001B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001BD   75..01       MOV     ?V2,#0x1
   \   0001C0   78..         MOV     R0,#?V2
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C5   7408         MOV     A,#0x8
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   12....       LCALL   ??Subroutine209_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_481:
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D0   7405         MOV     A,#0x5
   \   0001D2   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D5   88..         MOV     ?V2,R0
   \   0001D7   89..         MOV     ?V3,R1
   \   0001D9   78..         MOV     R0,#?V2
   \   0001DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DE   7409         MOV     A,#0x9
   \   0001E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   0001E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E9   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   0001EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EF   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   0001F2   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   0001F5   7407         MOV     A,#0x7
   \   0001F7   12....       LCALL   ?DEALLOC_XSTACK8
   1988          
   1989                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001FA                ; Setup parameters for call to function zclSetSecurityOption
   \   0001FA   7C01         MOV     R4,#0x1
   \   0001FC   12....       LCALL   ?Subroutine63 & 0xFFFF
   1990                }
   \                     ??CrossCallReturnLabel_97:
   \   0001FF   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1991          
   1992                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000202   90....       MOV     DPTR,#rawAFMsg
   \   000205   E4           CLR     A
   \   000206   F0           MOVX    @DPTR,A
   \   000207   A3           INC     DPTR
   \   000208   F0           MOVX    @DPTR,A
   1993                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000209   7905         MOV     R1,#0x5
   \   00020B   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1994              }
   1995            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00020E   7C00         MOV     R4,#0x0
   \   000210   7D00         MOV     R5,#0x0
   1996          
   1997            // Is this a foundation type message
   1998            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000212   7404         MOV     A,#0x4
   \   000214   12....       LCALL   ?XSTACK_DISP0_8
   \   000217   E0           MOVX    A,@DPTR
   \   000218   F8           MOV     R0,A
   \   000219   5403         ANL     A,#0x3
   \   00021B   6003         JZ      $+5
   \   00021D   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   1999            {
   2000              if ( inMsg.hdr.fc.manuSpecific )
   \   000220   E8           MOV     A,R0
   \   000221   5404         ANL     A,#0x4
   \   000223   6005         JZ      ??zcl_ProcessMessageMSG_12
   2001              {
   2002                // We don't support any manufacturer specific command
   2003                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000225   7E84         MOV     R6,#-0x7c
   \   000227   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   2004              }
   2005              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   2006                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00022A   7409         MOV     A,#0x9
   \   00022C   12....       LCALL   ?XSTACK_DISP0_8
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F5..         MOV     ?V4,A
   \   000232   C3           CLR     C
   \   000233   9417         SUBB    A,#0x17
   \   000235   4003         JC      $+5
   \   000237   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00023A   75..00       MOV     ?V5,#0x0
   \   00023D   7402         MOV     A,#0x2
   \   00023F   78..         MOV     R0,#?V4
   \   000241   12....       LCALL   ?S_SHL
   \   000244   74..         MOV     A,#zclCmdTable & 0xff
   \   000246   25..         ADD     A,?V4
   \   000248   F582         MOV     DPL,A
   \   00024A   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00024C   35..         ADDC    A,?V5
   \   00024E   F583         MOV     DPH,A
   \   000250   E4           CLR     A
   \   000251   93           MOVC    A,@A+DPTR
   \   000252   F8           MOV     R0,A
   \   000253   7401         MOV     A,#0x1
   \   000255   93           MOVC    A,@A+DPTR
   \   000256   F9           MOV     R1,A
   \   000257   E8           MOV     A,R0
   \   000258   49           ORL     A,R1
   \   000259   7003         JNZ     $+5
   \   00025B   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   2007              {
   2008                zclParseCmd_t parseCmd;
   2009          
   2010                parseCmd.endpoint = pkt->endPoint;
   \   00025E   85..82       MOV     DPL,?V0
   \   000261   85..83       MOV     DPH,?V1
   \   000264   E0           MOVX    A,@DPTR
   \   000265   C0E0         PUSH    A
   \   000267   7410         MOV     A,#0x10
   \   000269   12....       LCALL   ?XSTACK_DISP0_8
   \   00026C   D0E0         POP     A
   \   00026E   F0           MOVX    @DPTR,A
   2011                parseCmd.dataLen = inMsg.pDataLen;
   \   00026F   740C         MOV     A,#0xc
   \   000271   12....       LCALL   ?XSTACK_DISP0_8
   \   000274   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_405:
   \   000277   7411         MOV     A,#0x11
   \   000279   12....       LCALL   ?XSTACK_DISP0_8
   \   00027C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2012                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_465:
   \   00027F   740A         MOV     A,#0xa
   \   000281   12....       LCALL   ?XSTACK_DISP0_8
   \   000284   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_406:
   \   000287   7413         MOV     A,#0x13
   \   000289   12....       LCALL   ?XSTACK_DISP0_8
   \   00028C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2013          
   2014                // Parse the command, remember that the return value is a pointer to allocated memory
   2015                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_466:
   \   00028F                ; Setup parameters for indirect call
   \   00028F   7410         MOV     A,#0x10
   \   000291   12....       LCALL   ?XSTACK_DISP101_8
   \   000294   7409         MOV     A,#0x9
   \   000296   12....       LCALL   ?XSTACK_DISP0_8
   \   000299   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00029C   12....       LCALL   ?S_SHL
   \   00029F   74..         MOV     A,#zclCmdTable & 0xff
   \   0002A1   25..         ADD     A,?V0
   \   0002A3   F582         MOV     DPL,A
   \   0002A5   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002A7   35..         ADDC    A,?V1
   \   0002A9   F583         MOV     DPH,A
   \   0002AB   E4           CLR     A
   \   0002AC   93           MOVC    A,@A+DPTR
   \   0002AD   C0E0         PUSH    A
   \   0002AF   7401         MOV     A,#0x1
   \   0002B1   93           MOVC    A,@A+DPTR
   \   0002B2   F583         MOV     DPH,A
   \   0002B4   D082         POP     DPL
   \   0002B6   12....       LCALL   ?CALL_IND
   \   0002B9   8A..         MOV     ?V0,R2
   \   0002BB   8B..         MOV     ?V1,R3
   \   0002BD   A8..         MOV     R0,?V0
   \   0002BF   A9..         MOV     R1,?V1
   \   0002C1   740E         MOV     A,#0xe
   \   0002C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C6   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   2016                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_467:
   \   0002C9   E8           MOV     A,R0
   \   0002CA   49           ORL     A,R1
   \   0002CB   6045         JZ      ??zcl_ProcessMessageMSG_15
   \   0002CD   7409         MOV     A,#0x9
   \   0002CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D2   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0002D5   12....       LCALL   ?S_SHL
   \   0002D8   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002DA   25..         ADD     A,?V0
   \   0002DC   F582         MOV     DPL,A
   \   0002DE   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002E0   35..         ADDC    A,?V1
   \   0002E2   F583         MOV     DPH,A
   \   0002E4   E4           CLR     A
   \   0002E5   93           MOVC    A,@A+DPTR
   \   0002E6   F8           MOV     R0,A
   \   0002E7   7401         MOV     A,#0x1
   \   0002E9   93           MOVC    A,@A+DPTR
   \   0002EA   F9           MOV     R1,A
   \   0002EB   8882         MOV     DPL,R0
   \   0002ED   8983         MOV     DPH,R1
   \   0002EF   E582         MOV     A,DPL
   \   0002F1   4583         ORL     A,DPH
   \   0002F3   6012         JZ      ??zcl_ProcessMessageMSG_16
   2017                {
   2018                  // Process the command
   2019                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002F5                ; Setup parameters for indirect call
   \   0002F5   7402         MOV     A,#0x2
   \   0002F7   12....       LCALL   ?XSTACK_DISP101_8
   \   0002FA   12....       LCALL   ?CALL_IND
   2020                  {
   2021                    // Couldn't find attribute in the table.
   2022                  }
   2023                }
   2024          
   2025                // Free the buffer
   2026                if ( inMsg.attrCmd )
   \   0002FD   740E         MOV     A,#0xe
   \   0002FF   12....       LCALL   ?XSTACK_DISP0_8
   \   000302   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   000305   600B         JZ      ??zcl_ProcessMessageMSG_15
   2027                {
   2028                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   000307                ; Setup parameters for call to function osal_mem_free
   \   000307   740E         MOV     A,#0xe
   \   000309   12....       LCALL   ?XSTACK_DISP0_8
   \   00030C   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   2029                }
   \                     ??CrossCallReturnLabel_343:
   \   00030F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   2030          
   2031                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000312   7409         MOV     A,#0x9
   \   000314   12....       LCALL   ?XSTACK_DISP0_8
   \   000317   E0           MOVX    A,@DPTR
   \   000318   F8           MOV     R0,A
   \   000319   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   00031B   7402         MOV     A,#0x2
   \   00031D   68           XRL     A,R0
   \   00031E   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   000320   7403         MOV     A,#0x3
   \   000322   68           XRL     A,R0
   \   000323   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000325   7406         MOV     A,#0x6
   \   000327   68           XRL     A,R0
   \   000328   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   00032A   7408         MOV     A,#0x8
   \   00032C   68           XRL     A,R0
   \   00032D   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00032F   740C         MOV     A,#0xc
   \   000331   68           XRL     A,R0
   \   000332   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   000334   7411         MOV     A,#0x11
   \   000336   68           XRL     A,R0
   \   000337   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000339   7413         MOV     A,#0x13
   \   00033B   68           XRL     A,R0
   \   00033C   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   00033E   7415         MOV     A,#0x15
   \   000340   68           XRL     A,R0
   \   000341   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   000343   740B         MOV     A,#0xb
   \   000345   68           XRL     A,R0
   \   000346   6027         JZ      ??zcl_ProcessMessageMSG_17
   2032                {
   2033                  rawAFMsg = NULL;
   2034                  return ( ZCL_PROC_SUCCESS ); // We're done
   2035                }
   2036          
   2037                status = ZSuccess;
   \   000348   7E00         MOV     R6,#0x0
   \   00034A   8043         SJMP    ??zcl_ProcessMessageMSG_13
   2038              }
   2039              else
   2040              {
   2041                // Unsupported message
   2042                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   00034C   7E82         MOV     R6,#-0x7e
   \   00034E   803F         SJMP    ??zcl_ProcessMessageMSG_13
   2043              }
   2044            }
   2045            else  // Not a foundation type message, so it must be specific to the cluster ID.
   2046            {
   2047              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   000350   EC           MOV     A,R4
   \   000351   4D           ORL     A,R5
   \   000352   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   000354   8C82         MOV     DPL,R4
   \   000356   8D83         MOV     DPH,R5
   \   000358   A3           INC     DPTR
   \   000359   A3           INC     DPTR
   \   00035A   A3           INC     DPTR
   \   00035B   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   00035E   601F         JZ      ??zcl_ProcessMessageMSG_18
   2048              {
   2049                // The return value of the plugin function will be
   2050                //  ZSuccess - Supported and need default response
   2051                //  ZFailure - Unsupported
   2052                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   2053                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   2054                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   2055                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   2056                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000360                ; Setup parameters for indirect call
   \   000360   7402         MOV     A,#0x2
   \   000362   12....       LCALL   ?XSTACK_DISP101_8
   \   000365   12....       LCALL   ?CALL_IND
   \   000368   E9           MOV     A,R1
   \   000369   FE           MOV     R6,A
   2057                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   00036A   74FF         MOV     A,#-0x1
   \   00036C   6E           XRL     A,R6
   \   00036D   700B         JNZ     ??zcl_ProcessMessageMSG_19
   2058                {
   2059                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00036F   90....       MOV     DPTR,#rawAFMsg
   \   000372   E4           CLR     A
   \   000373   F0           MOVX    @DPTR,A
   \   000374   A3           INC     DPTR
   \   000375   F0           MOVX    @DPTR,A
   2060                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000376   F9           MOV     R1,A
   \   000377   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   2061                }
   2062              }
   2063          
   2064              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   00037A   7401         MOV     A,#0x1
   \   00037C   6E           XRL     A,R6
   \   00037D   7010         JNZ     ??zcl_ProcessMessageMSG_13
   2065              {
   2066                // Unsupported message
   2067                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00037F   7404         MOV     A,#0x4
   \   000381   12....       LCALL   ?XSTACK_DISP0_8
   \   000384   E0           MOVX    A,@DPTR
   \   000385   5404         ANL     A,#0x4
   \   000387   6004         JZ      ??zcl_ProcessMessageMSG_20
   2068                {
   2069                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000389   7E83         MOV     R6,#-0x7d
   \   00038B   8002         SJMP    ??zcl_ProcessMessageMSG_13
   2070                }
   2071                else
   2072                {
   2073                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   00038D   7E81         MOV     R6,#-0x7f
   2074                }
   2075              }
   2076            }
   2077          
   2078            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00038F   7402         MOV     A,#0x2
   \   000391   12....       LCALL   ?XSTACK_DISP0_8
   \   000394   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000397   7078         JNZ     ??zcl_ProcessMessageMSG_21
   \   000399   7402         MOV     A,#0x2
   \   00039B   12....       LCALL   ?XSTACK_DISP0_8
   \   00039E   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   0003A1   706E         JNZ     ??zcl_ProcessMessageMSG_21
   \   0003A3   7404         MOV     A,#0x4
   \   0003A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A8   E0           MOVX    A,@DPTR
   \   0003A9   5410         ANL     A,#0x10
   \   0003AB   7064         JNZ     ??zcl_ProcessMessageMSG_21
   2079            {
   2080              // Send a Default Response command back
   2081              defautlRspCmd.statusCode = status;
   \   0003AD   7401         MOV     A,#0x1
   \   0003AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B2   EE           MOV     A,R6
   \   0003B3   F0           MOVX    @DPTR,A
   2082              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003B4   7409         MOV     A,#0x9
   \   0003B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B9   12....       LCALL   ?Subroutine94 & 0xFFFF
   2083              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   2084                                     inMsg.msg->clusterId, &defautlRspCmd,
   2085                                     !inMsg.hdr.fc.direction, true,
   2086                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_153:
   \   0003BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BF   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   0003C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C5   7407         MOV     A,#0x7
   \   0003C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003CA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003CD   75..01       MOV     ?V0,#0x1
   \   0003D0   78..         MOV     R0,#?V0
   \   0003D2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D5   7408         MOV     A,#0x8
   \   0003D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DA   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_485:
   \   0003DD   F5..         MOV     ?V0,A
   \   0003DF   78..         MOV     R0,#?V0
   \   0003E1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003E4   7405         MOV     A,#0x5
   \   0003E6   12....       LCALL   ?XSTACK_DISP100_8
   \   0003E9   88..         MOV     ?V0,R0
   \   0003EB   89..         MOV     ?V1,R1
   \   0003ED   78..         MOV     R0,#?V0
   \   0003EF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003F2   7409         MOV     A,#0x9
   \   0003F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F7   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   0003FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FD   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000400   12....       LCALL   ?XSTACK_DISP0_8
   \   000403   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000406   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   000409   7407         MOV     A,#0x7
   \   00040B   12....       LCALL   ?DEALLOC_XSTACK8
   2087              defaultResponseSent = TRUE;
   \   00040E   75..01       MOV     ?V2,#0x1
   2088            }
   2089          
   2090            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   000411   90....       MOV     DPTR,#rawAFMsg
   \   000414   E4           CLR     A
   \   000415   F0           MOVX    @DPTR,A
   \   000416   A3           INC     DPTR
   \   000417   F0           MOVX    @DPTR,A
   2091            if ( status == ZSuccess )
   \   000418   EE           MOV     A,R6
   \   000419   7004         JNZ     ??zcl_ProcessMessageMSG_22
   2092            {
   2093              return ( ZCL_PROC_SUCCESS );
   \   00041B   7900         MOV     R1,#0x0
   \   00041D   801F         SJMP    ??zcl_ProcessMessageMSG_1
   2094            }
   2095            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   00041F   7484         MOV     A,#-0x7c
   \   000421   6E           XRL     A,R6
   \   000422   700E         JNZ     ??zcl_ProcessMessageMSG_23
   2096            {
   2097              if ( defaultResponseSent )
   \   000424   E5..         MOV     A,?V2
   \   000426   A2E0         MOV     C,0xE0 /* A   */.0
   \   000428   5004         JNC     ??zcl_ProcessMessageMSG_24
   2098              {
   2099                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   00042A   7907         MOV     R1,#0x7
   \   00042C   8010         SJMP    ??zcl_ProcessMessageMSG_1
   2100              }
   2101              else
   2102              {
   2103                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   00042E   7906         MOV     R1,#0x6
   \   000430   800C         SJMP    ??zcl_ProcessMessageMSG_1
   2104              }
   2105            }
   2106            else
   2107            {
   2108              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   000432   E5..         MOV     A,?V2
   \   000434   A2E0         MOV     C,0xE0 /* A   */.0
   \   000436   5004         JNC     ??zcl_ProcessMessageMSG_25
   2109              {
   2110                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000438   7909         MOV     R1,#0x9
   \   00043A   8002         SJMP    ??zcl_ProcessMessageMSG_1
   2111              }
   2112              else
   2113              {
   2114                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   00043C   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   00043E   7415         MOV     A,#0x15
   2115              }
   2116            }
   \   000440   02....       LJMP    ?Subroutine7 & 0xFFFF
   2117          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   C8           XCH     A,R0
   \   000004   2415         ADD     A,#0x15
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   38           ADDC    A,R0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000003   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_512:
   \   000006   7409         MOV     A,#0x9
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_353:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine177_0
   \   000003                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine180_0
   \   000005                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine162:
   \   000000   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   F583         MOV     DPH,A
   \   000005   8882         MOV     DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine181_0
   \   000003                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V6,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine209_0:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_486:
   \   000003   F5..         MOV     ?V2,A
   \   000005   78..         MOV     R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   F5..         MOV     ?V4,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V5,A
   \   000006   85..82       MOV     DPL,?V4
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine217_0
   \   000004                ; // Fall through to label ??Subroutine217_0
   2118          
   2119          /*********************************************************************
   2120           * PRIVATE FUNCTIONS
   2121           *********************************************************************/
   2122          
   2123          /*********************************************************************
   2124           * @fn      zclParseHdr
   2125           *
   2126           * @brief   Parse header of the ZCL format
   2127           *
   2128           * @param   hdr - place to put the frame control information
   2129           * @param   pData - incoming buffer to parse
   2130           *
   2131           * @return  pointer past the header
   2132           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2133          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   2134          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   2135            // Clear the header
   2136            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   2137          
   2138            // Parse the Frame Control
   2139            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   FA           MOV     R2,A
   \   00002B   E8           MOV     A,R0
   \   00002C   4A           ORL     A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine40 & 0xFFFF
   2140            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_43:
   \   000031   A2E2         MOV     C,0xE0 /* A   */.2
   \   000033   5004         JNC     ??zclParseHdr_0
   \   000035   D2F0         SETB    B.0
   \   000037   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000039   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   00003B   E8           MOV     A,R0
   \   00003C   54FB         ANL     A,#0xfb
   \   00003E   FA           MOV     R2,A
   \   00003F   A2F0         MOV     C,B.0
   \   000041   E4           CLR     A
   \   000042   33           RLC     A
   \   000043   F5..         MOV     ?V2,A
   \   000045   75..00       MOV     ?V3,#0x0
   \   000048   7402         MOV     A,#0x2
   \   00004A   78..         MOV     R0,#?V2
   \   00004C   12....       LCALL   ?S_SHL
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V2
   \   000052   12....       LCALL   ?Subroutine40 & 0xFFFF
   2141            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_44:
   \   000055   A2E3         MOV     C,0xE0 /* A   */.3
   \   000057   85..82       MOV     DPL,?V0
   \   00005A   85..83       MOV     DPH,?V1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5004         JNC     ??zclParseHdr_2
   2142            {
   2143              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000060   4408         ORL     A,#0x8
   \   000062   8002         SJMP    ??zclParseHdr_3
   2144            }
   2145            else
   2146            {
   2147              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000064   54F7         ANL     A,#0xf7
   2148            }
   \                     ??zclParseHdr_3:
   \   000066   12....       LCALL   ?Subroutine131 & 0xFFFF
   2149          
   2150            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_315:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   D2F0         SETB    B.0
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0
   \   000077   85..83       MOV     DPH,?V1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   FA           MOV     R2,A
   \   00007E   A2F0         MOV     C,B.0
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F5..         MOV     ?V2,A
   \   000084   7404         MOV     A,#0x4
   \   000086   78..         MOV     R0,#?V2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   EA           MOV     A,R2
   \   00008C   45..         ORL     A,?V2
   \   00008E   F8           MOV     R0,A
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   12....       LCALL   ?Subroutine33 & 0xFFFF
   2151            pData++;  // move past the frame control field
   2152          
   2153            // parse the manfacturer code
   2154            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_30:
   \   000095   E8           MOV     A,R0
   \   000096   5404         ANL     A,#0x4
   \   000098   600A         JZ      ??zclParseHdr_6
   2155            {
   2156              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   12....       LCALL   ?Subroutine83 & 0xFFFF
   2157              pData += 2;
   2158            }
   \                     ??CrossCallReturnLabel_133:
   \   00009E   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   0000A1   5001         JNC     ??zclParseHdr_6
   \   0000A3   0F           INC     R7
   2159          
   2160            // parse the Transaction Sequence Number
   2161            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   85..82       MOV     DPL,?V0
   \   0000AC   85..83       MOV     DPH,?V1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   2162          
   2163            // parse the Cluster's command ID
   2164            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_395:
   \   0000B5   85..82       MOV     DPL,?V0
   \   0000B8   85..83       MOV     DPH,?V1
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   12....       LCALL   ?Subroutine35 & 0xFFFF
   2165          
   2166            // Should point to the frame payload
   2167            return ( pData );
   \                     ??CrossCallReturnLabel_313:
   \   0000C0   AA82         MOV     R2,DPL
   \   0000C2   AB83         MOV     R3,DPH
   \   0000C4   02....       LJMP    ?Subroutine1 & 0xFFFF
   2168          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine178_0
   \   000003                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   AE82         MOV     R6,DPL
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine197_0
   \   000001                ; // Fall through to label ??Subroutine197_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine160:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EA           MOV     A,R2
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET
   2169          
   2170          /*********************************************************************
   2171           * @fn      zclBuildHdr
   2172           *
   2173           * @brief   Build header of the ZCL format
   2174           *
   2175           * @param   hdr - outgoing header information
   2176           * @param   pData - outgoing header space
   2177           *
   2178           * @return  pointer past the header
   2179           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2180          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2181          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2182            // Build the Frame Control byte
   2183            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   2184            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_321:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine43 & 0xFFFF
   2185            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_319:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine43 & 0xFFFF
   2186            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_320:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   12....       LCALL   ?Subroutine37 & 0xFFFF
   2187            pData++;  // move past the frame control field
   2188          
   2189            // Add the manfacturer code
   2190            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_36:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   600E         JZ      ??CrossCallReturnLabel_159
   2191            {
   2192              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000031   12....       LCALL   ?Subroutine96 & 0xFFFF
   2193              *pData++ = HI_UINT16( hdr->manuCode );
   \                     ??CrossCallReturnLabel_158:
   \   000034   8882         MOV     DPL,R0
   \   000036   8983         MOV     DPH,R1
   \   000038   A3           INC     DPTR
   \   000039   12....       LCALL   ?Subroutine96 & 0xFFFF
   2194            }
   2195          
   2196            // Add the Transaction Sequence Number
   2197            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_159:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   8C82         MOV     DPL,R4
   \   000047   8D83         MOV     DPH,R5
   \   000049   12....       LCALL   ?Subroutine37 & 0xFFFF
   2198          
   2199            // Add the Cluster's command ID
   2200            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_37:
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   12....       LCALL   ?Subroutine159 & 0xFFFF
   2201          
   2202            // Should point to the frame payload
   2203            return ( pData );
   \                     ??CrossCallReturnLabel_261:
   \   000054   AA82         MOV     R2,DPL
   \   000056   AB83         MOV     R3,DPH
   \   000058                REQUIRE ?Subroutine8
   \   000058                ; // Fall through to label ?Subroutine8
   2204          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine179_0
   \   000007                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   22           RET
   2205          
   2206          /*********************************************************************
   2207           * @fn      zclCalcHdrSize
   2208           *
   2209           * @brief   Calculate the number of bytes needed for an outgoing
   2210           *          ZCL header.
   2211           *
   2212           * @param   hdr - outgoing header information
   2213           *
   2214           * @return  returns the number of bytes needed
   2215           */
   2216          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2217          {
   2218            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2219          
   2220            // Add the manfacturer code
   2221            if ( hdr->fc.manuSpecific )
   2222            {
   2223              needed += 2;
   2224            }
   2225          
   2226            return ( needed );
   2227          }
   2228          
   2229          /*********************************************************************
   2230           * @fn      zclFindPlugin
   2231           *
   2232           * @brief   Find the right plugin for a cluster ID
   2233           *
   2234           * @param   clusterID - cluster ID to look for
   2235           * @param   profileID - profile ID
   2236           *
   2237           * @return  pointer to plugin, NULL if not found
   2238           */
   2239          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2240          {
   2241            zclLibPlugin_t *pLoop = plugins;
   2242          
   2243            (void)profileID;  // Intentionally unreferenced parameter
   2244          
   2245            while ( pLoop != NULL )
   2246            {
   2247              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2248              {
   2249                return ( pLoop );
   2250              }
   2251          
   2252              pLoop = pLoop->next;
   2253            }
   2254          
   2255            return ( (zclLibPlugin_t *)NULL );
   2256          }
   2257          
   2258          #ifdef ZCL_DISCOVER
   2259          /*********************************************************************
   2260           * @fn      zclFindCmdRecsList
   2261           *
   2262           * @brief   Find the right command record list for an endpoint
   2263           *
   2264           * @param   endpoint - endpoint to look for
   2265           *
   2266           * @return  pointer to record list, NULL if not found
   2267           */
   2268          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2269          {
   2270            zclCmdRecsList_t *pLoop = gpCmdList;
   2271          
   2272            while ( pLoop != NULL )
   2273            {
   2274              if ( pLoop->endpoint == endpoint )
   2275              {
   2276                return ( pLoop );
   2277              }
   2278          
   2279              pLoop = pLoop->pNext;
   2280            }
   2281          
   2282            return ( NULL );
   2283          }
   2284          
   2285          /*********************************************************************
   2286           * @fn      zclFindCmdRec
   2287           *
   2288           * @brief   Find the command record that matchs the parameters
   2289           *
   2290           * @param   endpoint - Application's endpoint
   2291           * @param   clusterID - cluster ID
   2292           * @param   attrId - attribute looking for
   2293           * @param   pAttr - attribute record to be returned
   2294           *
   2295           * @return  TRUE if record found. FALSE, otherwise.
   2296           */
   2297          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2298          {
   2299            uint8 i;
   2300            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2301          
   2302            if ( pRec != NULL )
   2303            {
   2304              for ( i = 0; i < pRec->numCommands; i++ )
   2305              {
   2306                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2307                {
   2308                  *pCmd = pRec->pCmdRecs[i];
   2309          
   2310                  return ( TRUE ); // EMBEDDED RETURN
   2311                }
   2312              }
   2313            }
   2314          
   2315            return ( FALSE );
   2316          }
   2317          #endif // ZCL_DISCOVER
   2318          
   2319          /*********************************************************************
   2320           * @fn      zclFindAttrRecsList
   2321           *
   2322           * @brief   Find the right attribute record list for an endpoint
   2323           *
   2324           * @param   clusterID - endpointto look for
   2325           *
   2326           * @return  pointer to record list, NULL if not found
   2327           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2328          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   2329          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2330            zclAttrRecsList *pLoop = attrList;
   \   000004   90....       MOV     DPTR,#attrList
   \   000007   8004         SJMP    ??zclFindAttrRecsList_0
   2331          
   2332            while ( pLoop != NULL )
   2333            {
   2334              if ( pLoop->endpoint == endpoint )
   2335              {
   2336                return ( pLoop );
   2337              }
   2338          
   2339              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_1:
   \   000009   8A82         MOV     DPL,R2
   \   00000B   8B83         MOV     DPH,R3
   \                     ??zclFindAttrRecsList_0:
   \   00000D   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   000010   600C         JZ      ??zclFindAttrRecsList_2
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   69           XRL     A,R1
   \   00001A   70ED         JNZ     ??zclFindAttrRecsList_1
   \   00001C   8004         SJMP    ??zclFindAttrRecsList_3
   2340            }
   2341          
   2342            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \                     ??zclFindAttrRecsList_3:
   \   000022   02....       LJMP    ?Subroutine0 & 0xFFFF
   2343          }
   2344          
   2345          /*********************************************************************
   2346           * @fn      zclFindAttrRec
   2347           *
   2348           * @brief   Find the attribute record that matchs the parameters
   2349           *
   2350           * @param   endpoint - Application's endpoint
   2351           * @param   clusterID - cluster ID
   2352           * @param   attrId - attribute looking for
   2353           * @param   pAttr - attribute record to be returned
   2354           *
   2355           * @return  TRUE if record found. FALSE, otherwise.
   2356           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2357          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   2358          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   2359          	zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000D                ; Setup parameters for call to function zclFindAttrRecsList
   \   00000D   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   2360          
   2361          	if ( pRec != NULL ) {
   \   000014   E582         MOV     A,DPL
   \   000016   4583         ORL     A,DPH
   \   000018   6064         JZ      ??zclFindAttrRec_0
   2362          		zclAttrRec_t const __code  * iter =  pRec->attrs;
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   000024   8007         SJMP    ??zclFindAttrRec_1
   2363          		while(iter->clusterID != ACHDJIAN_LAST_CLUSTER){
   2364          			if ( iter->clusterID == clusterID && iter->attr.attrId == attrId )  {
   2365          				*pAttr = *iter;
   2366          				return ( TRUE ); // EMBEDDED RETURN
   2367          			}
   2368          			iter++;
   \                     ??zclFindAttrRec_2:
   \   000026   E8           MOV     A,R0
   \   000027   240A         ADD     A,#0xa
   \   000029   F8           MOV     R0,A
   \   00002A   5001         JNC     ??zclFindAttrRec_1
   \   00002C   09           INC     R1
   \                     ??zclFindAttrRec_1:
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   93           MOVC    A,@A+DPTR
   \   000033   C0E0         PUSH    A
   \   000035   7401         MOV     A,#0x1
   \   000037   93           MOVC    A,@A+DPTR
   \   000038   F583         MOV     DPH,A
   \   00003A   D082         POP     DPL
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   74FF         MOV     A,#-0x1
   \   000042   6A           XRL     A,R2
   \   000043   7003         JNZ     ??zclFindAttrRec_3
   \   000045   74FF         MOV     A,#-0x1
   \   000047   6B           XRL     A,R3
   \                     ??zclFindAttrRec_3:
   \   000048   6034         JZ      ??zclFindAttrRec_0
   \   00004A   EE           MOV     A,R6
   \   00004B   6A           XRL     A,R2
   \   00004C   7002         JNZ     ??zclFindAttrRec_4
   \   00004E   EF           MOV     A,R7
   \   00004F   6B           XRL     A,R3
   \                     ??zclFindAttrRec_4:
   \   000050   70D4         JNZ     ??zclFindAttrRec_2
   \   000052   8882         MOV     DPL,R0
   \   000054   8983         MOV     DPH,R1
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E4           CLR     A
   \   000059   93           MOVC    A,@A+DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   7401         MOV     A,#0x1
   \   00005D   93           MOVC    A,@A+DPTR
   \   00005E   FB           MOV     R3,A
   \   00005F   E5..         MOV     A,?V0
   \   000061   6A           XRL     A,R2
   \   000062   7003         JNZ     ??zclFindAttrRec_5
   \   000064   E5..         MOV     A,?V1
   \   000066   6B           XRL     A,R3
   \                     ??zclFindAttrRec_5:
   \   000067   70BD         JNZ     ??zclFindAttrRec_2
   \   000069   740E         MOV     A,#0xe
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_495:
   \   000071   8983         MOV     DPH,R1
   \   000073   8882         MOV     DPL,R0
   \   000075   740A         MOV     A,#0xa
   \   000077   12....       LCALL   ?MOVE_LONG8_XDATA_CODE
   \   00007A   7901         MOV     R1,#0x1
   \   00007C   8002         SJMP    ??zclFindAttrRec_6
   2369          		}
   2370          	}
   2371          	return ( FALSE );
   \                     ??zclFindAttrRec_0:
   \   00007E   7900         MOV     R1,#0x0
   \                     ??zclFindAttrRec_6:
   \   000080   02....       LJMP    ?Subroutine3 & 0xFFFF
   2372          }
   2373          
   2374          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   2375          /*********************************************************************
   2376           * @fn      zclGetReadWriteCB
   2377           *
   2378           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   2379           *
   2380           * @param   endpoint - Application's endpoint
   2381           *
   2382           * @return  Read/Write CB, NULL if not found
   2383           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2384          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   2385          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2386            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2387          
   2388            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetReadWriteCB_0
   2389            {
   2390              return ( pRec->pfnReadWriteCB );
   \   000012   12....       LCALL   ??Subroutine184_0 & 0xFFFF
   2391            }
   \                     ??CrossCallReturnLabel_348:
   \   000015   8004         SJMP    ??zclGetReadWriteCB_1
   2392          
   2393            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetReadWriteCB_1:
   \   00001B   80..         SJMP    ?Subroutine2
   2394          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine185_0
   \   000003                ; // Fall through to label ??Subroutine185_0
   2395          
   2396          /*********************************************************************
   2397           * @fn      zclGetAuthorizeCB
   2398           *
   2399           * @brief   Get the Read/Write Authorization callback function pointer
   2400           *          for a given endpoint.
   2401           *
   2402           * @param   endpoint - Application's endpoint
   2403           *
   2404           * @return  Authorization CB, NULL if not found
   2405           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2406          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   2407          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2408            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000005                ; Setup parameters for call to function zclFindAttrRecsList
   \   000005   12....       LCALL   ??zclFindAttrRecsList?relay; Banked call to: zclFindAttrRecsList
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2409          
   2410            if ( pRec != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6005         JZ      ??zclGetAuthorizeCB_0
   2411            {
   2412              return ( pRec->pfnAuthorizeCB );
   \   000012   12....       LCALL   ?Subroutine90 & 0xFFFF
   2413            }
   \                     ??CrossCallReturnLabel_351:
   \   000015   8004         SJMP    ??zclGetAuthorizeCB_1
   2414          
   2415            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000017   7A00         MOV     R2,#0x0
   \   000019   7B00         MOV     R3,#0x0
   \                     ??zclGetAuthorizeCB_1:
   \   00001B                REQUIRE ?Subroutine2
   \   00001B                ; // Fall through to label ?Subroutine2
   2416          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine183_0
   \   000001                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine184_0
   \   000001                ; // Fall through to label ??Subroutine184_0
   2417          #endif // ZCL_READ || ZCL_WRITE
   2418          
   2419          /*********************************************************************
   2420           * @fn      zclFindClusterOption
   2421           *
   2422           * @brief   Find the option record that matchs the cluster id
   2423           *
   2424           * @param   endpoint - Application's endpoint
   2425           * @param   clusterID - cluster ID looking for
   2426           *
   2427           * @return  pointer to clutser option, NULL if not found
   2428           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2429          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2430          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2431            zclClusterOptionList *pLoop;
   2432          
   2433            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   8004         SJMP    ??zclFindClusterOption_0
   2434            while ( pLoop != NULL )
   2435            {
   2436              if ( pLoop->endpoint == endpoint )
   2437              {
   2438                uint8 x;
   2439                for ( x = 0; x < pLoop->numOptions; x++ )
   2440                {
   2441                  if ( pLoop->options[x].clusterID == clusterID )
   2442                  {
   2443                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2444                  }
   2445                }
   2446              }
   2447          
   2448              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   000017   6047         JZ      ??zclFindClusterOption_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   70ED         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0,#0x0
   \   000026   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000028   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   E5..         MOV     A,?V0
   \   000035   C3           CLR     C
   \   000036   9A           SUBB    A,R2
   \   000037   50D7         JNC     ??zclFindClusterOption_1
   \   000039   E5..         MOV     A,?V0
   \   00003B   75F003       MOV     B,#0x3
   \   00003E   A4           MUL     AB
   \   00003F   FA           MOV     R2,A
   \   000040   ABF0         MOV     R3,B
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   3B           ADDC    A,R3
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6C           XRL     A,R4
   \   000057   7003         JNZ     ??zclFindClusterOption_5
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6D           XRL     A,R5
   \                     ??zclFindClusterOption_5:
   \   00005C   70CA         JNZ     ??zclFindClusterOption_4
   \   00005E   8004         SJMP    ??zclFindClusterOption_6
   2449            }
   2450          
   2451            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000064   02....       LJMP    ?Subroutine8 & 0xFFFF
   2452          }
   2453          
   2454          /*********************************************************************
   2455           * @fn      zclGetClusterOption
   2456           *
   2457           * @brief   Get the option record that matchs the cluster id
   2458           *
   2459           * @param   endpoint - Application's endpoint
   2460           * @param   clusterID - cluster ID looking for
   2461           *
   2462           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2463           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2464          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2465          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2466            uint8 option;
   2467            zclOptionRec_t *pOption;
   2468          
   2469            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2470            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6008         JZ      ??zclGetClusterOption_0
   2471            {
   2472              option = pOption->option;
   2473              if ( !ZG_SECURE_ENABLED )
   2474              {
   2475                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2476              }
   2477          
   2478              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   54BF         ANL     A,#0xbf
   \   000017   F9           MOV     R1,A
   \   000018   8002         SJMP    ??zclGetClusterOption_1
   2479            }
   2480          
   2481            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001C   02....       LJMP    ?Subroutine2 & 0xFFFF
   2482          }
   2483          
   2484          /*********************************************************************
   2485           * @fn      zclSetSecurityOption
   2486           *
   2487           * @brief   Set the security option for the cluster id
   2488           *
   2489           * @param   endpoint - Application's endpoint
   2490           * @param   clusterID - cluster ID looking for
   2491           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2492           *
   2493           * @return  none
   2494           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2495          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2496          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2497            zclOptionRec_t *pOption;
   2498          
   2499            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2500            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2501            {
   2502              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2503              {
   2504                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2505              }
   2506              else
   2507              {
   2508                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2509              }
   2510            }
   2511          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   02....       LJMP    ?Subroutine2 & 0xFFFF
   2512          
   2513          #ifdef ZCL_DISCOVER
   2514          /*********************************************************************
   2515           * @fn      zclFindNextCmdRec
   2516           *
   2517           * @brief   Find the command (or next) record that matchs the parameters
   2518           *
   2519           * @param   endpoint - Application's endpoint
   2520           * @param   clusterID - cluster ID
   2521           * @param   commandID - command ID from requesting command
   2522           * @param   direction- direction of received command
   2523           * @param   pCmdID - command looking for
   2524           * @param   pCmd - command information within command record list
   2525           *
   2526           * @return  pointer to command record, NULL no more records of this cluster
   2527           */
   2528          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2529                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2530          {
   2531            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2532            uint8 i;
   2533          
   2534            if ( pRec != NULL )
   2535            {
   2536              for ( i = 0; i < pRec->numCommands; i++ )
   2537              {
   2538                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2539                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2540                {
   2541                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2542                  {
   2543                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2544                    {
   2545                      *pCmd = pRec->pCmdRecs[i];
   2546          
   2547                      // Update command ID
   2548                      *pCmdID = pCmd->cmdID;
   2549          
   2550                      return ( TRUE ); // EMBEDDED RETURN
   2551                    }
   2552                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2553                    {
   2554                      *pCmd = pRec->pCmdRecs[i];
   2555          
   2556                      // Update command ID
   2557                      *pCmdID = pCmd->cmdID;
   2558          
   2559                      return ( TRUE ); // EMBEDDED RETURN
   2560                    }
   2561                  }
   2562                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2563                  {
   2564                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2565                    {
   2566                      *pCmd = pRec->pCmdRecs[i];
   2567          
   2568                      // Update command ID
   2569                      *pCmdID = pCmd->cmdID;
   2570          
   2571                      return ( TRUE ); // EMBEDDED RETURN
   2572                    }
   2573                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2574                    {
   2575                      *pCmd = pRec->pCmdRecs[i];
   2576          
   2577                      // Update command ID
   2578                      *pCmdID = pCmd->cmdID;
   2579          
   2580                      return ( TRUE ); // EMBEDDED RETURN
   2581                    }
   2582                  }
   2583                  else
   2584                  {
   2585                    return ( FALSE ); // Incorrect Command ID
   2586                  }
   2587                }
   2588              }
   2589            }
   2590          
   2591            return ( FALSE );
   2592          }
   2593          
   2594          /*********************************************************************
   2595           * @fn      zclFindNextAttrRec
   2596           *
   2597           * @brief   Find the attribute (or next) record that matchs the parameters
   2598           *
   2599           * @param   endpoint - Application's endpoint
   2600           * @param   clusterID - cluster ID
   2601           * @param   attr - attribute looking for
   2602           *
   2603           * @return  pointer to attribute record, NULL if not found
   2604           */
   2605          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2606                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2607          {
   2608            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2609            uint8 attrDir;
   2610          
   2611            if ( pRec != NULL )
   2612            {
   2613              uint16 x;
   2614          
   2615              for ( x = 0; x < pRec->numAttributes; x++ )
   2616              {
   2617                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2618                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2619                {
   2620                  // also make sure direction is right
   2621                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2622                  if ( attrDir == direction )
   2623                  {
   2624                    // return attribute and found attribute ID
   2625                    *pAttr = pRec->attrs[x];
   2626                    *attrId = pAttr->attr.attrId;
   2627          
   2628                    return ( TRUE ); // EMBEDDED RETURN
   2629                  }
   2630                }
   2631              }
   2632            }
   2633          
   2634            return ( FALSE );
   2635          }
   2636          #endif // ZCL_DISCOVER
   2637          
   2638          /*********************************************************************
   2639           * @fn      zclSerializeData
   2640           *
   2641           * @brief   Builds a buffer from the attribute data to sent out over
   2642           *          the air.
   2643           *          NOTE - Not compatible with application's attributes callbacks.
   2644           *
   2645           * @param   dataType - data types defined in zcl.h
   2646           * @param   attrData - pointer to the attribute data
   2647           * @param   buf - where to put the serialized data
   2648           *
   2649           * @return  pointer to end of destination buffer
   2650           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2651          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2652          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V4,R2
   \   000009   8B..         MOV     ?V5,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   2653            uint8 *pStr;
   2654            uint16 len;
   2655          
   2656            if ( attrData == NULL )
   \   00000F   E5..         MOV     A,?V4
   \   000011   45..         ORL     A,?V5
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2657            {
   2658              return ( buf );
   2659            }
   2660          
   2661            switch ( dataType )
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   A3           INC     DPTR
   \   00001D   AC82         MOV     R4,DPL
   \   00001F   AD83         MOV     R5,DPH
   \   000021   85....       MOV     ?V0,?V4
   \   000024   85....       MOV     ?V1,?V5
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   EE           MOV     A,R6
   \   00002B   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   00002E   04           DB        4
   \   00002F   41           DB        65
   \   000030   42           DB        66
   \   000031   ....         DW        ??zclSerializeData_1
   \   000033   43           DB        67
   \   000034   44           DB        68
   \   000035   ....         DW        ??zclSerializeData_2
   \   000037   E0           DB        224
   \   000038   E2           DB        226
   \   000039   ....         DW        ??zclSerializeData_3
   \   00003B   E8           DB        232
   \   00003C   E9           DB        233
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   1A           DB        26
   \   000040   08           DB        8
   \   000041   ....         DW        ??zclSerializeData_5
   \   000043   09           DB        9
   \   000044   ....         DW        ??zclSerializeData_4
   \   000046   0A           DB        10
   \   000047   ....         DW        ??zclSerializeData_6
   \   000049   0B           DB        11
   \   00004A   ....         DW        ??zclSerializeData_3
   \   00004C   10           DB        16
   \   00004D   ....         DW        ??zclSerializeData_5
   \   00004F   18           DB        24
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   19           DB        25
   \   000053   ....         DW        ??zclSerializeData_4
   \   000055   1A           DB        26
   \   000056   ....         DW        ??zclSerializeData_6
   \   000058   1B           DB        27
   \   000059   ....         DW        ??zclSerializeData_3
   \   00005B   20           DB        32
   \   00005C   ....         DW        ??zclSerializeData_5
   \   00005E   21           DB        33
   \   00005F   ....         DW        ??zclSerializeData_4
   \   000061   22           DB        34
   \   000062   ....         DW        ??zclSerializeData_6
   \   000064   23           DB        35
   \   000065   ....         DW        ??zclSerializeData_3
   \   000067   24           DB        36
   \   000068   ....         DW        ??zclSerializeData_7
   \   00006A   25           DB        37
   \   00006B   ....         DW        ??zclSerializeData_8
   \   00006D   28           DB        40
   \   00006E   ....         DW        ??zclSerializeData_5
   \   000070   29           DB        41
   \   000071   ....         DW        ??zclSerializeData_4
   \   000073   2A           DB        42
   \   000074   ....         DW        ??zclSerializeData_6
   \   000076   2B           DB        43
   \   000077   ....         DW        ??zclSerializeData_3
   \   000079   30           DB        48
   \   00007A   ....         DW        ??zclSerializeData_5
   \   00007C   31           DB        49
   \   00007D   ....         DW        ??zclSerializeData_4
   \   00007F   38           DB        56
   \   000080   ....         DW        ??zclSerializeData_4
   \   000082   39           DB        57
   \   000083   ....         DW        ??zclSerializeData_3
   \   000085   EA           DB        234
   \   000086   ....         DW        ??zclSerializeData_3
   \   000088   F0           DB        240
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   F1           DB        241
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   ....         DW        ??zclSerializeData_0
   2662            {
   2663              case ZCL_DATATYPE_DATA8:
   2664              case ZCL_DATATYPE_BOOLEAN:
   2665              case ZCL_DATATYPE_BITMAP8:
   2666              case ZCL_DATATYPE_INT8:
   2667              case ZCL_DATATYPE_UINT8:
   2668              case ZCL_DATATYPE_ENUM8:
   2669                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   000090   85..82       MOV     DPL,?V4
   \   000093   85..83       MOV     DPH,?V5
   \   000096   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   000099   EC           MOV     A,R4
   \   00009A   FA           MOV     R2,A
   \   00009B   ED           MOV     A,R5
   \   00009C   FB           MOV     R3,A
   2670                 break;
   \   00009D   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2671          
   2672              case ZCL_DATATYPE_DATA16:
   2673              case ZCL_DATATYPE_BITMAP16:
   2674              case ZCL_DATATYPE_UINT16:
   2675              case ZCL_DATATYPE_INT16:
   2676              case ZCL_DATATYPE_ENUM16:
   2677              case ZCL_DATATYPE_SEMI_PREC:
   2678              case ZCL_DATATYPE_CLUSTER_ID:
   2679              case ZCL_DATATYPE_ATTR_ID:
   2680                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000A0   85..82       MOV     DPL,?V4
   \   0000A3   85..83       MOV     DPH,?V5
   \   0000A6   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_423:
   \   0000A9   12....       LCALL   ?Subroutine32 & 0xFFFF
   2681                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_28:
   \   0000AC   A3           INC     DPTR
   \   0000AD   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_424:
   \   0000B0   8036         SJMP    ??zclSerializeData_11
   2682                break;
   2683          
   2684              case ZCL_DATATYPE_DATA24:
   2685              case ZCL_DATATYPE_BITMAP24:
   2686              case ZCL_DATATYPE_UINT24:
   2687              case ZCL_DATATYPE_INT24:
   2688                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000B2   85..82       MOV     DPL,?V4
   \   0000B5   85..83       MOV     DPH,?V5
   \   0000B8   78..         MOV     R0,#?V0
   \   0000BA   12....       LCALL   ?L_MOV_X
   \   0000BD   8A82         MOV     DPL,R2
   \   0000BF   8B83         MOV     DPH,R3
   \   0000C1   E5..         MOV     A,?V0
   \   0000C3   12....       LCALL   ?Subroutine32 & 0xFFFF
   2689                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_29:
   \   0000C6   78..         MOV     R0,#?V0
   \   0000C8   12....       LCALL   ?L_MOV_X
   \   0000CB   E5..         MOV     A,?V1
   \   0000CD   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   2690                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_287:
   \   0000D0   85..82       MOV     DPL,?V4
   \   0000D3   85..83       MOV     DPH,?V5
   \   0000D6   78..         MOV     R0,#?V0
   \   0000D8   12....       LCALL   ?L_MOV_X
   \   0000DB   7410         MOV     A,#0x10
   \   0000DD   78..         MOV     R0,#?V0
   \   0000DF   12....       LCALL   ?UL_SHR
   \   0000E2   8A82         MOV     DPL,R2
   \   0000E4   8B83         MOV     DPH,R3
   \   0000E6   E5..         MOV     A,?V0
   \                     ??zclSerializeData_11:
   \   0000E8   12....       LCALL   ??Subroutine172_0 & 0xFFFF
   2691                break;
   \                     ??CrossCallReturnLabel_286:
   \   0000EB   8067         SJMP    ??zclSerializeData_0
   2692          
   2693              case ZCL_DATATYPE_DATA32:
   2694              case ZCL_DATATYPE_BITMAP32:
   2695              case ZCL_DATATYPE_UINT32:
   2696              case ZCL_DATATYPE_INT32:
   2697              case ZCL_DATATYPE_SINGLE_PREC:
   2698              case ZCL_DATATYPE_TOD:
   2699              case ZCL_DATATYPE_DATE:
   2700              case ZCL_DATATYPE_UTC:
   2701              case ZCL_DATATYPE_BAC_OID:
   2702                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000ED                ; Setup parameters for call to function osal_buffer_uint32
   \   0000ED   85..82       MOV     DPL,?V4
   \   0000F0   85..83       MOV     DPH,?V5
   \   0000F3   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000F6   12....       LCALL   ??osal_buffer_uint32?relay; Banked call to: osal_buffer_uint32
   \   0000F9   7404         MOV     A,#0x4
   \   0000FB   12....       LCALL   ?DEALLOC_XSTACK8
   2703                break;
   \   0000FE   8054         SJMP    ??zclSerializeData_0
   2704          
   2705              case ZCL_DATATYPE_UINT40:
   2706                pStr = (uint8*)attrData;
   2707                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000100                ; Setup parameters for call to function osal_memcpy
   \   000100   78..         MOV     R0,#?V0
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000105   7C05         MOV     R4,#0x5
   \   000107   8041         SJMP    ??zclSerializeData_12
   2708                break;
   2709          
   2710              case ZCL_DATATYPE_UINT48:
   2711                pStr = (uint8*)attrData;
   2712                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   000109                ; Setup parameters for call to function osal_memcpy
   \   000109   78..         MOV     R0,#?V0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00010E   7C06         MOV     R4,#0x6
   \   000110   8038         SJMP    ??zclSerializeData_12
   2713                break;
   2714          
   2715              case ZCL_DATATYPE_IEEE_ADDR:
   2716                pStr = (uint8*)attrData;
   2717                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   000112                ; Setup parameters for call to function osal_memcpy
   \   000112   78..         MOV     R0,#?V0
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000117   7C08         MOV     R4,#0x8
   \   000119   802F         SJMP    ??zclSerializeData_12
   2718                break;
   2719          
   2720              case ZCL_DATATYPE_CHAR_STR:
   2721              case ZCL_DATATYPE_OCTET_STR:
   2722                pStr = (uint8*)attrData;
   2723                len = *pStr;
   2724                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   00011B                ; Setup parameters for call to function osal_memcpy
   \   00011B   78..         MOV     R0,#?V0
   \   00011D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000120   85..82       MOV     DPL,?V4
   \   000123   85..83       MOV     DPH,?V5
   \   000126   E0           MOVX    A,@DPTR
   \   000127   2401         ADD     A,#0x1
   \   000129   FC           MOV     R4,A
   \   00012A   E4           CLR     A
   \   00012B   3400         ADDC    A,#0x0
   \   00012D   8011         SJMP    ??zclSerializeData_13
   2725                break;
   2726          
   2727              case ZCL_DATATYPE_LONG_CHAR_STR:
   2728              case ZCL_DATATYPE_LONG_OCTET_STR:
   2729                pStr = (uint8*)attrData;
   2730                len = BUILD_UINT16( pStr[0], pStr[1] );
   2731                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   85..82       MOV     DPL,?V4
   \   000137   85..83       MOV     DPH,?V5
   \   00013A   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00013D   FC           MOV     R4,A
   \   00013E   E4           CLR     A
   \   00013F   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000140   FD           MOV     R5,A
   \   000141   8009         SJMP    ??zclSerializeData_14
   2732                break;
   2733          
   2734              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2735                pStr = (uint8*)attrData;
   2736                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   000143                ; Setup parameters for call to function osal_memcpy
   \   000143   78..         MOV     R0,#?V0
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000148   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   00014A   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   00014C   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00014F   7403         MOV     A,#0x3
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   2737                break;
   2738          
   2739              case ZCL_DATATYPE_NO_DATA:
   2740              case ZCL_DATATYPE_UNKNOWN:
   2741                // Fall through
   2742          
   2743              default:
   2744                break;
   2745            }
   2746          
   2747            return ( buf );
   \                     ??zclSerializeData_0:
   \   000154   02....       LJMP    ?Subroutine3 & 0xFFFF
   2748          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V4
   \   000008   85..83       MOV     DPH,?V5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   12....       LCALL   ?Subroutine163 & 0xFFFF
   \                     ??CrossCallReturnLabel_518:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   2749          
   2750          #ifdef ZCL_REPORT
   2751          /*********************************************************************
   2752           * @fn      zclAnalogDataType
   2753           *
   2754           * @brief   Checks to see if Data Type is Analog
   2755           *
   2756           * @param   dataType - data type
   2757           *
   2758           * @return  TRUE if data type is analog
   2759           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2760          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2761          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2762            uint8 analog;
   2763          
   2764            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2765            {
   2766              case ZCL_DATATYPE_UINT8:
   2767              case ZCL_DATATYPE_UINT16:
   2768              case ZCL_DATATYPE_UINT24:
   2769              case ZCL_DATATYPE_UINT32:
   2770              case ZCL_DATATYPE_UINT40:
   2771              case ZCL_DATATYPE_UINT48:
   2772              case ZCL_DATATYPE_UINT56:
   2773              case ZCL_DATATYPE_UINT64:
   2774              case ZCL_DATATYPE_INT8:
   2775              case ZCL_DATATYPE_INT16:
   2776              case ZCL_DATATYPE_INT24:
   2777              case ZCL_DATATYPE_INT32:
   2778              case ZCL_DATATYPE_INT40:
   2779              case ZCL_DATATYPE_INT48:
   2780              case ZCL_DATATYPE_INT56:
   2781              case ZCL_DATATYPE_INT64:
   2782              case ZCL_DATATYPE_SEMI_PREC:
   2783              case ZCL_DATATYPE_SINGLE_PREC:
   2784              case ZCL_DATATYPE_DOUBLE_PREC:
   2785              case ZCL_DATATYPE_TOD:
   2786              case ZCL_DATATYPE_DATE:
   2787              case ZCL_DATATYPE_UTC:
   2788                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2789                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2790          
   2791              default:
   2792                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2793                break;
   2794            }
   2795          
   2796            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2797          }
   2798          
   2799          /*********************************************************************
   2800           * @fn      zclIsLittleEndianMachine
   2801           *
   2802           * @brief   Verifies endianness in system.
   2803           *
   2804           * @param   none
   2805           *
   2806           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2807           */
   2808          static int zclIsLittleEndianMachine(void)
   2809          {
   2810            uint16 test = 0x0001;
   2811          
   2812            return (*((uint8 *)(&test)));
   2813          }
   2814          
   2815          /*********************************************************************
   2816           * @fn      zcl_BuildAnalogData
   2817           *
   2818           * @brief   Build an analog arribute out of sequential bytes.
   2819           *
   2820           * @param   dataType - type of data
   2821           * @param   pData - pointer to data
   2822           * @param   pBuf - where to put the data
   2823           *
   2824           * @return  none
   2825           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2826          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     zcl_BuildAnalogData:
   2827          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   2828            int current_byte_index;
   2829            int remaining_bytes;
   2830            int step;
   2831          
   2832            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   2833          
   2834            // decide if move forward or backwards to copy data
   2835            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   000023   600C         JZ      ??zcl_BuildAnalogData_0
   2836            {
   2837              step = 1;
   \   000025   75..01       MOV     ?V4,#0x1
   \   000028   75..00       MOV     ?V5,#0x0
   2838              current_byte_index = 0;
   \   00002B   7800         MOV     R0,#0x0
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   8038         SJMP    ??zcl_BuildAnalogData_1
   2839            }
   2840            else
   2841            {
   2842              step = -1;
   \                     ??zcl_BuildAnalogData_0:
   \   000031   75..FF       MOV     ?V4,#-0x1
   \   000034   75..FF       MOV     ?V5,#-0x1
   2843              current_byte_index = remaining_bytes - 1;
   \   000037   EA           MOV     A,R2
   \   000038   24FF         ADD     A,#-0x1
   \   00003A   F8           MOV     R0,A
   \   00003B   EB           MOV     A,R3
   \   00003C   34FF         ADDC    A,#-0x1
   \   00003E   8028         SJMP    ??zcl_BuildAnalogData_2
   2844            }
   2845          
   2846            while ( remaining_bytes-- )
   2847            {
   2848              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_3:
   \   000040   85..82       MOV     DPL,?V0
   \   000043   85..83       MOV     DPH,?V1
   \   000046   E0           MOVX    A,@DPTR
   \   000047   C0E0         PUSH    A
   \   000049   EE           MOV     A,R6
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   EF           MOV     A,R7
   \   00004E   39           ADDC    A,R1
   \   00004F   F583         MOV     DPH,A
   \   000051   D0E0         POP     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   85..82       MOV     DPL,?V0
   \   000057   85..83       MOV     DPH,?V1
   \   00005A   A3           INC     DPTR
   \   00005B   8582..       MOV     ?V0,DPL
   \   00005E   8583..       MOV     ?V1,DPH
   2849              current_byte_index += step;
   \   000061   E8           MOV     A,R0
   \   000062   25..         ADD     A,?V4
   \   000064   F8           MOV     R0,A
   \   000065   E9           MOV     A,R1
   \   000066   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_2:
   \   000068   F9           MOV     R1,A
   2850            }
   \                     ??zcl_BuildAnalogData_1:
   \   000069   EA           MOV     A,R2
   \   00006A   FC           MOV     R4,A
   \   00006B   EB           MOV     A,R3
   \   00006C   FD           MOV     R5,A
   \   00006D   EC           MOV     A,R4
   \   00006E   24FF         ADD     A,#-0x1
   \   000070   1A           DEC     R2
   \   000071   ED           MOV     A,R5
   \   000072   34FF         ADDC    A,#-0x1
   \   000074   FB           MOV     R3,A
   \   000075   EC           MOV     A,R4
   \   000076   4D           ORL     A,R5
   \   000077   70C7         JNZ     ??zcl_BuildAnalogData_3
   2851          }
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007E                REQUIRE ?Subroutine3
   \   00007E                ; // Fall through to label ?Subroutine3

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
   2852          #endif // ZCL_REPORT
   2853          
   2854          /*********************************************************************
   2855           * @fn      zclGetDataTypeLength
   2856           *
   2857           * @brief   Return the length of the datatype in octet.
   2858           *
   2859           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2860           *                ZCL_DATATYPE_CHAR_STR data types.
   2861           *
   2862           * @param   dataType - data type
   2863           *
   2864           * @return  length of data
   2865           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2866          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2867          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   2868            uint8 len;
   2869          
   2870            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   2871            {
   2872              case ZCL_DATATYPE_DATA8:
   2873              case ZCL_DATATYPE_BOOLEAN:
   2874              case ZCL_DATATYPE_BITMAP8:
   2875              case ZCL_DATATYPE_INT8:
   2876              case ZCL_DATATYPE_UINT8:
   2877              case ZCL_DATATYPE_ENUM8:
   2878                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   2879                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   2880          
   2881              case ZCL_DATATYPE_DATA16:
   2882              case ZCL_DATATYPE_BITMAP16:
   2883              case ZCL_DATATYPE_UINT16:
   2884              case ZCL_DATATYPE_INT16:
   2885              case ZCL_DATATYPE_ENUM16:
   2886              case ZCL_DATATYPE_SEMI_PREC:
   2887              case ZCL_DATATYPE_CLUSTER_ID:
   2888              case ZCL_DATATYPE_ATTR_ID:
   2889                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   2890                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   2891          
   2892              case ZCL_DATATYPE_DATA24:
   2893              case ZCL_DATATYPE_BITMAP24:
   2894              case ZCL_DATATYPE_UINT24:
   2895              case ZCL_DATATYPE_INT24:
   2896                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   2897                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   2898          
   2899              case ZCL_DATATYPE_DATA32:
   2900              case ZCL_DATATYPE_BITMAP32:
   2901              case ZCL_DATATYPE_UINT32:
   2902              case ZCL_DATATYPE_INT32:
   2903              case ZCL_DATATYPE_SINGLE_PREC:
   2904              case ZCL_DATATYPE_TOD:
   2905              case ZCL_DATATYPE_DATE:
   2906              case ZCL_DATATYPE_UTC:
   2907              case ZCL_DATATYPE_BAC_OID:
   2908                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   2909                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   2910          
   2911             case ZCL_DATATYPE_UINT40:
   2912             case ZCL_DATATYPE_INT40:
   2913                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   2914                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   2915          
   2916             case ZCL_DATATYPE_UINT48:
   2917             case ZCL_DATATYPE_INT48:
   2918                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   2919                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   2920          
   2921             case ZCL_DATATYPE_UINT56:
   2922             case ZCL_DATATYPE_INT56:
   2923                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   2924                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   2925          
   2926             case ZCL_DATATYPE_DOUBLE_PREC:
   2927             case ZCL_DATATYPE_IEEE_ADDR:
   2928             case ZCL_DATATYPE_UINT64:
   2929             case ZCL_DATATYPE_INT64:
   2930               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   2931               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   2932          
   2933              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2934               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   2935               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   2936          
   2937              case ZCL_DATATYPE_NO_DATA:
   2938              case ZCL_DATATYPE_UNKNOWN:
   2939                // Fall through
   2940          
   2941              default:
   2942                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   2943                break;
   2944            }
   2945          
   2946            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   2947          }
   2948          
   2949          /*********************************************************************
   2950           * @fn      zclGetAttrDataLength
   2951           *
   2952           * @brief   Return the length of the attribute.
   2953           *
   2954           * @param   dataType - data type
   2955           * @param   pData - pointer to data
   2956           *
   2957           * @return  returns atrribute length
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2960          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2961            uint16 dataLen = 0;
   2962          
   2963            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   2964            {
   2965              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine105 & 0xFFFF
   2966            }
   \                     ??CrossCallReturnLabel_173:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   2967            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   2968            {
   2969              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   2970            }
   2971            else
   2972            {
   2973              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   2974            }
   2975          
   2976            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ?Subroutine8 & 0xFFFF
   2977          }
   2978          
   2979          #ifdef ZCL_READ
   2980          /*********************************************************************
   2981           * @fn      zclReadAttrData
   2982           *
   2983           * @brief   Read the attribute's current value into pAttrData.
   2984           *          NOTE - Not compatible with application's attributes callbacks.
   2985           *
   2986           * @param   pAttrData - where to put attribute data
   2987           * @param   pAttr - pointer to attribute
   2988           * @param   pDataLen - where to put attribute data length
   2989           *
   2990           * @return Success
   2991           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2992          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2993          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2994            uint16 dataLen;
   2995          
   2996            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   2997            {
   2998              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   2999            }
   3000          
   3001            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   3002            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine177_0 & 0xFFFF
   3003          
   3004            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_306:
   \   000062   6007         JZ      ??zclReadAttrData_2
   3005            {
   3006              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   3007            }
   3008          
   3009            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D                REQUIRE ?Subroutine9
   \   00006D                ; // Fall through to label ?Subroutine9
   3010          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7F07         MOV     R7,#0x7
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   3011          
   3012          /*********************************************************************
   3013           * @fn      zcl_ReadAttrData
   3014           *
   3015           * @brief   Read the attribute's current value into pAttrData.
   3016           *          Use application's callback function if assigned to this attribute.
   3017           *
   3018           * @param   endpoint - application's endpoint
   3019           * @param   clusterId - cluster that attribute belongs to
   3020           * @param   attrId - attribute id
   3021           * @param   pAttrData - where to put attribute data
   3022           * @param   pDataLen - where to put attribute data length
   3023           *
   3024           * @return  Successful if data was read
   3025           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3026          ZStatus_t zcl_ReadAttrData( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zcl_ReadAttrData:
   3027                                                   uint8 *pAttrData, uint16 *pDataLen )
   3028          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V2,R1
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   \   000010   EC           MOV     A,R4
   \   000011   FE           MOV     R6,A
   \   000012   ED           MOV     A,R5
   \   000013   FF           MOV     R7,A
   3029            zclAttrRec_t attrRec;
   3030          
   3031            if ( zclFindAttrRec( endpoint, clusterId, attrId, &attrRec ) == FALSE )
   \   000014                ; Setup parameters for call to function zclFindAttrRec
   \   000014   A8..         MOV     R0,?XSP + 0
   \   000016   A9..         MOV     R1,?XSP + 1
   \   000018   88..         MOV     ?V4,R0
   \   00001A   89..         MOV     ?V5,R1
   \   00001C   78..         MOV     R0,#?V4
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   A9..         MOV     R1,?V2
   \   000023   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002B   E9           MOV     A,R1
   \   00002C   7004         JNZ     ??zcl_ReadAttrData_0
   3032            {
   3033              return ( ZCL_STATUS_FAILURE );
   \   00002E   7901         MOV     R1,#0x1
   \   000030   804C         SJMP    ??zcl_ReadAttrData_1
   3034            }
   \                     ??zcl_ReadAttrData_0:
   \   000032   741A         MOV     A,#0x1a
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   00003A   741C         MOV     A,#0x1c
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ?Subroutine92 & 0xFFFF
   3035          
   3036            if ( attrRec.attr.dataPtr != NULL )
   \                     ??CrossCallReturnLabel_149:
   \   000042   7406         MOV     A,#0x6
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   00004A   78..         MOV     R0,#?V4
   \   00004C   6016         JZ      ??zcl_ReadAttrData_2
   3037            {
   3038              return zclReadAttrData( pAttrData, &attrRec, pDataLen );
   \   00004E                ; Setup parameters for call to function zclReadAttrData
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP102_8
   \   000056   AA..         MOV     R2,?V6
   \   000058   AB..         MOV     R3,?V7
   \   00005A   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000062   801A         SJMP    ??zcl_ReadAttrData_1
   3039            }
   3040            else
   3041            {
   3042              return zclReadAttrDataUsingCB( endpoint, clusterId, attrId, pAttrData, pDataLen );
   \                     ??zcl_ReadAttrData_2:
   \   000064                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   78..         MOV     R0,#?V6
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006C   EE           MOV     A,R6
   \   00006D   FC           MOV     R4,A
   \   00006E   EF           MOV     A,R7
   \   00006F   FD           MOV     R5,A
   \   000070   AA..         MOV     R2,?V0
   \   000072   AB..         MOV     R3,?V1
   \   000074   A9..         MOV     R1,?V2
   \   000076   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   000079   7404         MOV     A,#0x4
   \   00007B   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zcl_ReadAttrData_1:
   \   00007E   740A         MOV     A,#0xa
   3043            }
   \   000080   02....       LJMP    ?Subroutine7 & 0xFFFF
   3044          }
   3045          
   3046          /*********************************************************************
   3047           * @fn      zclGetAttrDataLengthUsingCB
   3048           *
   3049           * @brief   Use application's callback to get the length of the attribute's
   3050           *          current value stored in the database.
   3051           *
   3052           * @param   endpoint - application's endpoint
   3053           * @param   clusterId - cluster that attribute belongs to
   3054           * @param   attrId - attribute id
   3055           *
   3056           * @return  returns attribute length
   3057           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3058          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   3059          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   3060            uint16 dataLen = 0;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   E4           CLR     A
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   F0           MOVX    @DPTR,A
   3061            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001C                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001C   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   00001F   8A..         MOV     ?V0,R2
   \   000021   8B..         MOV     ?V1,R3
   3062          
   3063            if ( pfnReadWriteCB != NULL )
   \   000023   EA           MOV     A,R2
   \   000024   45..         ORL     A,?V1
   \   000026   602F         JZ      ??zclGetAttrDataLengthUsingCB_0
   3064            {
   3065              // Only get the attribute length
   3066              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000028                ; Setup parameters for indirect call
   \   000028   A8..         MOV     R0,?XSP + 0
   \   00002A   A9..         MOV     R1,?XSP + 1
   \   00002C   88..         MOV     ?V6,R0
   \   00002E   89..         MOV     ?V7,R1
   \   000030   78..         MOV     R0,#?V6
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   E4           CLR     A
   \   000036   F5..         MOV     ?V6,A
   \   000038   F5..         MOV     ?V7,A
   \   00003A   78..         MOV     R0,#?V6
   \   00003C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003F   7900         MOV     R1,#0x0
   \   000041   EE           MOV     A,R6
   \   000042   FC           MOV     R4,A
   \   000043   EF           MOV     A,R7
   \   000044   FD           MOV     R5,A
   \   000045   AA..         MOV     R2,?V4
   \   000047   AB..         MOV     R3,?V5
   \   000049   85..82       MOV     DPL,?V0
   \   00004C   85..83       MOV     DPH,?V1
   \   00004F   12....       LCALL   ?CALL_IND
   \   000052   7404         MOV     A,#0x4
   \   000054   12....       LCALL   ?DEALLOC_XSTACK8
   3067            }
   3068          
   3069            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   000060   7402         MOV     A,#0x2
   \   000062                REQUIRE ?Subroutine7
   \   000062                ; // Fall through to label ?Subroutine7
   3070          }
   3071          
   3072          /*********************************************************************
   3073           * @fn      zclReadAttrDataUsingCB
   3074           *
   3075           * @brief   Use application's callback to read the attribute's current
   3076           *          value stored in the database.
   3077           *
   3078           * @param   endpoint - application's endpoint
   3079           * @param   clusterId - cluster that attribute belongs to
   3080           * @param   attrId - attribute id
   3081           * @param   pAttrData - where to put attribute data
   3082           * @param   pDataLen - where to put attribute data length
   3083           *
   3084           * @return  Successful if data was read
   3085           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3086          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   3087                                                   uint8 *pAttrData, uint16 *pDataLen )
   3088          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   3089            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000D                ; Setup parameters for call to function zclGetReadWriteCB
   \   00000D   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   7412         MOV     A,#0x12
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   3090          
   3091            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_337:
   \   00001C   E5..         MOV     A,?V6
   \   00001E   45..         ORL     A,?V7
   \   000020   600A         JZ      ??zclReadAttrDataUsingCB_0
   3092            {
   3093              *pDataLen = 0; // Always initialize it to 0
   \   000022   85..82       MOV     DPL,?V6
   \   000025   85..83       MOV     DPH,?V7
   \   000028   E4           CLR     A
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   F0           MOVX    @DPTR,A
   3094            }
   3095          
   3096            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00002C   EA           MOV     A,R2
   \   00002D   45..         ORL     A,?V3
   \   00002F   6027         JZ      ??zclReadAttrDataUsingCB_1
   3097            {
   3098              // Read the attribute value and its length
   3099              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000031                ; Setup parameters for indirect call
   \   000031   78..         MOV     R0,#?V6
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000036   7412         MOV     A,#0x12
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003E   7901         MOV     R1,#0x1
   \   000040   EE           MOV     A,R6
   \   000041   FC           MOV     R4,A
   \   000042   EF           MOV     A,R7
   \   000043   FD           MOV     R5,A
   \   000044   AA..         MOV     R2,?V0
   \   000046   AB..         MOV     R3,?V1
   \   000048   85..82       MOV     DPL,?V2
   \   00004B   85..83       MOV     DPH,?V3
   \   00004E   12....       LCALL   ?CALL_IND
   \   000051   7404         MOV     A,#0x4
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   8002         SJMP    ??zclReadAttrDataUsingCB_2
   3100            }
   3101          
   3102            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000058   79C1         MOV     R1,#-0x3f
   \                     ??zclReadAttrDataUsingCB_2:
   \   00005A   80..         SJMP    ??Subroutine181_0
   3103          }
   3104          
   3105          /*********************************************************************
   3106           * @fn      zclAuthorizeRead
   3107           *
   3108           * @brief   Use application's callback to authorize a Read operation
   3109           *          on a given attribute.
   3110           *
   3111           * @param   endpoint - application's endpoint
   3112           * @param   srcAddr - source Address
   3113           * @param   pAttr - pointer to attribute
   3114           *
   3115           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3116           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3117           */
   3118          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   3119          {
   3120            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   3121            {
   3122              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   3123          
   3124              if ( pfnAuthorizeCB != NULL )
   3125              {
   3126                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   3127              }
   3128            }
   3129          
   3130            return ( ZCL_STATUS_SUCCESS );
   3131          }
   3132          #endif // ZCL_READ
   3133          
   3134          #ifdef ZCL_WRITE
   3135          /*********************************************************************
   3136           * @fn      zclWriteAttrData
   3137           *
   3138           * @brief   Write the received data.
   3139           *
   3140           * @param   endpoint - application's endpoint
   3141           * @param   pAttr - where to write data to
   3142           * @param   pWriteRec - data to be written
   3143           *
   3144           * @return  Successful if data was written
   3145           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3146          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   3147                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   3148          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FE           MOV     R6,A
   \   000007   ED           MOV     A,R5
   \   000008   FF           MOV     R7,A
   3149            uint8 status;
   3150          
   3151            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   A2E1         MOV     C,0xE0 /* A   */.1
   \   000015   507B         JNC     ??zclWriteAttrData_0
   3152            {
   3153              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000017                ; Setup parameters for call to function zclAuthorizeWrite
   \   000017   12....       LCALL   ??zclAuthorizeWrite?relay; Banked call to: zclAuthorizeWrite
   \   00001A   E9           MOV     A,R1
   \   00001B   F5..         MOV     ?V3,A
   3154              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7076         JNZ     ??zclWriteAttrData_1
   \   00001F   740F         MOV     A,#0xf
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V1,A
   3155              {
   3156                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   00002B   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   00002E   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000031   6013         JZ      ??zclWriteAttrData_2
   \   000033                ; Setup parameters for indirect call
   \   000033   AC..         MOV     R4,?V0
   \   000035   AD..         MOV     R5,?V1
   \   000037   EE           MOV     A,R6
   \   000038   FA           MOV     R2,A
   \   000039   EF           MOV     A,R7
   \   00003A   FB           MOV     R3,A
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   F583         MOV     DPH,A
   \   00003E   8882         MOV     DPL,R0
   \   000040   12....       LCALL   ?CALL_IND
   \   000043   E9           MOV     A,R1
   \   000044   6047         JZ      ??zclWriteAttrData_3
   3157                {
   3158                  // Write the attribute value
   3159                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   000046   E5..         MOV     A,?V0
   \   000048   2403         ADD     A,#0x3
   \   00004A   F8           MOV     R0,A
   \   00004B   E4           CLR     A
   \   00004C   35..         ADDC    A,?V1
   \   00004E   F9           MOV     R1,A
   \   00004F   88..         MOV     ?V0,R0
   \   000051   89..         MOV     ?V1,R1
   \   000053                ; Setup parameters for call to function zclGetAttrDataLength
   \   000053   8882         MOV     DPL,R0
   \   000055   F583         MOV     DPH,A
   \   000057   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   00005A   8E82         MOV     DPL,R6
   \   00005C   8F83         MOV     DPH,R7
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F9           MOV     R1,A
   \   000064   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000067   8A..         MOV     ?V4,R2
   \   000069   8B..         MOV     ?V5,R3
   \   00006B   AC..         MOV     R4,?V4
   \   00006D   AD..         MOV     R5,?V5
   3160                  zcl_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00006F                ; Setup parameters for call to function osal_memcpy
   \   00006F   85..82       MOV     DPL,?V0
   \   000072   85..83       MOV     DPH,?V1
   \   000075   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000078   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007B   8E82         MOV     DPL,R6
   \   00007D   8F83         MOV     DPH,R7
   \   00007F   A3           INC     DPTR
   \   000080   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_352:
   \   000083   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000086   7403         MOV     A,#0x3
   \   000088   12....       LCALL   ?DEALLOC_XSTACK8
   3161          
   3162                  status = ZCL_STATUS_SUCCESS;
   \   00008B   8008         SJMP    ??zclWriteAttrData_1
   3163                }
   3164                else
   3165                {
   3166                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   00008D   75..87       MOV     ?V3,#-0x79
   \   000090   8003         SJMP    ??zclWriteAttrData_1
   3167                }
   3168              }
   3169            }
   3170            else
   3171            {
   3172              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000092   75..88       MOV     ?V3,#-0x78
   3173            }
   3174          
   3175            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000095   A9..         MOV     R1,?V3
   \   000097   02....       LJMP    ?Subroutine9 & 0xFFFF
   3176          }
   3177          
   3178          /*********************************************************************
   3179           * @fn      zclWriteAttrDataUsingCB
   3180           *
   3181           * @brief   Use application's callback to write the attribute's current
   3182           *          value stored in the database.
   3183           *
   3184           * @param   endpoint - application's endpoint
   3185           * @param   pAttr - where to write data to
   3186           * @param   pAttrData - data to be written
   3187           *
   3188           * @return  Successful if data was written
   3189           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3190          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   3191                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   3192          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   EC           MOV     A,R4
   \   000008   FE           MOV     R6,A
   \   000009   ED           MOV     A,R5
   \   00000A   FF           MOV     R7,A
   3193            uint8 status;
   3194          
   3195            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   00000B   8E82         MOV     DPL,R6
   \   00000D   8F83         MOV     DPH,R7
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   A2E1         MOV     C,0xE0 /* A   */.1
   \   000017   504A         JNC     ??zclWriteAttrDataUsingCB_0
   3196            {
   3197              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   000019                ; Setup parameters for call to function zclAuthorizeWrite
   \   000019   12....       LCALL   ??zclAuthorizeWrite?relay; Banked call to: zclAuthorizeWrite
   \   00001C   E9           MOV     A,R1
   3198              if ( status == ZCL_STATUS_SUCCESS )
   \   00001D   7046         JNZ     ??zclWriteAttrDataUsingCB_1
   3199              {
   3200                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00001F                ; Setup parameters for call to function zclGetReadWriteCB
   \   00001F   A9..         MOV     R1,?V0
   \   000021   12....       LCALL   ??zclGetReadWriteCB?relay; Banked call to: zclGetReadWriteCB
   \   000024   8A..         MOV     ?V2,R2
   \   000026   8B..         MOV     ?V3,R3
   3201                if ( pfnReadWriteCB != NULL )
   \   000028   EA           MOV     A,R2
   \   000029   45..         ORL     A,?V3
   \   00002B   6032         JZ      ??zclWriteAttrDataUsingCB_2
   3202                {
   3203                  // Write the attribute value
   3204                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   3205                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   00002D                ; Setup parameters for indirect call
   \   00002D   E4           CLR     A
   \   00002E   F5..         MOV     ?V4,A
   \   000030   F5..         MOV     ?V5,A
   \   000032   78..         MOV     R0,#?V4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   7410         MOV     A,#0x10
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00003F   7902         MOV     R1,#0x2
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   12....       LCALL   ??Subroutine213_0 & 0xFFFF
   3206                }
   \                     ??CrossCallReturnLabel_498:
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_346:
   \   00004F   85..82       MOV     DPL,?V2
   \   000052   85..83       MOV     DPH,?V3
   \   000055   12....       LCALL   ?CALL_IND
   \   000058   7404         MOV     A,#0x4
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   8006         SJMP    ??zclWriteAttrDataUsingCB_1
   3207                else
   3208                {
   3209                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   00005F   79C1         MOV     R1,#-0x3f
   \   000061   8002         SJMP    ??zclWriteAttrDataUsingCB_1
   3210                }
   3211              }
   3212            }
   3213            else
   3214            {
   3215              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   000063   7988         MOV     R1,#-0x78
   3216            }
   3217          
   3218            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000065   02....       LJMP    ?Subroutine3 & 0xFFFF
   3219          }
   3220          
   3221          /*********************************************************************
   3222           * @fn      zclAuthorizeWrite
   3223           *
   3224           * @brief   Use application's callback to authorize a Write operation
   3225           *          on a given attribute.
   3226           *
   3227           * @param   endpoint - application's endpoint
   3228           * @param   srcAddr - source Address
   3229           * @param   pAttr - pointer to attribute
   3230           *
   3231           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   3232           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   3233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3234          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   3235          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3236            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   00000D   8C82         MOV     DPL,R4
   \   00000F   8D83         MOV     DPH,R5
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   A2E5         MOV     C,0xE0 /* A   */.5
   \   000019   501C         JNC     ??zclAuthorizeWrite_0
   3237            {
   3238              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00001B                ; Setup parameters for call to function zclGetAuthorizeCB
   \   00001B   12....       LCALL   ??zclGetAuthorizeCB?relay; Banked call to: zclGetAuthorizeCB
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   3239          
   3240              if ( pfnAuthorizeCB != NULL )
   \   000022   E582         MOV     A,DPL
   \   000024   4583         ORL     A,DPH
   \   000026   600F         JZ      ??zclAuthorizeWrite_0
   3241              {
   3242                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000028                ; Setup parameters for indirect call
   \   000028   7902         MOV     R1,#0x2
   \   00002A   AC..         MOV     R4,?V0
   \   00002C   AD..         MOV     R5,?V1
   \   00002E   EE           MOV     A,R6
   \   00002F   FA           MOV     R2,A
   \   000030   EF           MOV     A,R7
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   ?CALL_IND
   \   000035   8002         SJMP    ??zclAuthorizeWrite_1
   3243              }
   3244            }
   3245          
   3246            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000037   7900         MOV     R1,#0x0
   \                     ??zclAuthorizeWrite_1:
   \   000039   02....       LJMP    ?Subroutine3 & 0xFFFF
   3247          }
   3248          #endif // ZCL_WRITE
   3249          
   3250          #ifdef ZCL_READ
   3251          /*********************************************************************
   3252           * @fn      zclParseInReadCmd
   3253           *
   3254           * @brief   Parse the "Profile" Read Commands
   3255           *
   3256           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3257           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3258           *
   3259           * @param   pCmd - pointer to incoming data to parse
   3260           *
   3261           * @return  pointer to the parsed command structure
   3262           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3263          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   3264          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3265            zclReadCmd_t *readCmd;
   3266            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   00000F   FE           MOV     R6,A
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   3267          
   3268            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000012   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000015   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3269            if ( readCmd != NULL )
   \   000018   EA           MOV     A,R2
   \   000019   4B           ORL     A,R3
   \   00001A   6049         JZ      ??zclParseInReadCmd_0
   3270            {
   3271              uint8 i;
   3272              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00001C   85..82       MOV     DPL,?V0
   \   00001F   85..83       MOV     DPH,?V1
   \   000022   12....       LCALL   ?Subroutine165 & 0xFFFF
   \                     ??CrossCallReturnLabel_419:
   \   000025   C3           CLR     C
   \   000026   13           RRC     A
   \   000027   E8           MOV     A,R0
   \   000028   13           RRC     A
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   F0           MOVX    @DPTR,A
   3273              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002E   75..00       MOV     ?V0,#0x0
   \   000031   8029         SJMP    ??zclParseInReadCmd_1
   3274              {
   3275                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   12....       LCALL   ?Subroutine163 & 0xFFFF
   3276                pBuf += 2;
   3277              }
   \                     ??CrossCallReturnLabel_517:
   \   00003A   F8           MOV     R0,A
   \   00003B   E4           CLR     A
   \   00003C   C8           XCH     A,R0
   \   00003D   F9           MOV     R1,A
   \   00003E   EC           MOV     A,R4
   \   00003F   28           ADD     A,R0
   \   000040   E4           CLR     A
   \   000041   39           ADDC    A,R1
   \   000042   FD           MOV     R5,A
   \   000043   A8..         MOV     R0,?V0
   \   000045   E8           MOV     A,R0
   \   000046   28           ADD     A,R0
   \   000047   F8           MOV     R0,A
   \   000048   E4           CLR     A
   \   000049   33           RLC     A
   \   00004A   F9           MOV     R1,A
   \   00004B   EA           MOV     A,R2
   \   00004C   28           ADD     A,R0
   \   00004D   F582         MOV     DPL,A
   \   00004F   EB           MOV     A,R3
   \   000050   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   000053   EC           MOV     A,R4
   \   000054   12....       LCALL   ??Subroutine194_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000057   5001         JNC     ??zclParseInReadCmd_3
   \   000059   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   00005A   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   00005C   8A82         MOV     DPL,R2
   \   00005E   8B83         MOV     DPH,R3
   \   000060   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   3278            }
   \                     ??CrossCallReturnLabel_281:
   \   000063   40CE         JC      ??zclParseInReadCmd_2
   3279          
   3280            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000065   02....       LJMP    ?Subroutine1 & 0xFFFF
   3281          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0,DPL
   \   000008   8583..       MOV     ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000003   E8           MOV     A,R0
   \   000004   22           RET
   3282          
   3283          /*********************************************************************
   3284           * @fn      zclParseInReadRspCmd
   3285           *
   3286           * @brief   Parse the "Profile" Read Response Commands
   3287           *
   3288           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3289           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3290           *
   3291           * @param   pCmd - pointer to incoming data to parse
   3292           *
   3293           * @return  pointer to the parsed command structure
   3294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3295          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   3296          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   3297            zclReadRspCmd_t *readRspCmd;
   3298            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine74 & 0xFFFF
   3299            uint8 *dataPtr;
   3300            uint8 numAttr = 0;
   3301            uint8 hdrLen;
   3302            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_117:
   \   000019   803A         SJMP    ??zclParseInReadRspCmd_0
   3303            uint16 attrDataLen;
   3304          
   3305            // find out the number of attributes and the length of attribute data
   3306            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3307            {
   3308              uint8 status;
   3309          
   3310              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00001B   05..         INC     ?V2
   3311              pBuf += 2; // move pass attribute id
   \   00001D   EE           MOV     A,R6
   \   00001E   2402         ADD     A,#0x2
   \   000020   FE           MOV     R6,A
   \   000021   5001         JNC     ??zclParseInReadRspCmd_2
   \   000023   0F           INC     R7
   3312          
   3313              status = *pBuf++;
   \                     ??zclParseInReadRspCmd_2:
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   E0           MOVX    A,@DPTR
   \   000029   A3           INC     DPTR
   \   00002A   AE82         MOV     R6,DPL
   \   00002C   AF83         MOV     R7,DPH
   3314              if ( status == ZCL_STATUS_SUCCESS )
   \   00002E   7025         JNZ     ??zclParseInReadRspCmd_0
   3315              {
   3316                uint8 dataType = *pBuf++;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   A3           INC     DPTR
   \   000033   0E           INC     R6
   \   000034   AF83         MOV     R7,DPH
   3317          
   3318                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000036                ; Setup parameters for call to function zclGetAttrDataLength
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00003D   12....       LCALL   ?Subroutine116 & 0xFFFF
   3319                pBuf += attrDataLen; // move pass attribute data
   3320          
   3321                // add padding if needed
   3322                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_202:
   \   000040   5007         JNC     ??zclParseInReadRspCmd_3
   3323                {
   3324                  attrDataLen++;
   \   000042   05..         INC     ?V0
   \   000044   04           INC     A
   \   000045   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000047   05..         INC     ?V1
   3325                }
   3326          
   3327                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000049   E5..         MOV     A,?V6
   \   00004B   25..         ADD     A,?V0
   \   00004D   F5..         MOV     ?V6,A
   \   00004F   E5..         MOV     A,?V7
   \   000051   35..         ADDC    A,?V1
   \   000053   F5..         MOV     ?V7,A
   3328              }
   3329            }
   \                     ??zclParseInReadRspCmd_0:
   \   000055   85..82       MOV     DPL,?V8
   \   000058   85..83       MOV     DPH,?V9
   \   00005B   A3           INC     DPTR
   \   00005C   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00005F   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   000062   40B7         JC      ??zclParseInReadRspCmd_1
   3330          
   3331            // calculate the length of the response header
   3332            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000064   75F006       MOV     B,#0x6
   \   000067   12....       LCALL   ?Subroutine124 & 0xFFFF
   3333          
   3334            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_358:
   \   00006A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00006D   8A..         MOV     ?V10,R2
   \   00006F   8B..         MOV     ?V11,R3
   3335            if ( readRspCmd != NULL )
   \   000071   EA           MOV     A,R2
   \   000072   45..         ORL     A,?V11
   \   000074   7003         JNZ     $+5
   \   000076   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   3336            {
   3337              uint8 i;
   3338              pBuf = pCmd->pData;
   \   000079   85..82       MOV     DPL,?V4
   \   00007C   85..83       MOV     DPH,?V5
   \   00007F   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   3339              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_384:
   \   000082   F5..         MOV     ?V8,A
   \   000084   E4           CLR     A
   \   000085   3B           ADDC    A,R3
   \   000086   F5..         MOV     ?V9,A
   3340          
   3341              readRspCmd->numAttr = numAttr;
   \   000088   8A82         MOV     DPL,R2
   \   00008A   8B83         MOV     DPH,R3
   \   00008C   E5..         MOV     A,?V2
   \   00008E   F0           MOVX    @DPTR,A
   3342              for ( i = 0; i < numAttr; i++ )
   \   00008F   75..00       MOV     ?V3,#0x0
   \   000092   8077         SJMP    ??zclParseInReadRspCmd_5
   3343              {
   3344                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   000094   E5..         MOV     A,?V3
   \   000096   75F006       MOV     B,#0x6
   \   000099   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   3345          
   3346                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3347                pBuf += 2;
   \                     ??CrossCallReturnLabel_363:
   \   00009C   5001         JNC     ??zclParseInReadRspCmd_7
   \   00009E   0F           INC     R7
   3348          
   3349                statusRec->status = *pBuf++;
   \                     ??zclParseInReadRspCmd_7:
   \   00009F   8E82         MOV     DPL,R6
   \   0000A1   8F83         MOV     DPH,R7
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   85..82       MOV     DPL,?V12
   \   0000A7   85..83       MOV     DPH,?V13
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   12....       LCALL   ?Subroutine33 & 0xFFFF
   3350                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_31:
   \   0000AF   7058         JNZ     ??zclParseInReadRspCmd_8
   3351                {
   3352                  statusRec->dataType = *pBuf++;
   \   0000B1   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   0000B4   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   0000B7   0E           INC     R6
   \   0000B8   AF83         MOV     R7,DPH
   3353          
   3354                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0000BA                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000BA   EE           MOV     A,R6
   \   0000BB   FA           MOV     R2,A
   \   0000BC   EF           MOV     A,R7
   \   0000BD   FB           MOV     R3,A
   \   0000BE   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000C1   8A..         MOV     ?V0,R2
   \   0000C3   8B..         MOV     ?V1,R3
   3355                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000C5                ; Setup parameters for call to function osal_memcpy
   \   0000C5   8E..         MOV     ?V4,R6
   \   0000C7   8F..         MOV     ?V5,R7
   \   0000C9   75..00       MOV     ?V6,#0x0
   \   0000CC   78..         MOV     R0,#?V4
   \   0000CE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D1   AC..         MOV     R4,?V0
   \   0000D3   AD..         MOV     R5,?V1
   \   0000D5   AA..         MOV     R2,?V8
   \   0000D7   AB..         MOV     R3,?V9
   \   0000D9   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000DC   7403         MOV     A,#0x3
   \   0000DE   12....       LCALL   ?DEALLOC_XSTACK8
   3356                  statusRec->data = dataPtr;
   \   0000E1   85..82       MOV     DPL,?V12
   \   0000E4   85..83       MOV     DPH,?V13
   \   0000E7   A3           INC     DPTR
   \   0000E8   A3           INC     DPTR
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   E5..         MOV     A,?V8
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   A3           INC     DPTR
   \   0000EF   E5..         MOV     A,?V9
   \   0000F1   12....       LCALL   ??Subroutine190_0 & 0xFFFF
   3357          
   3358                  pBuf += attrDataLen; // move pass attribute data
   3359          
   3360                  // advance attribute data pointer
   3361                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_375:
   \   0000F4   5007         JNC     ??zclParseInReadRspCmd_9
   3362                  {
   3363                    attrDataLen++;
   \   0000F6   05..         INC     ?V0
   \   0000F8   04           INC     A
   \   0000F9   7002         JNZ     ??zclParseInReadRspCmd_9
   \   0000FB   05..         INC     ?V1
   3364                  }
   3365          
   3366                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   0000FD   E5..         MOV     A,?V8
   \   0000FF   25..         ADD     A,?V0
   \   000101   F5..         MOV     ?V8,A
   \   000103   E5..         MOV     A,?V9
   \   000105   35..         ADDC    A,?V1
   \   000107   F5..         MOV     ?V9,A
   3367                }
   3368              }
   \                     ??zclParseInReadRspCmd_8:
   \   000109   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00010B   E5..         MOV     A,?V3
   \   00010D   C3           CLR     C
   \   00010E   95..         SUBB    A,?V2
   \   000110   4082         JC      ??zclParseInReadRspCmd_6
   3369            }
   3370          
   3371            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000112   02....       LJMP    ?Subroutine6 & 0xFFFF
   3372          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   E5..         MOV     A,?V2
   \   000002                REQUIRE ??Subroutine187_0
   \   000002                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   A4           MUL     AB
   \   000001   04           INC     A
   \   000002   F5..         MOV     ?V8,A
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   25..         ADD     A,?V6
   \   000006   FA           MOV     R2,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V7
   \   00000A   FB           MOV     R3,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   00000E   8582..       MOV     ?V12,DPL
   \   000011   8583..       MOV     ?V13,DPH
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   EA           MOV     A,R2
   \   00001E   85..82       MOV     DPL,?V12
   \   000021   85..83       MOV     DPH,?V13
   \   000024                REQUIRE ??Subroutine189_0
   \   000024                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   8A..         MOV     ?V0,R2
   \   000002   8B..         MOV     ?V1,R3
   \   000004   EE           MOV     A,R6
   \   000005   2A           ADD     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EF           MOV     A,R7
   \   000008   35..         ADDC    A,?V1
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   25..         ADD     A,?V0
   \   000004   FE           MOV     R6,A
   \   000005   EF           MOV     A,R7
   \   000006   35..         ADDC    A,?V1
   \   000008   FF           MOV     R7,A
   \   000009   E5..         MOV     A,?V0
   \   00000B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   EE           MOV     A,R6
   \   000009   98           SUBB    A,R0
   \   00000A   EF           MOV     A,R7
   \   00000B   99           SUBB    A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   000003   EA           MOV     A,R2
   \   000004   25..         ADD     A,?V8
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   000003   75..00       MOV     ?V2,#0x0
   \   000006   75..00       MOV     ?V6,#0x0
   \   000009   75..00       MOV     ?V7,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004                REQUIRE ??Subroutine199_0
   \   000004                ; // Fall through to label ??Subroutine199_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000003   85..82       MOV     DPL,?V4
   \   000006   85..83       MOV     DPH,?V5
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine204_0
   \   000002                ; // Fall through to label ??Subroutine204_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine204_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET
   3373          #endif // ZCL_READ
   3374          
   3375          #ifdef ZCL_WRITE
   3376          /*********************************************************************
   3377           * @fn      zclParseInWriteCmd
   3378           *
   3379           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   3380           *          Response Commands
   3381           *
   3382           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3383           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3384           *
   3385           * @param   pCmd - pointer to incoming data to parse
   3386           *
   3387           * @return  pointer to the parsed command structure
   3388           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   E5..         MOV     A,?V8
   \   000002   75F005       MOV     B,#0x5
   \   000005                REQUIRE ??Subroutine188_0
   \   000005                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3389          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   3390          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   3391            zclWriteCmd_t *writeCmd;
   3392            uint8 *pBuf = pCmd->pData;
   3393            uint16 attrDataLen;
   3394            uint8 *dataPtr;
   3395            uint8 numAttr = 0;
   3396            uint8 hdrLen;
   3397            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_119:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_215
   3398          
   3399            // find out the number of attributes and the length of attribute data
   3400            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3401            {
   3402              uint8 dataType;
   3403          
   3404              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000A   05..         INC     ?V7
   3405              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInWriteCmd_1
   \   000012   0F           INC     R7
   3406          
   3407              dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_1:
   \   000013   12....       LCALL   ?Subroutine84 & 0xFFFF
   3408          
   3409              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_135:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine116 & 0xFFFF
   3410              pBuf += attrDataLen; // move pass attribute data
   3411          
   3412              // add padding if needed
   3413              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_203:
   \   00001C   5007         JNC     ??zclParseInWriteCmd_2
   3414              {
   3415                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInWriteCmd_2
   \   000023   05..         INC     ?V1
   3416              }
   3417          
   3418              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000025   12....       LCALL   ?Subroutine122 & 0xFFFF
   3419            }
   \                     ??CrossCallReturnLabel_215:
   \   000028   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   00002B   40DD         JC      ??zclParseInWriteCmd_0
   3420          
   3421            // calculate the length of the response header
   3422            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   00002D   75F005       MOV     B,#0x5
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   3423          
   3424            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   3425            if ( writeCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   6047         JZ      ??zclParseInWriteCmd_3
   3426            {
   3427              uint8 i;
   3428              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine56 & 0xFFFF
   3429              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   3430          
   3431              writeCmd->numAttr = numAttr;
   3432              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_64:
   \   00004C   803B         SJMP    ??CrossCallReturnLabel_213
   3433              {
   3434                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   3435          
   3436                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3437                pBuf += 2;
   \                     ??CrossCallReturnLabel_361:
   \   000051   5001         JNC     ??zclParseInWriteCmd_5
   \   000053   0F           INC     R7
   3438                statusRec->dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_5:
   \   000054   12....       LCALL   ?Subroutine25 & 0xFFFF
   3439          
   3440                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_18:
   \   000057   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005A   8A..         MOV     ?V0,R2
   \   00005C   8B..         MOV     ?V1,R3
   3441                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   8E..         MOV     ?V4,R6
   \   000060   8F..         MOV     ?V5,R7
   \   000062   75..00       MOV     ?V6,#0x0
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006A   AC..         MOV     R4,?V0
   \   00006C   AD..         MOV     R5,?V1
   \   00006E   AA..         MOV     R2,?V2
   \   000070   AB..         MOV     R3,?V3
   \   000072   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   3442                statusRec->attrData = dataPtr;
   \   00007A   12....       LCALL   ?Subroutine20 & 0xFFFF
   3443          
   3444                pBuf += attrDataLen; // move pass attribute data
   3445          
   3446                // advance attribute data pointer
   3447                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_373:
   \   00007D   5007         JNC     ??zclParseInWriteCmd_6
   3448                {
   3449                  attrDataLen++;
   \   00007F   05..         INC     ?V0
   \   000081   04           INC     A
   \   000082   7002         JNZ     ??zclParseInWriteCmd_6
   \   000084   05..         INC     ?V1
   3450                }
   3451          
   3452                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_6:
   \   000086   12....       LCALL   ?Subroutine121 & 0xFFFF
   3453              }
   \                     ??CrossCallReturnLabel_213:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40BE         JC      ??zclParseInWriteCmd_4
   3454            }
   3455          
   3456            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   000090   02....       LJMP    ?Subroutine6 & 0xFFFF
   3457          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   E5..         MOV     A,?V2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E5..         MOV     A,?V3
   \   00000F                REQUIRE ??Subroutine190_0
   \   00000F                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine191_0
   \   000007                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_504:
   \   000003                REQUIRE ??Subroutine192_0
   \   000003                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   E5..         MOV     A,?V4
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V4,A
   \   000006   E5..         MOV     A,?V5
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V5,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   E5..         MOV     A,?V2
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V2,A
   \   000006   E5..         MOV     A,?V3
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V3,A
   \   00000C   05..         INC     ?V8
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   AE82         MOV     R6,DPL
   \   000009   AF83         MOV     R7,DPH
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V2,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V9
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   000014   75..00       MOV     ?V7,#0x0
   \   000017   75..00       MOV     ?V4,#0x0
   \   00001A   75..00       MOV     ?V5,#0x0
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   000009   85....       MOV     ?V0,?V6
   \   00000C   EA           MOV     A,R2
   \   00000D   25..         ADD     A,?V0
   \   00000F   F5..         MOV     ?V2,A
   \   000011   E4           CLR     A
   \   000012   3B           ADDC    A,R3
   \   000013   F5..         MOV     ?V3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V8,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   EE           MOV     A,R6
   \   00000D   FA           MOV     R2,A
   \   00000E   EF           MOV     A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine215_0
   \   000003                ; // Fall through to label ??Subroutine215_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine215_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002                ; Setup parameters for call to function zclGetAttrDataLengthUsingCB
   \   000002                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000002   85..82       MOV     DPL,?V2
   \   000005   85..83       MOV     DPH,?V3
   \   000008   22           RET
   3458          
   3459          /*********************************************************************
   3460           * @fn      zclParseInWriteRspCmd
   3461           *
   3462           * @brief   Parse the "Profile" Write Response Commands
   3463           *
   3464           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3465           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3466           *
   3467           * @param   pCmd - pointer to incoming data to parse
   3468           *
   3469           * @return  pointer to the parsed command structure
   3470           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3471          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3472          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3473            zclWriteRspCmd_t *writeRspCmd;
   3474            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine107 & 0xFFFF
   3475            uint8 i = 0;
   3476          
   3477            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_176:
   \   000014   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3478            if ( writeRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   604A         JZ      ??zclParseInWriteRspCmd_0
   3479            {
   3480              if ( pCmd->dataLen == 1 )
   \   00001E   85..82       MOV     DPL,?V0
   \   000021   85..83       MOV     DPH,?V1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6401         XRL     A,#0x1
   \   000027   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00002B   7029         JNZ     ??zclParseInWriteRspCmd_2
   3481              {
   3482                // special case when all writes were successfull
   3483                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002D   12....       LCALL   ?Subroutine101 & 0xFFFF
   3484              }
   \                     ??CrossCallReturnLabel_426:
   \   000030   A3           INC     DPTR
   \   000031   F0           MOVX    @DPTR,A
   \   000032   75..01       MOV     ?V4,#0x1
   \   000035   802A         SJMP    ??zclParseInWriteRspCmd_3
   3485              else
   3486              {
   3487                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3488                {
   3489                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000037   E5..         MOV     A,?V4
   \   000039   12....       LCALL   ?Subroutine15 & 0xFFFF
   3490                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_392:
   \   00003C   F5..         MOV     ?V6,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FD           MOV     R5,A
   \   000041   E5..         MOV     A,?V6
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   ED           MOV     A,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   05..         INC     ?V4
   3491                  pBuf += 2;
   \   00004F   EE           MOV     A,R6
   \   000050   2402         ADD     A,#0x2
   \   000052   FE           MOV     R6,A
   \   000053   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000055   0F           INC     R7
   3492                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000056   85..82       MOV     DPL,?V0
   \   000059   85..83       MOV     DPH,?V1
   \   00005C   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   3493              }
   \                     ??CrossCallReturnLabel_379:
   \   00005F   40D6         JC      ??zclParseInWriteRspCmd_4
   3494          
   3495              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   E5..         MOV     A,?V4
   \   000067   F0           MOVX    @DPTR,A
   3496            }
   3497          
   3498            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000068   02....       LJMP    ??Subroutine181_0 & 0xFFFF
   3499          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C                REQUIRE ??Subroutine195_0
   \   00000C                ; // Fall through to label ??Subroutine195_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine161 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000008                REQUIRE ??Subroutine196_0
   \   000008                ; // Fall through to label ??Subroutine196_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   000003   75..00       MOV     ?V4,#0x0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine200_0
   \   000004                ; // Fall through to label ??Subroutine200_0
   3500          #endif // ZCL_WRITE
   3501          
   3502          #ifdef ZCL_REPORT
   3503          /*********************************************************************
   3504           * @fn      zclParseInConfigReportCmd
   3505           *
   3506           * @brief   Parse the "Profile" Configure Reporting Command
   3507           *
   3508           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3509           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3510           *
   3511           * @param   pCmd - pointer to incoming data to parse
   3512           *
   3513           * @return  pointer to the parsed command structure
   3514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine168_0
   \   000004                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3515          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3516          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   3517            zclCfgReportCmd_t *cfgReportCmd;
   3518            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine74 & 0xFFFF
   3519            uint8 *dataPtr;
   3520            uint8 numAttr = 0;
   3521            uint8 dataType;
   3522            uint8 hdrLen;
   3523            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_118:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   3524            uint8 reportChangeLen; // length of Reportable Change field
   3525          
   3526            // Calculate the length of the Request command
   3527            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3528            {
   3529              uint8 direction;
   3530          
   3531              numAttr++;
   3532              direction = *pBuf++;
   3533              pBuf += 2; // move pass the attribute ID
   3534          
   3535              // Is there a Reportable Change field?
   3536              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3537              {
   3538                dataType = *pBuf++;
   3539                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3540          
   3541                // For attributes of 'discrete' data types this field is omitted
   3542                if ( zclAnalogDataType( dataType ) )
   3543                {
   3544                  reportChangeLen = zclGetDataTypeLength( dataType );
   3545                  pBuf += reportChangeLen;
   3546          
   3547                  // add padding if needed
   3548                  if ( PADDING_NEEDED( reportChangeLen ) )
   3549                  {
   3550                    reportChangeLen++;
   3551                  }
   3552          
   3553                  dataLen += reportChangeLen;
   3554                }
   3555                else
   3556                {
   3557                  pBuf++; // move past reportable change field
   3558                }
   3559              }
   3560              else
   3561              {
   3562                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2402         ADD     A,#0x2
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   3563              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   00002B   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_377:
   \   00002E   504B         JNC     ??zclParseInConfigReportCmd_2
   \   000030   05..         INC     ?V2
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   AF83         MOV     R7,DPH
   \   00003B   E582         MOV     A,DPL
   \   00003D   2402         ADD     A,#0x2
   \   00003F   FE           MOV     R6,A
   \   000040   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000042   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000043   E8           MOV     A,R0
   \   000044   70D5         JNZ     ??zclParseInConfigReportCmd_1
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5..         MOV     ?V3,A
   \   00004D   A3           INC     DPTR
   \   00004E   AF83         MOV     R7,DPH
   \   000050   E582         MOV     A,DPL
   \   000052   2404         ADD     A,#0x4
   \   000054   FE           MOV     R6,A
   \   000055   5001         JNC     ??zclParseInConfigReportCmd_4
   \   000057   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_4:
   \   000058                ; Setup parameters for call to function zclAnalogDataType
   \   000058   A9..         MOV     R1,?V3
   \   00005A   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005D   E9           MOV     A,R1
   \   00005E   6011         JZ      ??zclParseInConfigReportCmd_5
   \   000060                ; Setup parameters for call to function zclGetDataTypeLength
   \   000060   A9..         MOV     R1,?V3
   \   000062   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000065   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000068   5002         JNC     ??zclParseInConfigReportCmd_6
   \   00006A   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_6:
   \   00006C   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   00006F   80B1         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_5:
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   A3           INC     DPTR
   \   000076   0E           INC     R6
   \   000077   AF83         MOV     R7,DPH
   \   000079   80A7         SJMP    ??zclParseInConfigReportCmd_0
   3564            } // while loop
   3565          
   3566            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   00007B   75F00C       MOV     B,#0xc
   \   00007E   12....       LCALL   ?Subroutine124 & 0xFFFF
   3567          
   3568            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_359:
   \   000081   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000084   8A..         MOV     ?V6,R2
   \   000086   8B..         MOV     ?V7,R3
   3569            if ( cfgReportCmd != NULL )
   \   000088   EA           MOV     A,R2
   \   000089   45..         ORL     A,?V7
   \   00008B   7003         JNZ     $+5
   \   00008D   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   3570            {
   3571              uint8 i;
   3572              pBuf = pCmd->pData;
   \   000090   12....       LCALL   ?Subroutine80 & 0xFFFF
   3573              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_382:
   \   000093   F5..         MOV     ?V4,A
   \   000095   E4           CLR     A
   \   000096   3B           ADDC    A,R3
   \   000097   F5..         MOV     ?V5,A
   3574          
   3575              cfgReportCmd->numAttr = numAttr;
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V2
   \   00009F   F0           MOVX    @DPTR,A
   3576              for ( i = 0; i < numAttr; i++ )
   \   0000A0   75..00       MOV     ?V3,#0x0
   \   0000A3   800B         SJMP    ??zclParseInConfigReportCmd_8
   3577              {
   3578                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3579          
   3580                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3581          
   3582                reportRec->direction = *pBuf++;
   3583                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3584                pBuf += 2;
   3585                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3586                {
   3587                  // Attribute to be reported
   3588                  reportRec->dataType = *pBuf++;
   3589                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3590                  pBuf += 2;
   3591                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3592                  pBuf += 2;
   3593          
   3594                  // For attributes of 'discrete' data types this field is omitted
   3595                  if ( zclAnalogDataType( reportRec->dataType ) )
   3596                  {
   3597                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3598                    reportRec->reportableChange = dataPtr;
   3599          
   3600                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3601                    pBuf += reportChangeLen;
   3602          
   3603                    // advance attribute data pointer
   3604                    if ( PADDING_NEEDED( reportChangeLen ) )
   3605                    {
   3606                      reportChangeLen++;
   3607                    }
   3608          
   3609                    dataPtr += reportChangeLen;
   3610                  }
   3611                }
   3612                else
   3613                {
   3614                  // Attribute reports to be received
   3615                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_9:
   \   0000A5   12....       LCALL   ?Subroutine69 & 0xFFFF
   3616                  pBuf += 2;
   3617                }
   \                     ??CrossCallReturnLabel_108:
   \   0000A8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   0000AB   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000AD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000AE   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B0   E5..         MOV     A,?V3
   \   0000B2   C3           CLR     C
   \   0000B3   95..         SUBB    A,?V2
   \   0000B5   4003         JC      $+5
   \   0000B7   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   \   0000BA   E5..         MOV     A,?V3
   \   0000BC   75F00C       MOV     B,#0xc
   \   0000BF   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   0000C2                ; Setup parameters for call to function osal_memset
   \   0000C2   7C0C         MOV     R4,#0xc
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   AA..         MOV     R2,?V0
   \   0000CA   AB..         MOV     R3,?V1
   \   0000CC   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0000CF   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0000D2   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   0000D5   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   0000D8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_366:
   \   0000DB   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000DD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000DE   8E82         MOV     DPL,R6
   \   0000E0   8F83         MOV     DPH,R7
   \   0000E2   A3           INC     DPTR
   \   0000E3   A882         MOV     R0,DPL
   \   0000E5   A983         MOV     R1,DPH
   \   0000E7   8E82         MOV     DPL,R6
   \   0000E9   8F83         MOV     DPH,R7
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   F5..         MOV     ?V10,A
   \   0000EE   EC           MOV     A,R4
   \   0000EF   70B4         JNZ     ??zclParseInConfigReportCmd_9
   \   0000F1   E5..         MOV     A,?V0
   \   0000F3   2403         ADD     A,#0x3
   \   0000F5   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000F8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_367:
   \   0000FB   5001         JNC     ??zclParseInConfigReportCmd_12
   \   0000FD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_12:
   \   0000FE   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000101   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_368:
   \   000104   5001         JNC     ??zclParseInConfigReportCmd_13
   \   000106   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_13:
   \   000107                ; Setup parameters for call to function zclAnalogDataType
   \   000107   A9..         MOV     R1,?V10
   \   000109   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00010C   E9           MOV     A,R1
   \   00010D   609F         JZ      ??zclParseInConfigReportCmd_10
   \   00010F                ; Setup parameters for call to function zcl_BuildAnalogData
   \   00010F   EE           MOV     A,R6
   \   000110   FC           MOV     R4,A
   \   000111   EF           MOV     A,R7
   \   000112   FD           MOV     R5,A
   \   000113   AA..         MOV     R2,?V4
   \   000115   AB..         MOV     R3,?V5
   \   000117   85..82       MOV     DPL,?V8
   \   00011A   85..83       MOV     DPH,?V9
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F9           MOV     R1,A
   \   00011F   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000122   85..82       MOV     DPL,?V0
   \   000125   85..83       MOV     DPH,?V1
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E5..         MOV     A,?V4
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V5
   \   000138   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000141   5002         JNC     ??zclParseInConfigReportCmd_14
   \   000143   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_14:
   \   000145   E5..         MOV     A,?V4
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V4,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V5
   \   00014E   F5..         MOV     ?V5,A
   \   000150   02....       LJMP    ??zclParseInConfigReportCmd_10 & 0xFFFF
   3618              } // while loop
   3619            }
   3620          
   3621            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_7:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3622          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine193_0
   \   000006                ; // Fall through to label ??Subroutine193_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   E5..         MOV     A,?V6
   \   000002   25..         ADD     A,?V10
   \   000004   F5..         MOV     ?V6,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V7
   \   000009   F5..         MOV     ?V7,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   12....       LCALL   ??Subroutine201_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   00000E   8582..       MOV     ?V0,DPL
   \   000011   8583..       MOV     ?V1,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V10,A
   \   000003   EE           MOV     A,R6
   \   000004   29           ADD     A,R1
   \   000005   FE           MOV     R6,A
   \   000006   E4           CLR     A
   \   000007   3F           ADDC    A,R7
   \   000008   FF           MOV     R7,A
   \   000009   E9           MOV     A,R1
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FC           MOV     R4,A
   \   000006   85..82       MOV     DPL,?V0
   \   000009   85..83       MOV     DPH,?V1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000004   85..82       MOV     DPL,?V0
   \   000007   85..83       MOV     DPH,?V1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   E5..         MOV     A,?V10
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   85..82       MOV     DPL,?V8
   \   00000A   F583         MOV     DPH,A
   \   00000C   E5..         MOV     A,?V10
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   0E           INC     R6
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   12....       LCALL   ?Subroutine160 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   3623          
   3624          /*********************************************************************
   3625           * @fn      zclParseInConfigReportRspCmd
   3626           *
   3627           * @brief   Parse the "Profile" Configure Reporting Response Command
   3628           *
   3629           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3630           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3631           *
   3632           * @param   pCmd - pointer to incoming data to parse
   3633           *
   3634           * @return  pointer to the parsed command structure
   3635           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3636          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3637          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   3638            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3639            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine91 & 0xFFFF
   3640            uint8 numAttr;
   3641          
   3642            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_145:
   \   000008   F5..         MOV     ?V0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?US_SHR
   \   000015   E5..         MOV     A,?V0
   \   000017   F5..         MOV     ?V2,A
   3643          
   3644            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3645                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   E5..         MOV     A,?V0
   \   000025   2401         ADD     A,#0x1
   \   000027   FA           MOV     R2,A
   \   000028   E4           CLR     A
   \   000029   35..         ADDC    A,?V1
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3646            if ( cfgReportRspCmd != NULL )
   \   00002F   EA           MOV     A,R2
   \   000030   4B           ORL     A,R3
   \   000031   6040         JZ      ??zclParseInConfigReportRspCmd_0
   3647            {
   3648              uint8 i;
   3649              cfgReportRspCmd->numAttr = numAttr;
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   E5..         MOV     A,?V2
   \   000039   F0           MOVX    @DPTR,A
   3650              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003A   75..00       MOV     ?V2,#0x0
   \   00003D   802B         SJMP    ??zclParseInConfigReportRspCmd_1
   3651              {
   3652                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_2:
   \   00003F   85....       MOV     ?V0,?V2
   \   000042   75..00       MOV     ?V1,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   EA           MOV     A,R2
   \   00004D   25..         ADD     A,?V0
   \   00004F   F8           MOV     R0,A
   \   000050   EB           MOV     A,R3
   \   000051   35..         ADDC    A,?V1
   \   000053   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   3653                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3654                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3655                pBuf += 2;
   3656              }
   \                     ??CrossCallReturnLabel_394:
   \   000056   8882         MOV     DPL,R0
   \   000058   8983         MOV     DPH,R1
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00005E   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000065   5001         JNC     ??zclParseInConfigReportRspCmd_3
   \   000067   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_3:
   \   000068   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00006A   8A82         MOV     DPL,R2
   \   00006C   8B83         MOV     DPH,R3
   \   00006E   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   3657            }
   \                     ??CrossCallReturnLabel_455:
   \   000071   40CC         JC      ??zclParseInConfigReportRspCmd_2
   3658          
   3659            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000073   7F03         MOV     R7,#0x3
   \   000075   02....       LJMP    ?BANKED_LEAVE_XDATA
   3660          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine194_0
   \   000002                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_447:
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000004   A3           INC     DPTR
   \   000005   0E           INC     R6
   \   000006   AF83         MOV     R7,DPH
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET
   3661          
   3662          /*********************************************************************
   3663           * @fn      zclParseInReadReportCfgCmd
   3664           *
   3665           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3666           *
   3667           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3668           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3669           *
   3670           * @param   pCmd - pointer to incoming data to parse
   3671           *
   3672           * @return  pointer to the parsed command structure
   3673           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3674          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3675          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3676            zclReadReportCfgCmd_t *readReportCfgCmd;
   3677            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine91 & 0xFFFF
   3678            uint8 numAttr;
   3679          
   3680            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_146:
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   7A03         MOV     R2,#0x3
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   ?US_DIV_MOD
   \   000013   E8           MOV     A,R0
   \   000014   F5..         MOV     ?V0,A
   3681          
   3682            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3683                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_506:
   \   000019   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3684            if ( readReportCfgCmd != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6025         JZ      ??zclParseInReadReportCfgCmd_0
   3685            {
   3686              uint8 i;
   3687              readReportCfgCmd->numAttr = numAttr;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E5..         MOV     A,?V0
   \   000026   F0           MOVX    @DPTR,A
   3688              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   8010         SJMP    ??zclParseInReadReportCfgCmd_1
   3689              {
   3690                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002C   E5..         MOV     A,?V2
   \   00002E   12....       LCALL   ?Subroutine15 & 0xFFFF
   3691                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3692                pBuf += 2;
   3693              }
   \                     ??CrossCallReturnLabel_393:
   \   000031   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   000034   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000037   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   000039   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00003A   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   3694            }
   \                     ??CrossCallReturnLabel_456:
   \   000043   40E7         JC      ??zclParseInReadReportCfgCmd_2
   3695          
   3696            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000045   02....       LJMP    ?Subroutine1 & 0xFFFF
   3697          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine156:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine216_0
   \   000003                ; // Fall through to label ??Subroutine216_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine216_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3698          
   3699          /*********************************************************************
   3700           * @fn      zclParseInReadReportCfgRspCmd
   3701           *
   3702           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3703           *
   3704           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3705           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3706           *
   3707           * @param   pCmd - pointer to incoming data to parse
   3708           *
   3709           * @return  pointer to the parsed command structure
   3710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3711          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3712          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   3713            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3714            uint8 reportChangeLen;
   3715            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine107 & 0xFFFF
   3716            uint8 *dataPtr;
   3717            uint8 numAttr = 0;
   3718            uint8 hdrLen;
   3719            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_177:
   \   000019   75..00       MOV     ?V6,#0x0
   \   00001C   75..00       MOV     ?V7,#0x0
   \   00001F   8007         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3720          
   3721            // Calculate the length of the response command
   3722            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3723            {
   3724              uint8 status;
   3725              uint8 direction;
   3726          
   3727              numAttr++;
   3728              status = *pBuf++;
   3729              direction = *pBuf++;
   3730              pBuf += 2; // move pass the attribute ID
   3731          
   3732              if ( status == ZCL_STATUS_SUCCESS )
   3733              {
   3734                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3735                {
   3736                  uint8 dataType = *pBuf++;
   3737                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3738          
   3739                  // For attributes of 'discrete' data types this field is omitted
   3740                  if ( zclAnalogDataType( dataType ) )
   3741                  {
   3742                    reportChangeLen = zclGetDataTypeLength( dataType );
   3743                    pBuf += reportChangeLen;
   3744          
   3745                    // add padding if needed
   3746                    if ( PADDING_NEEDED( reportChangeLen ) )
   3747                    {
   3748                      reportChangeLen++;
   3749                    }
   3750          
   3751                    dataLen += reportChangeLen;
   3752                  }
   3753                }
   3754                else
   3755                {
   3756                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   000021   EE           MOV     A,R6
   \   000022   2402         ADD     A,#0x2
   \   000024   FE           MOV     R6,A
   \   000025   5001         JNC     ??zclParseInReadReportCfgRspCmd_0
   \   000027   0F           INC     R7
   3757                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000028   85..82       MOV     DPL,?V2
   \   00002B   85..83       MOV     DPH,?V3
   \   00002E   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000031   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_378:
   \   000034   5045         JNC     ??zclParseInReadReportCfgRspCmd_2
   \   000036   05..         INC     ?V4
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_403:
   \   00003F   A3           INC     DPTR
   \   000040   AF83         MOV     R7,DPH
   \   000042   E582         MOV     A,DPL
   \   000044   2402         ADD     A,#0x2
   \   000046   FE           MOV     R6,A
   \   000047   5001         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000049   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   00004A   E8           MOV     A,R0
   \   00004B   70DB         JNZ     ??zclParseInReadReportCfgRspCmd_0
   \   00004D   E9           MOV     A,R1
   \   00004E   70D1         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F5..         MOV     ?V5,A
   \   000057   A3           INC     DPTR
   \   000058   AF83         MOV     R7,DPH
   \   00005A   E582         MOV     A,DPL
   \   00005C   2404         ADD     A,#0x4
   \   00005E   FE           MOV     R6,A
   \   00005F   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000061   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000062                ; Setup parameters for call to function zclAnalogDataType
   \   000062   A9..         MOV     R1,?V5
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60BE         JZ      ??zclParseInReadReportCfgRspCmd_0
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   A9..         MOV     R1,?V5
   \   00006C   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006F   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000072   5002         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   000074   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   000076   12....       LCALL   ?Subroutine123 & 0xFFFF
   3758              }
   3759            } // while loop
   \                     ??CrossCallReturnLabel_218:
   \   000079   80AD         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3760          
   3761            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   00007B   75F00D       MOV     B,#0xd
   \   00007E   E5..         MOV     A,?V4
   \   000080   12....       LCALL   ??Subroutine187_0 & 0xFFFF
   3762          
   3763            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_360:
   \   000083   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000086   8A..         MOV     ?V6,R2
   \   000088   8B..         MOV     ?V7,R3
   3764            if ( readReportCfgRspCmd != NULL )
   \   00008A   EA           MOV     A,R2
   \   00008B   45..         ORL     A,?V7
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3765            {
   3766              uint8 i;
   3767              pBuf = pCmd->pData;
   \   000092   12....       LCALL   ?Subroutine80 & 0xFFFF
   3768              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_383:
   \   000095   F5..         MOV     ?V2,A
   \   000097   E4           CLR     A
   \   000098   3B           ADDC    A,R3
   \   000099   F5..         MOV     ?V3,A
   3769          
   3770              readReportCfgRspCmd->numAttr = numAttr;
   \   00009B   8A82         MOV     DPL,R2
   \   00009D   8B83         MOV     DPH,R3
   \   00009F   E5..         MOV     A,?V4
   \   0000A1   F0           MOVX    @DPTR,A
   3771              for ( i = 0; i < numAttr; i++ )
   \   0000A2   75..00       MOV     ?V5,#0x0
   \   0000A5   800C         SJMP    ??zclParseInReadReportCfgRspCmd_7
   3772              {
   3773                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3774          
   3775                reportRspRec->status = *pBuf++;
   3776                reportRspRec->direction = *pBuf++;
   3777                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3778                pBuf += 2;
   3779          
   3780                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3781                {
   3782                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3783                  {
   3784                    reportRspRec->dataType = *pBuf++;
   3785                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3786                    pBuf += 2;
   3787                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3788                    pBuf += 2;
   3789          
   3790                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3791                    {
   3792                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3793                      reportRspRec->reportableChange = dataPtr;
   3794          
   3795                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3796                      pBuf += reportChangeLen;
   3797          
   3798                      // advance attribute data pointer
   3799                      if ( PADDING_NEEDED( reportChangeLen ) )
   3800                      {
   3801                        reportChangeLen++;
   3802                      }
   3803          
   3804                      dataPtr += reportChangeLen;
   3805                    }
   3806                  }
   3807                  else
   3808                  {
   3809                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000A7   12....       LCALL   ?Subroutine69 & 0xFFFF
   3810                    pBuf += 2;
   3811                  }
   \                     ??CrossCallReturnLabel_109:
   \   0000AA   A3           INC     DPTR
   \   0000AB   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   0000AE   5001         JNC     ??zclParseInReadReportCfgRspCmd_9
   \   0000B0   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000B1   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0000B3   E5..         MOV     A,?V5
   \   0000B5   C3           CLR     C
   \   0000B6   95..         SUBB    A,?V4
   \   0000B8   4003         JC      $+5
   \   0000BA   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   \   0000BD   E5..         MOV     A,?V5
   \   0000BF   75F00D       MOV     B,#0xd
   \   0000C2   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   0000C5   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   0000C8   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   0000CB   FD           MOV     R5,A
   \   0000CC   85..82       MOV     DPL,?V0
   \   0000CF   85..83       MOV     DPH,?V1
   \   0000D2   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   0000D5   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   0000D8   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   0000DB   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000DD   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000DE   EC           MOV     A,R4
   \   0000DF   70D0         JNZ     ??zclParseInReadReportCfgRspCmd_9
   \   0000E1   8E82         MOV     DPL,R6
   \   0000E3   8F83         MOV     DPH,R7
   \   0000E5   A3           INC     DPTR
   \   0000E6   A882         MOV     R0,DPL
   \   0000E8   A983         MOV     R1,DPH
   \   0000EA   8E82         MOV     DPL,R6
   \   0000EC   8F83         MOV     DPH,R7
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V10,A
   \   0000F1   ED           MOV     A,R5
   \   0000F2   70B3         JNZ     ??zclParseInReadReportCfgRspCmd_8
   \   0000F4   E5..         MOV     A,?V0
   \   0000F6   2404         ADD     A,#0x4
   \   0000F8   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000FB   A3           INC     DPTR
   \   0000FC   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   0000FF   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   000101   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   000102   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000105   A3           INC     DPTR
   \   000106   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   000109   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   00010B   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   00010C                ; Setup parameters for call to function zclAnalogDataType
   \   00010C   A9..         MOV     R1,?V10
   \   00010E   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000111   E9           MOV     A,R1
   \   000112   609D         JZ      ??zclParseInReadReportCfgRspCmd_9
   \   000114                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000114   EE           MOV     A,R6
   \   000115   FC           MOV     R4,A
   \   000116   EF           MOV     A,R7
   \   000117   FD           MOV     R5,A
   \   000118   AA..         MOV     R2,?V2
   \   00011A   AB..         MOV     R3,?V3
   \   00011C   85..82       MOV     DPL,?V8
   \   00011F   85..83       MOV     DPH,?V9
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000127   E5..         MOV     A,?V0
   \   000129   240B         ADD     A,#0xb
   \   00012B   F582         MOV     DPL,A
   \   00012D   E4           CLR     A
   \   00012E   35..         ADDC    A,?V1
   \   000130   F583         MOV     DPH,A
   \   000132   E5..         MOV     A,?V2
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V3
   \   000138   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine113 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000141   5002         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   000143   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   000145   E5..         MOV     A,?V2
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V2,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V3
   \   00014E   F5..         MOV     ?V3,A
   \   000150   02....       LJMP    ??zclParseInReadReportCfgRspCmd_9 & 0xFFFF
   3812                }
   3813              }
   3814            }
   3815          
   3816            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3817          }
   3818          
   3819          /*********************************************************************
   3820           * @fn      zclParseInReportCmd
   3821           *
   3822           * @brief   Parse the "Profile" Report Command
   3823           *
   3824           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3825           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3826           *
   3827           * @param   pCmd - pointer to incoming data to parse
   3828           *
   3829           * @return  pointer to the parsed command structure
   3830           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3831          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   3832          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine75 & 0xFFFF
   3833            zclReportCmd_t *reportCmd;
   3834            uint8 *pBuf = pCmd->pData;
   3835            uint16 attrDataLen;
   3836            uint8 *dataPtr;
   3837            uint8 numAttr = 0;
   3838            uint8 hdrLen;
   3839            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_120:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_216
   3840          
   3841            // find out the number of attributes and the length of attribute data
   3842            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3843            {
   3844              uint8 dataType;
   3845          
   3846              numAttr++;
   \                     ??zclParseInReportCmd_0:
   \   00000A   05..         INC     ?V7
   3847              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInReportCmd_1
   \   000012   0F           INC     R7
   3848          
   3849              dataType = *pBuf++;
   \                     ??zclParseInReportCmd_1:
   \   000013   12....       LCALL   ?Subroutine84 & 0xFFFF
   3850          
   3851              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_136:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine116 & 0xFFFF
   3852              pBuf += attrDataLen; // move pass attribute data
   3853          
   3854              // add padding if needed
   3855              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_204:
   \   00001C   5007         JNC     ??zclParseInReportCmd_2
   3856              {
   3857                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInReportCmd_2
   \   000023   05..         INC     ?V1
   3858              }
   3859          
   3860              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000025   12....       LCALL   ?Subroutine122 & 0xFFFF
   3861            }
   \                     ??CrossCallReturnLabel_216:
   \   000028   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   00002B   40DD         JC      ??zclParseInReportCmd_0
   3862          
   3863            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   00002D   75F005       MOV     B,#0x5
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   3864          
   3865            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   3866            if (reportCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   6047         JZ      ??zclParseInReportCmd_3
   3867            {
   3868              uint8 i;
   3869              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine56 & 0xFFFF
   3870              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3871          
   3872              reportCmd->numAttr = numAttr;
   3873              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_65:
   \   00004C   803B         SJMP    ??CrossCallReturnLabel_214
   3874              {
   3875                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_4:
   \   00004E   12....       LCALL   ?Subroutine14 & 0xFFFF
   3876          
   3877                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3878                pBuf += 2;
   \                     ??CrossCallReturnLabel_362:
   \   000051   5001         JNC     ??zclParseInReportCmd_5
   \   000053   0F           INC     R7
   3879                reportRec->dataType = *pBuf++;
   \                     ??zclParseInReportCmd_5:
   \   000054   12....       LCALL   ?Subroutine25 & 0xFFFF
   3880          
   3881                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_19:
   \   000057   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005A   8A..         MOV     ?V0,R2
   \   00005C   8B..         MOV     ?V1,R3
   3882                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   00005E                ; Setup parameters for call to function osal_memcpy
   \   00005E   8E..         MOV     ?V4,R6
   \   000060   8F..         MOV     ?V5,R7
   \   000062   75..00       MOV     ?V6,#0x0
   \   000065   78..         MOV     R0,#?V4
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006A   AC..         MOV     R4,?V0
   \   00006C   AD..         MOV     R5,?V1
   \   00006E   AA..         MOV     R2,?V2
   \   000070   AB..         MOV     R3,?V3
   \   000072   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000075   7403         MOV     A,#0x3
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   3883                reportRec->attrData = dataPtr;
   \   00007A   12....       LCALL   ?Subroutine20 & 0xFFFF
   3884          
   3885                pBuf += attrDataLen; // move pass attribute data
   3886          
   3887                // advance attribute data pointer
   3888                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_374:
   \   00007D   5007         JNC     ??zclParseInReportCmd_6
   3889                {
   3890                  attrDataLen++;
   \   00007F   05..         INC     ?V0
   \   000081   04           INC     A
   \   000082   7002         JNZ     ??zclParseInReportCmd_6
   \   000084   05..         INC     ?V1
   3891                }
   3892          
   3893                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_6:
   \   000086   12....       LCALL   ?Subroutine121 & 0xFFFF
   3894              }
   \                     ??CrossCallReturnLabel_214:
   \   000089   E5..         MOV     A,?V8
   \   00008B   C3           CLR     C
   \   00008C   95..         SUBB    A,?V7
   \   00008E   40BE         JC      ??zclParseInReportCmd_4
   3895            }
   3896          
   3897            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   000090                REQUIRE ?Subroutine6
   \   000090                ; // Fall through to label ?Subroutine6
   3898          }
   3899          #endif // ZCL_REPORT
   3900          
   3901          /*********************************************************************
   3902           * @fn      zclParseInDefaultRspCmd
   3903           *
   3904           * @brief   Parse the "Profile" Default Response Command
   3905           *
   3906           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3907           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3908           *
   3909           * @param   pCmd - pointer to incoming data to parse
   3910           *
   3911           * @return  pointer to the parsed command structure
   3912           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3913          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3914          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3915            zclDefaultRspCmd_t *defaultRspCmd;
   3916            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine108 & 0xFFFF
   3917          
   3918            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_179:
   \   00000F                ; Setup parameters for call to function osal_mem_alloc
   \   00000F   7A02         MOV     R2,#0x2
   \   000011   7B00         MOV     R3,#0x0
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3919            if ( defaultRspCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   600B         JZ      ??zclParseInDefaultRspCmd_0
   3920            {
   3921              defaultRspCmd->commandID = *pBuf++;
   \   00001A   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   00001D   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   3922              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_312:
   \   000020   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   3923            }
   \                     ??CrossCallReturnLabel_425:
   \   000023   A3           INC     DPTR
   \   000024   F0           MOVX    @DPTR,A
   3924          
   3925            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000025   02....       LJMP    ?Subroutine2 & 0xFFFF
   3926          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_448:
   \   000003   22           RET
   3927          
   3928          #ifdef ZCL_DISCOVER
   3929          /*********************************************************************
   3930           * @fn      zclParseInDiscAttrsCmd
   3931           *
   3932           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3933           *
   3934           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3935           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3936           *
   3937           * @param   pCmd - pointer to incoming data to parse
   3938           *
   3939           * @return  pointer to the parsed command structure
   3940           */
   3941          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3942          {
   3943            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3944            uint8 *pBuf = pCmd->pData;
   3945          
   3946            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3947            if ( pDiscoverCmd != NULL )
   3948            {
   3949              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3950              pBuf += 2;
   3951              pDiscoverCmd->maxAttrIDs = *pBuf;
   3952            }
   3953          
   3954            return ( (void *)pDiscoverCmd );
   3955          }
   3956          
   3957          /*********************************************************************
   3958           * @fn      zclParseInDiscAttrsRspCmd
   3959           *
   3960           * @brief   Parse the "Profile" Discovery Response Commands
   3961           *
   3962           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3963           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3964           *
   3965           * @param   pCmd - pointer to incoming data to parse
   3966           *
   3967           * @return  pointer to the parsed command structure
   3968           */
   3969          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3970          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3971          {
   3972            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3973            uint8 *pBuf = pCmd->pData;
   3974            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3975          
   3976            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3977                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3978          
   3979            if ( pDiscoverRspCmd != NULL )
   3980            {
   3981              uint8 i;
   3982          
   3983              pDiscoverRspCmd->discComplete = *pBuf++;
   3984              pDiscoverRspCmd->numAttr = numAttr;
   3985          
   3986              for ( i = 0; i < numAttr; i++ )
   3987              {
   3988                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3989                pBuf += 2;
   3990                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3991              }
   3992            }
   3993          
   3994            return ( (void *)pDiscoverRspCmd );
   3995          }
   3996          
   3997          /*********************************************************************
   3998           * @fn      zclParseInDiscCmdsCmd
   3999           *
   4000           * @brief   Parse the "Profile" Discovery Commands
   4001           *
   4002           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4003           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4004           *
   4005           * @param   pCmd - pointer to incoming data to parse
   4006           *
   4007           * @return  pointer to the parsed command structure
   4008           */
   4009          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   4010          {
   4011            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4012            uint8 *pBuf = pCmd->pData;
   4013          
   4014            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   4015            if ( pDiscoverCmd != NULL )
   4016            {
   4017              pDiscoverCmd->startCmdID = *pBuf++;
   4018              pDiscoverCmd->maxCmdID = *pBuf++;
   4019            }
   4020          
   4021            return ( (void *)pDiscoverCmd );
   4022          }
   4023          
   4024          /*********************************************************************
   4025           * @fn      zclParseInDiscCmdsRspCmd
   4026           *
   4027           * @brief   Parse the Discover Commands Response Command
   4028           *
   4029           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4030           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4031           *
   4032           * @param   pCmd - pointer to incoming data to parse
   4033           *
   4034           * @return  pointer to the parsed command structure
   4035           */
   4036          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4037          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   4038          {
   4039            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   4040            uint8 *pBuf = pCmd->pData;
   4041            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   4042          
   4043              // allocate memory for size of structure plus variable array
   4044            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   4045                              ( numCmds * sizeof(uint8) ) );
   4046            if ( pDiscoverRspCmd != NULL )
   4047            {
   4048              uint8 i;
   4049              pDiscoverRspCmd->discComplete = *pBuf++;
   4050              pDiscoverRspCmd->numCmd = numCmds;
   4051          
   4052              for ( i = 0; i < numCmds; i++ )
   4053              {
   4054                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   4055              }
   4056            }
   4057          
   4058            return ( (void *)pDiscoverRspCmd );
   4059          }
   4060          
   4061          /*********************************************************************
   4062           * @fn      zclParseInDiscAttrsExtRspCmd
   4063           *
   4064           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   4065           *
   4066           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   4067           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   4068           *
   4069           * @param   pCmd - pointer to incoming data to parse
   4070           *
   4071           * @return  pointer to the parsed command structure
   4072           */
   4073          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   4074          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   4075          {
   4076            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   4077            uint8 i;
   4078            uint8 *pBuf = pCmd->pData;
   4079            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   4080          
   4081            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   4082                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   4083          
   4084            if ( pDiscoverRspCmd != NULL )
   4085            {
   4086              pDiscoverRspCmd->discComplete = *pBuf++;
   4087              pDiscoverRspCmd->numAttr = numAttrs;
   4088          
   4089              for ( i = 0; i < numAttrs; i++ )
   4090              {
   4091                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   4092                pBuf += 2;
   4093                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   4094                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   4095              }
   4096            }
   4097          
   4098            return ( (void *)pDiscoverRspCmd );
   4099          }
   4100          #endif // ZCL_DISCOVER
   4101          
   4102          #ifdef ZCL_READ
   4103          /*********************************************************************
   4104           * @fn      zclProcessInReadCmd
   4105           *
   4106           * @brief   Process the "Profile" Read Command
   4107           *
   4108           * @param   pInMsg - incoming message to process
   4109           *
   4110           * @return  TRUE if command processed. FALSE, otherwise.
   4111           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine186_0
   \   000004                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4112          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   4113          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   4114            zclReadCmd_t *readCmd;
   4115            zclReadRspCmd_t *readRspCmd;
   4116            zclAttrRec_t attrRec;
   4117            uint16 len;
   4118            uint8 i;
   4119          
   4120            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V10,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V11,A
   4121          
   4122            // calculate the length of the response status record
   4123            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   4124          
   4125            readRspCmd = zcl_mem_alloc( len );
   \   00001E                ; Setup parameters for call to function osal_mem_alloc
   \   00001E   85..82       MOV     DPL,?V10
   \   000021   F583         MOV     DPH,A
   \   000023   E0           MOVX    A,@DPTR
   \   000024   75F006       MOV     B,#0x6
   \   000027   12....       LCALL   ??Subroutine216_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_505:
   \   00002A   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002D   8A..         MOV     ?V0,R2
   \   00002F   8B..         MOV     ?V1,R3
   4126            if ( readRspCmd == NULL )
   \   000031   EA           MOV     A,R2
   \   000032   45..         ORL     A,?V1
   \   000034   7005         JNZ     ??zclProcessInReadCmd_0
   4127            {
   4128              return FALSE; // EMBEDDED RETURN
   \   000036   7900         MOV     R1,#0x0
   \   000038   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   4129            }
   4130          
   4131            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   00003B   85..82       MOV     DPL,?V10
   \   00003E   85..83       MOV     DPH,?V11
   \   000041   12....       LCALL   ?Subroutine100 & 0xFFFF
   4132            for ( i = 0; i < readCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_167:
   \   000044   75..00       MOV     ?V2,#0x0
   \   000047   800B         SJMP    ??zclProcessInReadCmd_2
   4133            {
   4134              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   4135          
   4136              statusRec->attrID = readCmd->attrID[i];
   4137          
   4138              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4139                                   readCmd->attrID[i], &attrRec ) )
   4140              {
   4141                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   4142                {
   4143                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   4144                                                        &(pInMsg->msg->srcAddr), &attrRec );
   4145                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   4146                  {
   4147                    statusRec->data = attrRec.attr.dataPtr;
   4148                    statusRec->dataType = attrRec.attr.dataType;
   4149                  }
   4150                }
   4151                else
   4152                {
   4153                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   4154                }
   4155              }
   4156              else
   4157              {
   4158                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_3:
   \   000049   85..82       MOV     DPL,?V6
   \   00004C   85..83       MOV     DPH,?V7
   \   00004F   7486         MOV     A,#-0x7a
   \                     ??zclProcessInReadCmd_4:
   \   000051   F0           MOVX    @DPTR,A
   4159              }
   \                     ??zclProcessInReadCmd_5:
   \   000052   05..         INC     ?V2
   \                     ??zclProcessInReadCmd_2:
   \   000054   85..82       MOV     DPL,?V10
   \   000057   85..83       MOV     DPH,?V11
   \   00005A   12....       LCALL   ??Subroutine205_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_457:
   \   00005D   4003         JC      $+5
   \   00005F   02....       LJMP    ??zclProcessInReadCmd_6 & 0xFFFF
   \   000062   85..82       MOV     DPL,?V2
   \   000065   A882         MOV     R0,DPL
   \   000067   E8           MOV     A,R0
   \   000068   75F006       MOV     B,#0x6
   \   00006B   A4           MUL     AB
   \   00006C   FA           MOV     R2,A
   \   00006D   ABF0         MOV     R3,B
   \   00006F   E5..         MOV     A,?V0
   \   000071   2A           ADD     A,R2
   \   000072   F582         MOV     DPL,A
   \   000074   E5..         MOV     A,?V1
   \   000076   3B           ADDC    A,R3
   \   000077   F583         MOV     DPH,A
   \   000079   A3           INC     DPTR
   \   00007A   8582..       MOV     ?V4,DPL
   \   00007D   8583..       MOV     ?V5,DPH
   \   000080   E8           MOV     A,R0
   \   000081   28           ADD     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   E4           CLR     A
   \   000084   33           RLC     A
   \   000085   F9           MOV     R1,A
   \   000086   E5..         MOV     A,?V10
   \   000088   28           ADD     A,R0
   \   000089   F582         MOV     DPL,A
   \   00008B   E5..         MOV     A,?V11
   \   00008D   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000090   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000093   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_468:
   \   000096   E5..         MOV     A,?V4
   \   000098   2402         ADD     A,#0x2
   \   00009A   F5..         MOV     ?V6,A
   \   00009C   E4           CLR     A
   \   00009D   35..         ADDC    A,?V5
   \   00009F   F5..         MOV     ?V7,A
   \   0000A1   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_479:
   \   0000A4                ; Setup parameters for call to function zclFindAttrRec
   \   0000A4   A8..         MOV     R0,?XSP + 0
   \   0000A6   A9..         MOV     R1,?XSP + 1
   \   0000A8   88..         MOV     ?V12,R0
   \   0000AA   89..         MOV     ?V13,R1
   \   0000AC   78..         MOV     R0,#?V12
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   8A82         MOV     DPL,R2
   \   0000B3   8B83         MOV     DPH,R3
   \   0000B5   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   0000B8   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000BB   7402         MOV     A,#0x2
   \   0000BD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C0   E9           MOV     A,R1
   \   0000C1   6086         JZ      ??zclProcessInReadCmd_3
   \   0000C3   7405         MOV     A,#0x5
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000CB   5065         JNC     ??zclProcessInReadCmd_7
   \   0000CD   8E82         MOV     DPL,R6
   \   0000CF   8F83         MOV     DPH,R7
   \   0000D1   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   0000D4   2406         ADD     A,#0x6
   \   0000D6   F5..         MOV     ?V8,A
   \   0000D8   E4           CLR     A
   \   0000D9   39           ADDC    A,R1
   \   0000DA   F5..         MOV     ?V9,A
   \   0000DC   7405         MOV     A,#0x5
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000E4   5020         JNC     ??zclProcessInReadCmd_8
   \   0000E6                ; Setup parameters for call to function zclGetAuthorizeCB
   \   0000E6   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000E9   12....       LCALL   ??zclGetAuthorizeCB?relay; Banked call to: zclGetAuthorizeCB
   \   0000EC   8A82         MOV     DPL,R2
   \   0000EE   8B83         MOV     DPH,R3
   \   0000F0   E582         MOV     A,DPL
   \   0000F2   4583         ORL     A,DPH
   \   0000F4   6010         JZ      ??zclProcessInReadCmd_8
   \   0000F6                ; Setup parameters for indirect call
   \   0000F6   7901         MOV     R1,#0x1
   \   0000F8   AC..         MOV     R4,?XSP + 0
   \   0000FA   AD..         MOV     R5,?XSP + 1
   \   0000FC   AA..         MOV     R2,?V8
   \   0000FE   AB..         MOV     R3,?V9
   \   000100   12....       LCALL   ?CALL_IND
   \   000103   E9           MOV     A,R1
   \   000104   8001         SJMP    ??zclProcessInReadCmd_9
   \                     ??zclProcessInReadCmd_8:
   \   000106   E4           CLR     A
   \                     ??zclProcessInReadCmd_9:
   \   000107   85..82       MOV     DPL,?V6
   \   00010A   85..83       MOV     DPH,?V7
   \   00010D   F0           MOVX    @DPTR,A
   \   00010E   6003         JZ      $+5
   \   000110   02....       LJMP    ??zclProcessInReadCmd_5 & 0xFFFF
   \   000113   7406         MOV     A,#0x6
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00011B   A3           INC     DPTR
   \   00011C   A3           INC     DPTR
   \   00011D   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000120   7404         MOV     A,#0x4
   \   000122   12....       LCALL   ?XSTACK_DISP0_8
   \   000125   E0           MOVX    A,@DPTR
   \   000126   85..82       MOV     DPL,?V4
   \   000129   85..83       MOV     DPH,?V5
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   \                     ??zclProcessInReadCmd_7:
   \   000132   85..82       MOV     DPL,?V6
   \   000135   85..83       MOV     DPH,?V7
   \   000138   748F         MOV     A,#-0x71
   \   00013A   02....       LJMP    ??zclProcessInReadCmd_4 & 0xFFFF
   4160            }
   4161          
   4162            // Build and send Read Response command
   4163            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   4164                             readRspCmd, !pInMsg->hdr.fc.direction,
   4165                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_6:
   \   00013D   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_480:
   \   000140                ; Setup parameters for call to function zcl_SendReadRsp
   \   000140   8E82         MOV     DPL,R6
   \   000142   8F83         MOV     DPH,R7
   \   000144   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   000147   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00014A   75..01       MOV     ?V2,#0x1
   \   00014D   78..         MOV     R0,#?V2
   \   00014F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000152   8E82         MOV     DPL,R6
   \   000154   8F83         MOV     DPH,R7
   \   000156   12....       LCALL   ??Subroutine208_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_482:
   \   000159   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015C   78..         MOV     R0,#?V0
   \   00015E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000161   85..82       MOV     DPL,?V8
   \   000164   85..83       MOV     DPH,?V9
   \   000167   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_501:
   \   00016A   E5..         MOV     A,?V8
   \   00016C   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_487:
   \   00016F   35..         ADDC    A,?V9
   \   000171   FB           MOV     R3,A
   \   000172   E5..         MOV     A,?V8
   \   000174   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000177   35..         ADDC    A,?V9
   \   000179   F583         MOV     DPH,A
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   F9           MOV     R1,A
   \   00017D   12....       LCALL   ??zcl_SendReadRsp?relay; Banked call to: zcl_SendReadRsp
   \   000180   7405         MOV     A,#0x5
   \   000182   12....       LCALL   ?DEALLOC_XSTACK8
   4166            zcl_mem_free( readRspCmd );
   \   000185                ; Setup parameters for call to function osal_mem_free
   \   000185   AA..         MOV     R2,?V0
   \   000187   AB..         MOV     R3,?V1
   \   000189   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4167          
   4168            return TRUE;
   \   00018C   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   00018E   740A         MOV     A,#0xa
   \   000190   02....       LJMP    ?Subroutine11 & 0xFFFF
   4169          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine203_0
   \   000006                ; // Fall through to label ??Subroutine203_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine206_0
   \   000002                ; // Fall through to label ??Subroutine206_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine207_0
   \   000004                ; // Fall through to label ??Subroutine207_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_509:
   \   000003   85..82       MOV     DPL,?V8
   \   000006   85..83       MOV     DPH,?V9
   \   000009   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00000C   E5..         MOV     A,?V8
   \   00000E   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000011   35..         ADDC    A,?V9
   \   000013   F583         MOV     DPH,A
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine208_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine209_0
   \   000002                ; // Fall through to label ??Subroutine209_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine211_0:
   \   000000   2406         ADD     A,#0x6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   22           RET
   4170          #endif // ZCL_READ
   4171          
   4172          #ifdef ZCL_WRITE
   4173          /*********************************************************************
   4174           * @fn      processInWriteCmd
   4175           *
   4176           * @brief   Process the "Profile" Write and Write No Response Commands
   4177           *
   4178           * @param   pInMsg - incoming message to process
   4179           *
   4180           * @return  TRUE if command processed. FALSE, otherwise.
   4181           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   7E00         MOV     R6,#0x0
   \   000002   EA           MOV     A,R2
   \   000003   240C         ADD     A,#0xc
   \   000005   F582         MOV     DPL,A
   \   000007   E4           CLR     A
   \   000008   35..         ADDC    A,?V5
   \   00000A   F583         MOV     DPH,A
   \   00000C                REQUIRE ??Subroutine198_0
   \   00000C                ; // Fall through to label ??Subroutine198_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ??Subroutine204_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000009   85..82       MOV     DPL,?V4
   \   00000C   85..83       MOV     DPH,?V5
   \   00000F                REQUIRE ??Subroutine202_0
   \   00000F                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4182          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   4183          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4184            zclWriteCmd_t *writeCmd;
   4185            zclWriteRspCmd_t *writeRspCmd;
   4186            uint8 sendRsp = FALSE;
   \   00000E   7F00         MOV     R7,#0x0
   4187            uint8 j = 0;
   \   000010   12....       LCALL   ?Subroutine99 & 0xFFFF
   4188            uint8 i;
   4189          
   4190            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_401:
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   4191            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \                     ??CrossCallReturnLabel_469:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   A3           INC     DPTR
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6402         XRL     A,#0x2
   \   00002A   701B         JNZ     ??zclProcessInWriteCmd_0
   4192            {
   4193              // We need to send a response back - allocate space for it
   4194              writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4195                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   00002C                ; Setup parameters for call to function osal_mem_alloc
   \   00002C   85..82       MOV     DPL,?XSP + 0
   \   00002F   85..83       MOV     DPH,?XSP + 1
   \   000032   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000035   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000038   8A..         MOV     ?V0,R2
   \   00003A   8B..         MOV     ?V1,R3
   4196              if ( writeRspCmd == NULL )
   \   00003C   EA           MOV     A,R2
   \   00003D   45..         ORL     A,?V1
   \   00003F   7005         JNZ     ??zclProcessInWriteCmd_1
   4197              {
   4198                return FALSE; // EMBEDDED RETURN
   \   000041   7900         MOV     R1,#0x0
   \   000043   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   4199              }
   4200          
   4201              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   000046   0F           INC     R7
   4202            }
   4203          
   4204            for ( i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_0:
   \   000047   8E..         MOV     ?V6,R6
   \   000049   801C         SJMP    ??zclProcessInWriteCmd_3
   4205            {
   4206              zclAttrRec_t attrRec;
   4207              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4208          
   4209              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4210                                   statusRec->attrID, &attrRec ) )
   4211              {
   4212                if ( statusRec->dataType == attrRec.attr.dataType )
   4213                {
   4214                  uint8 status;
   4215          
   4216                  // Write the new attribute value
   4217                  if ( attrRec.attr.dataPtr != NULL )
   4218                  {
   4219                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4220                                               &attrRec, statusRec );
   4221                  }
   4222                  else // Use CB
   4223                  {
   4224                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4225                                                      &attrRec, statusRec->attrData );
   4226                  }
   4227          
   4228                  // If successful, a write attribute status record shall NOT be generated
   4229                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   4230                  {
   4231                    // Attribute is read only - move on to the next write attribute record
   4232                    writeRspCmd->attrList[j].status = status;
   4233                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4234                  }
   4235                }
   4236                else
   4237                {
   4238                  // Attribute data type is incorrect - move on to the next write attribute record
   4239                  if ( sendRsp )
   4240                  {
   4241                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4242                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4243                  }
   4244                }
   4245              }
   4246              else
   4247              {
   4248                // Attribute is not supported - move on to the next write attribute record
   4249                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_4:
   \   00004B   EF           MOV     A,R7
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   5015         JNC     ??zclProcessInWriteCmd_5
   4250                {
   4251                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   000050   85..82       MOV     DPL,?V14
   \   000053   85..83       MOV     DPH,?V15
   \   000056   7486         MOV     A,#-0x7a
   4252                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4253                }
   4254              }
   \                     ??zclProcessInWriteCmd_6:
   \   000058   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   00005B   85..82       MOV     DPL,?V12
   \   00005E   85..83       MOV     DPH,?V13
   \   000061   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   000064   0E           INC     R6
   \                     ??zclProcessInWriteCmd_5:
   \   000065   05..         INC     ?V6
   \                     ??zclProcessInWriteCmd_3:
   \   000067   85..82       MOV     DPL,?XSP + 0
   \   00006A   85..83       MOV     DPH,?XSP + 1
   \   00006D   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000070   E5..         MOV     A,?V6
   \   000072   C3           CLR     C
   \   000073   98           SUBB    A,R0
   \   000074   4003         JC      $+5
   \   000076   02....       LJMP    ??zclProcessInWriteCmd_7 & 0xFFFF
   \   000079   E5..         MOV     A,?V6
   \   00007B   75F005       MOV     B,#0x5
   \   00007E   A4           MUL     AB
   \   00007F   F8           MOV     R0,A
   \   000080   A9F0         MOV     R1,B
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00008B   EE           MOV     A,R6
   \   00008C   75F003       MOV     B,#0x3
   \   00008F   A4           MUL     AB
   \   000090   F8           MOV     R0,A
   \   000091   A9F0         MOV     R1,B
   \   000093   E5..         MOV     A,?V0
   \   000095   28           ADD     A,R0
   \   000096   F582         MOV     DPL,A
   \   000098   E5..         MOV     A,?V1
   \   00009A   39           ADDC    A,R1
   \   00009B   F583         MOV     DPH,A
   \   00009D   E582         MOV     A,DPL
   \   00009F   2402         ADD     A,#0x2
   \   0000A1   F5..         MOV     ?V12,A
   \   0000A3   E4           CLR     A
   \   0000A4   3583         ADDC    A,DPH
   \   0000A6   F5..         MOV     ?V13,A
   \   0000A8   A3           INC     DPTR
   \   0000A9   8582..       MOV     ?V14,DPL
   \   0000AC   8583..       MOV     ?V15,DPH
   \   0000AF   85..82       MOV     DPL,?V4
   \   0000B2   85..83       MOV     DPH,?V5
   \   0000B5   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_477:
   \   0000B8                ; Setup parameters for call to function zclFindAttrRec
   \   0000B8   7402         MOV     A,#0x2
   \   0000BA   12....       LCALL   ?XSTACK_DISP100_8
   \   0000BD   88..         MOV     ?V10,R0
   \   0000BF   89..         MOV     ?V11,R1
   \   0000C1   78..         MOV     R0,#?V10
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C6   85..82       MOV     DPL,?V2
   \   0000C9   85..83       MOV     DPH,?V3
   \   0000CC   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000CF   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000D2   7402         MOV     A,#0x2
   \   0000D4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D7   E9           MOV     A,R1
   \   0000D8   7003         JNZ     $+5
   \   0000DA   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   \   0000DD   85..82       MOV     DPL,?V2
   \   0000E0   85..83       MOV     DPH,?V3
   \   0000E3   A3           INC     DPTR
   \   0000E4   A3           INC     DPTR
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F8           MOV     R0,A
   \   0000E7   7406         MOV     A,#0x6
   \   0000E9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EC   E0           MOVX    A,@DPTR
   \   0000ED   68           XRL     A,R0
   \   0000EE   7071         JNZ     ??zclProcessInWriteCmd_8
   \   0000F0   85..82       MOV     DPL,?V4
   \   0000F3   85..83       MOV     DPH,?V5
   \   0000F6   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   0000F9   2414         ADD     A,#0x14
   \   0000FB   F5..         MOV     ?V8,A
   \   0000FD   E4           CLR     A
   \   0000FE   39           ADDC    A,R1
   \   0000FF   F5..         MOV     ?V9,A
   \   000101   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_491:
   \   000104   39           ADDC    A,R1
   \   000105   FB           MOV     R3,A
   \   000106   7408         MOV     A,#0x8
   \   000108   12....       LCALL   ?XSTACK_DISP0_8
   \   00010B   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   00010E   6017         JZ      ??zclProcessInWriteCmd_9
   \   000110                ; Setup parameters for call to function zclWriteAttrData
   \   000110   78..         MOV     R0,#?V2
   \   000112   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000115   7404         MOV     A,#0x4
   \   000117   12....       LCALL   ?XSTACK_DISP102_8
   \   00011A   85..82       MOV     DPL,?V8
   \   00011D   85..83       MOV     DPH,?V9
   \   000120   E0           MOVX    A,@DPTR
   \   000121   F9           MOV     R1,A
   \   000122   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData
   \   000125   801C         SJMP    ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   000127                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000127   85..82       MOV     DPL,?V2
   \   00012A   85..83       MOV     DPH,?V3
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000133   7404         MOV     A,#0x4
   \   000135   12....       LCALL   ?XSTACK_DISP102_8
   \   000138   85..82       MOV     DPL,?V8
   \   00013B   85..83       MOV     DPH,?V9
   \   00013E   E0           MOVX    A,@DPTR
   \   00013F   F9           MOV     R1,A
   \   000140   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteCmd_10:
   \   000143   7402         MOV     A,#0x2
   \   000145   12....       LCALL   ?DEALLOC_XSTACK8
   \   000148   E9           MOV     A,R1
   \   000149   F8           MOV     R0,A
   \   00014A   EF           MOV     A,R7
   \   00014B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00014D   4003         JC      $+5
   \   00014F   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000152   E8           MOV     A,R0
   \   000153   7003         JNZ     $+5
   \   000155   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000158   85..82       MOV     DPL,?V14
   \   00015B   85..83       MOV     DPH,?V15
   \   00015E   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   \                     ??zclProcessInWriteCmd_8:
   \   000161   EF           MOV     A,R7
   \   000162   A2E0         MOV     C,0xE0 /* A   */.0
   \   000164   4003         JC      $+5
   \   000166   02....       LJMP    ??zclProcessInWriteCmd_5 & 0xFFFF
   \   000169   85..82       MOV     DPL,?V14
   \   00016C   85..83       MOV     DPH,?V15
   \   00016F   748D         MOV     A,#-0x73
   \   000171   02....       LJMP    ??zclProcessInWriteCmd_6 & 0xFFFF
   4255            } // for loop
   4256          
   4257            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   000174   EF           MOV     A,R7
   \   000175   A2E0         MOV     C,0xE0 /* A   */.0
   \   000177   5038         JNC     ??zclProcessInWriteCmd_11
   4258            {
   4259              writeRspCmd->numAttr = j;
   \   000179   EE           MOV     A,R6
   \   00017A   85..82       MOV     DPL,?V0
   \   00017D   85..83       MOV     DPH,?V1
   \   000180   F0           MOVX    @DPTR,A
   4260              if ( writeRspCmd->numAttr == 0 )
   \   000181   7003         JNZ     ??CrossCallReturnLabel_48
   4261              {
   4262                // Since all records were written successful, include a single status record
   4263                // in the resonse command with the status field set to SUCCESS and the
   4264                // attribute ID field omitted.
   4265                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000183   12....       LCALL   ?Subroutine44 & 0xFFFF
   4266                writeRspCmd->numAttr = 1;
   4267              }
   4268          
   4269              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4270                                pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4271                                true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_48:
   \   000186   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_443:
   \   000189   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00018C   75..01       MOV     ?V2,#0x1
   \   00018F   78..         MOV     R0,#?V2
   \   000191   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000194   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_483:
   \   000197   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00019A   78..         MOV     R0,#?V0
   \   00019C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00019F   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   0001A2   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0001A5   7405         MOV     A,#0x5
   \   0001A7   12....       LCALL   ?DEALLOC_XSTACK8
   4272              zcl_mem_free( writeRspCmd );
   \   0001AA                ; Setup parameters for call to function osal_mem_free
   \   0001AA   AA..         MOV     R2,?V0
   \   0001AC   AB..         MOV     R3,?V1
   \   0001AE   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4273            }
   4274          
   4275            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0001B1   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   0001B3   740C         MOV     A,#0xc
   \   0001B5   02....       LJMP    ?Subroutine4 & 0xFFFF
   4276          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine208_0
   \   000006                ; // Fall through to label ??Subroutine208_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine211_0
   \   000001                ; // Fall through to label ??Subroutine211_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   12....       LCALL   ?Subroutine162 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?Subroutine156 & 0xFFFF
   \                     ??CrossCallReturnLabel_507:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_511:
   \   000007   EE           MOV     A,R6
   \   000008   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_490:
   \   00000B   3F           ADDC    A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   EE           MOV     A,R6
   \   00000E   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   000011   3F           ADDC    A,R7
   \   000012   F583         MOV     DPH,A
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   8A82         MOV     DPL,R2
   \   000008   F583         MOV     DPH,A
   \   00000A   A3           INC     DPTR
   \   00000B   8582..       MOV     ?V2,DPL
   \   00000E   8583..       MOV     ?V3,DPH
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   F0           MOVX    @DPTR,A
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   04           INC     A
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_412:
   \   00000A   22           RET
   4277          
   4278          /*********************************************************************
   4279           * @fn      zclRevertWriteUndividedCmd
   4280           *
   4281           * @brief   Revert the "Profile" Write Undevided Command
   4282           *
   4283           * @param   pInMsg - incoming message to process
   4284           * @param   curWriteRec - old data
   4285           * @param   numAttr - number of attributes to be reverted
   4286           *
   4287           * @return  none
   4288           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4289          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   4290                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   4291          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   4292            uint8 i;
   4293          
   4294            for ( i = 0; i < numAttr; i++ )
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   741E         MOV     A,#0x1e
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine207_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_478:
   \   00001D   8030         SJMP    ??zclRevertWriteUndividedCmd_0
   4295            {
   4296              zclAttrRec_t attrRec;
   4297              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   4298          
   4299              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4300                                    statusRec->attrID, &attrRec ) )
   4301              {
   4302                break; // should never happen
   4303              }
   4304          
   4305              if ( attrRec.attr.dataPtr != NULL )
   4306              {
   4307                // Just copy the old data back - no need to validate the data
   4308                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   4309                zcl_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   4310              }
   4311              else // Use CB
   4312              {
   4313                // Write the old data back
   4314                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4315                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_1:
   \   00001F   85..82       MOV     DPL,?V2
   \   000022   85..83       MOV     DPH,?V3
   \   000025   12....       LCALL   ?Subroutine108 & 0xFFFF
   4316              }
   \                     ??CrossCallReturnLabel_180:
   \   000028                ; Setup parameters for call to function zclWriteAttrDataUsingCB
   \   000028   8A..         MOV     ?V4,R2
   \   00002A   8B..         MOV     ?V5,R3
   \   00002C   78..         MOV     R0,#?V4
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP102_8
   \   000036   EE           MOV     A,R6
   \   000037   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_488:
   \   00003A   3F           ADDC    A,R7
   \   00003B   FB           MOV     R3,A
   \   00003C   EE           MOV     A,R6
   \   00003D   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000040   3F           ADDC    A,R7
   \   000041   F583         MOV     DPH,A
   \   000043   E0           MOVX    A,@DPTR
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??zclRevertWriteUndividedCmd_2:
   \   00004D   05..         INC     ?V0
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00004F   85....       MOV     ?V4,?V0
   \   000052   C3           CLR     C
   \   000053   E5..         MOV     A,?V4
   \   000055   95..         SUBB    A,?V8
   \   000057   E4           CLR     A
   \   000058   95..         SUBB    A,?V9
   \   00005A   4003         JC      $+5
   \   00005C   02....       LJMP    ??zclRevertWriteUndividedCmd_3 & 0xFFFF
   \   00005F   E5..         MOV     A,?V0
   \   000061   75F005       MOV     B,#0x5
   \   000064   A4           MUL     AB
   \   000065   F8           MOV     R0,A
   \   000066   A9F0         MOV     R1,B
   \   000068   E5..         MOV     A,?V10
   \   00006A   28           ADD     A,R0
   \   00006B   FE           MOV     R6,A
   \   00006C   E5..         MOV     A,?V11
   \   00006E   39           ADDC    A,R1
   \   00006F   FF           MOV     R7,A
   \   000070   85..82       MOV     DPL,?V2
   \   000073   85..83       MOV     DPH,?V3
   \   000076   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   000079   88..         MOV     ?V4,R0
   \   00007B   89..         MOV     ?V5,R1
   \   00007D                ; Setup parameters for call to function zclFindAttrRec
   \   00007D   A8..         MOV     R0,?XSP + 0
   \   00007F   A9..         MOV     R1,?XSP + 1
   \   000081   88..         MOV     ?V6,R0
   \   000083   89..         MOV     ?V7,R1
   \   000085   78..         MOV     R0,#?V6
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   8E82         MOV     DPL,R6
   \   00008C   8F83         MOV     DPH,R7
   \   00008E   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_496:
   \   000091   85..82       MOV     DPL,?V4
   \   000094   85..83       MOV     DPH,?V5
   \   000097   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   00009A   E5..         MOV     A,?V4
   \   00009C   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   00009F   35..         ADDC    A,?V5
   \   0000A1   F583         MOV     DPH,A
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F9           MOV     R1,A
   \   0000A5   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AD   E9           MOV     A,R1
   \   0000AE   6045         JZ      ??zclRevertWriteUndividedCmd_3
   \   0000B0   EE           MOV     A,R6
   \   0000B1   2403         ADD     A,#0x3
   \   0000B3   12....       LCALL   ?Subroutine115 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   0000B6   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   0000B9   7406         MOV     A,#0x6
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   0000C1   EE           MOV     A,R6
   \   0000C2   4F           ORL     A,R7
   \   0000C3   7003         JNZ     $+5
   \   0000C5   02....       LJMP    ??zclRevertWriteUndividedCmd_1 & 0xFFFF
   \   0000C8                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000C8   7404         MOV     A,#0x4
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   E0           MOVX    A,@DPTR
   \   0000CE   F9           MOV     R1,A
   \   0000CF   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000D2   8A..         MOV     ?V6,R2
   \   0000D4   8B..         MOV     ?V7,R3
   \   0000D6   AC..         MOV     R4,?V6
   \   0000D8   AD..         MOV     R5,?V7
   \   0000DA                ; Setup parameters for call to function osal_memcpy
   \   0000DA   85..82       MOV     DPL,?V4
   \   0000DD   85..83       MOV     DPH,?V5
   \   0000E0   12....       LCALL   ?Subroutine66 & 0xFFFF
   4317            } // for loop
   \                     ??CrossCallReturnLabel_102:
   \   0000E3   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000E6   EE           MOV     A,R6
   \   0000E7   FA           MOV     R2,A
   \   0000E8   EF           MOV     A,R7
   \   0000E9   FB           MOV     R3,A
   \   0000EA   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000ED   7403         MOV     A,#0x3
   \   0000EF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F2   02....       LJMP    ??zclRevertWriteUndividedCmd_2 & 0xFFFF
   4318          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   0000F5   740A         MOV     A,#0xa
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FA   02....       LJMP    ??Subroutine168_0 & 0xFFFF
   4319          
   4320          /*********************************************************************
   4321           * @fn      zclProcessInWriteUndividedCmd
   4322           *
   4323           * @brief   Process the "Profile" Write Undivided Command
   4324           *
   4325           * @param   pInMsg - incoming message to process
   4326           *
   4327           * @return  TRUE if command processed. FALSE, otherwise.
   4328           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine182_0
   \   000006                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   4329          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   4330          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   4331            zclWriteCmd_t *writeCmd;
   4332            zclWriteRspCmd_t *writeRspCmd;
   4333            zclAttrRec_t attrRec;
   4334            uint16 dataLen;
   4335            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V8,#0x0
   \   000011   75..00       MOV     ?V9,#0x0
   4336            uint8 j = 0;
   \   000014   12....       LCALL   ?Subroutine99 & 0xFFFF
   4337            uint8 i;
   4338          
   4339            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \                     ??CrossCallReturnLabel_402:
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine206_0 & 0xFFFF
   4340          
   4341            // Allocate space for Write Response Command
   4342            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   4343                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_471:
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   4344            if ( writeRspCmd == NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   4345            {
   4346              return FALSE; // EMBEDDED RETURN
   4347            }
   4348          
   4349            // If any attribute cannot be written, no attribute values are changed. Hence,
   4350            // make sure all the attributes are supported and writable
   4351            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000036   7F00         MOV     R7,#0x0
   \   000038   8039         SJMP    ??zclProcessInWriteUndividedCmd_1
   4352            {
   4353              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4354          
   4355              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4356                                    statusRec->attrID, &attrRec ) )
   4357              {
   4358                // Attribute is not supported - stop here
   4359                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   4360                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4361                break;
   4362              }
   4363          
   4364              if ( statusRec->dataType != attrRec.attr.dataType )
   4365              {
   4366                // Attribute data type is incorrect - stope here
   4367                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   4368                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4369                break;
   4370              }
   4371          
   4372              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   4373              {
   4374                // Attribute is not writable - stop here
   4375                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   4376                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4377                break;
   4378              }
   4379          
   4380              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   4381              {
   4382                // Not authorized to write - stop here
   4383                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   4384                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4385                break;
   4386              }
   4387          
   4388              // Attribute Data length
   4389              if ( attrRec.attr.dataPtr != NULL )
   4390              {
   4391                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   4392              }
   4393              else // Use CB
   4394              {
   4395                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4396                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   00003A   12....       LCALL   ?Subroutine86 & 0xFFFF
   4397              }
   \                     ??CrossCallReturnLabel_139:
   \   00003D   12....       LCALL   ??Subroutine214_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_497:
   \   000040   8882         MOV     DPL,R0
   \   000042   8983         MOV     DPH,R1
   \   000044   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   000047   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   00004A   12....       LCALL   ??zclGetAttrDataLengthUsingCB?relay; Banked call to: zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   00004D   85..82       MOV     DPL,?XSP + 0
   \   000050   85..83       MOV     DPH,?XSP + 1
   \   000053   EA           MOV     A,R2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   EB           MOV     A,R3
   \   000057   12....       LCALL   ?Subroutine47 & 0xFFFF
   4398          
   4399              // add padding if needed
   4400              if ( PADDING_NEEDED( dataLen ) )
   \                     ??CrossCallReturnLabel_55:
   \   00005A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00005C   5003         JNC     ??CrossCallReturnLabel_219
   4401              {
   4402                dataLen++;
   \   00005E   12....       LCALL   ?Subroutine125 & 0xFFFF
   4403              }
   4404          
   4405              curLen += dataLen;
   \                     ??CrossCallReturnLabel_219:
   \   000061   85..82       MOV     DPL,?XSP + 0
   \   000064   85..83       MOV     DPH,?XSP + 1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   25..         ADD     A,?V8
   \   00006A   F5..         MOV     ?V8,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   35..         ADDC    A,?V9
   \   000070   F5..         MOV     ?V9,A
   \   000072   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000073   7402         MOV     A,#0x2
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   00007B   5043         JNC     ??zclProcessInWriteUndividedCmd_4
   \   00007D   EF           MOV     A,R7
   \   00007E   75F005       MOV     B,#0x5
   \   000081   A4           MUL     AB
   \   000082   F8           MOV     R0,A
   \   000083   A9F0         MOV     R1,B
   \   000085   7402         MOV     A,#0x2
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00008D   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   000090   12....       LCALL   ?XSTACK_DISP100_8
   \   000093   88..         MOV     ?V10,R0
   \   000095   89..         MOV     ?V11,R1
   \   000097   78..         MOV     R0,#?V10
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   00009F   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   E9           MOV     A,R1
   \   0000A8   7047         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000AA   85..82       MOV     DPL,?V0
   \   0000AD   85..83       MOV     DPH,?V1
   \   0000B0   A3           INC     DPTR
   \   0000B1   7486         MOV     A,#-0x7a
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   0000B3   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000B6   85..82       MOV     DPL,?V0
   \   0000B9   85..83       MOV     DPH,?V1
   \   0000BC   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_473:
   \   0000BF   0E           INC     R6
   4406            } // for loop
   4407          
   4408            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   0000C0   EE           MOV     A,R6
   \   0000C1   85..82       MOV     DPL,?V0
   \   0000C4   85..83       MOV     DPH,?V1
   \   0000C7   F0           MOVX    @DPTR,A
   4409            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   0000C8   6003         JZ      $+5
   \   0000CA   02....       LJMP    ??zclProcessInWriteUndividedCmd_7 & 0xFFFF
   4410            {
   4411              uint8 *curDataPtr;
   4412              zclWriteRec_t *curWriteRec;
   4413          
   4414              // calculate the length of the current data header
   4415              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   0000CD   75F005       MOV     B,#0x5
   \   0000D0   A4           MUL     AB
   \   0000D1   FF           MOV     R7,A
   4416          
   4417              // Allocate space to keep a copy of the current data
   4418              curWriteRec = (zclWriteRec_t *) zcl_mem_alloc( hdrLen + curLen );
   \   0000D2                ; Setup parameters for call to function osal_mem_alloc
   \   0000D2   25..         ADD     A,?V8
   \   0000D4   FA           MOV     R2,A
   \   0000D5   E4           CLR     A
   \   0000D6   35..         ADDC    A,?V9
   \   0000D8   FB           MOV     R3,A
   \   0000D9   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   0000DC   8A..         MOV     ?V14,R2
   \   0000DE   8B..         MOV     ?V15,R3
   4419              if ( curWriteRec == NULL )
   \   0000E0   EA           MOV     A,R2
   \   0000E1   45..         ORL     A,?V15
   \   0000E3   705C         JNZ     ??zclProcessInWriteUndividedCmd_8
   4420              {
   4421                zcl_mem_free(writeRspCmd );
   \   0000E5                ; Setup parameters for call to function osal_mem_free
   \   0000E5   AA..         MOV     R2,?V0
   \   0000E7   AB..         MOV     R3,?V1
   \   0000E9   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4422                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   0000EC   7900         MOV     R1,#0x0
   \   0000EE   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   4423              }
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000F1   7408         MOV     A,#0x8
   \   0000F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F6   12....       LCALL   ??Subroutine215_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_502:
   \   0000F9   A3           INC     DPTR
   \   0000FA   A3           INC     DPTR
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   69           XRL     A,R1
   \   0000FD   600B         JZ      ??zclProcessInWriteUndividedCmd_10
   \   0000FF   85..82       MOV     DPL,?V0
   \   000102   85..83       MOV     DPH,?V1
   \   000105   A3           INC     DPTR
   \   000106   748D         MOV     A,#-0x73
   \   000108   80A9         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00010A   7409         MOV     A,#0x9
   \   00010C   12....       LCALL   ?XSTACK_DISP0_8
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   A2E1         MOV     C,0xE0 /* A   */.1
   \   000112   400B         JC      ??zclProcessInWriteUndividedCmd_11
   \   000114   85..82       MOV     DPL,?V0
   \   000117   85..83       MOV     DPH,?V1
   \   00011A   A3           INC     DPTR
   \   00011B   7488         MOV     A,#-0x78
   \   00011D   8094         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   00011F   A2E5         MOV     C,0xE0 /* A   */.5
   \   000121   500B         JNC     ??zclProcessInWriteUndividedCmd_12
   \   000123   85..82       MOV     DPL,?V0
   \   000126   85..83       MOV     DPH,?V1
   \   000129   A3           INC     DPTR
   \   00012A   747E         MOV     A,#0x7e
   \   00012C   8085         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   00012E   740A         MOV     A,#0xa
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000136   7003         JNZ     $+5
   \   000138   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   00013B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00013B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00013E   02....       LJMP    ??zclProcessInWriteUndividedCmd_3 & 0xFFFF
   4424          
   4425              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   000141   EA           MOV     A,R2
   \   000142   2F           ADD     A,R7
   \   000143   F5..         MOV     ?V8,A
   \   000145   E4           CLR     A
   \   000146   3B           ADDC    A,R3
   \   000147   F5..         MOV     ?V9,A
   4426          
   4427              // Write the new data over
   4428              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000149   7F00         MOV     R7,#0x0
   \   00014B   8022         SJMP    ??zclProcessInWriteUndividedCmd_13
   4429              {
   4430                uint8 status;
   4431                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   4432                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   4433          
   4434                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4435                                      statusRec->attrID, &attrRec ) )
   4436                {
   4437                  break; // should never happen
   4438                }
   4439          
   4440                // Keep a copy of the current data before before writing the new data over
   4441                curStatusRec->attrID = statusRec->attrID;
   4442                curStatusRec->attrData = curDataPtr;
   4443          
   4444                if ( attrRec.attr.dataPtr != NULL )
   4445                {
   4446                  // Read the current value
   4447                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   4448          
   4449                  // Write the new attribute value
   4450                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4451                                             &attrRec, statusRec );
   4452                }
   4453                else // Use CBs
   4454                {
   4455                  // Read the current value
   4456                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   4457                                          statusRec->attrID, curDataPtr, &dataLen );
   4458                  // Write the new attribute value
   4459                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4460                                                    &attrRec, statusRec->attrData );
   4461                }
   4462          
   4463                // If successful, a write attribute status record shall NOT be generated
   4464                if ( status != ZCL_STATUS_SUCCESS )
   4465                {
   4466                  writeRspCmd->attrList[j].status = status;
   4467                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   4468          
   4469                  // Since this write failed, we need to revert all the pervious writes
   4470                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   4471                  break;
   4472                }
   4473          
   4474                // add padding if needed
   4475                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   00014D   85..82       MOV     DPL,?XSP + 0
   \   000150   85..83       MOV     DPH,?XSP + 1
   \   000153   E0           MOVX    A,@DPTR
   \   000154   A2E0         MOV     C,0xE0 /* A   */.0
   \   000156   5003         JNC     ??CrossCallReturnLabel_220
   4476                {
   4477                  dataLen++;
   \   000158   12....       LCALL   ?Subroutine125 & 0xFFFF
   4478                }
   4479          
   4480                curDataPtr += dataLen;
   \                     ??CrossCallReturnLabel_220:
   \   00015B   85..82       MOV     DPL,?XSP + 0
   \   00015E   85..83       MOV     DPH,?XSP + 1
   \   000161   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000164   E5..         MOV     A,?V8
   \   000166   28           ADD     A,R0
   \   000167   F5..         MOV     ?V8,A
   \   000169   E5..         MOV     A,?V9
   \   00016B   39           ADDC    A,R1
   \   00016C   F5..         MOV     ?V9,A
   \   00016E   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   00016F   7402         MOV     A,#0x2
   \   000171   12....       LCALL   ?XSTACK_DISP0_8
   \   000174   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000177   4003         JC      $+5
   \   000179   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   00017C   EF           MOV     A,R7
   \   00017D   75F005       MOV     B,#0x5
   \   000180   A4           MUL     AB
   \   000181   F8           MOV     R0,A
   \   000182   A9F0         MOV     R1,B
   \   000184   7402         MOV     A,#0x2
   \   000186   12....       LCALL   ?XSTACK_DISP0_8
   \   000189   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   00018C   E5..         MOV     A,?V14
   \   00018E   28           ADD     A,R0
   \   00018F   F5..         MOV     ?V12,A
   \   000191   E5..         MOV     A,?V15
   \   000193   39           ADDC    A,R1
   \   000194   F5..         MOV     ?V13,A
   \   000196   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000199   12....       LCALL   ?XSTACK_DISP100_8
   \   00019C   88..         MOV     ?V10,R0
   \   00019E   89..         MOV     ?V11,R1
   \   0001A0   78..         MOV     R0,#?V10
   \   0001A2   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001A5   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0001A8   12....       LCALL   ??zclFindAttrRec?relay; Banked call to: zclFindAttrRec
   \   0001AB   7402         MOV     A,#0x2
   \   0001AD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B0   E9           MOV     A,R1
   \   0001B1   7003         JNZ     $+5
   \   0001B3   02....       LJMP    ??zclProcessInWriteUndividedCmd_15 & 0xFFFF
   \   0001B6   85..82       MOV     DPL,?V2
   \   0001B9   85..83       MOV     DPH,?V3
   \   0001BC   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   0001BF   85..82       MOV     DPL,?V12
   \   0001C2   85..83       MOV     DPH,?V13
   \   0001C5   E8           MOV     A,R0
   \   0001C6   F0           MOVX    @DPTR,A
   \   0001C7   A3           INC     DPTR
   \   0001C8   E9           MOV     A,R1
   \   0001C9   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0001CC   E5..         MOV     A,?V8
   \   0001CE   F0           MOVX    @DPTR,A
   \   0001CF   A3           INC     DPTR
   \   0001D0   E5..         MOV     A,?V9
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   740A         MOV     A,#0xa
   \   0001D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D8   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   0001DB   6043         JZ      ??zclProcessInWriteUndividedCmd_16
   \   0001DD                ; Setup parameters for call to function zclReadAttrData
   \   0001DD   A8..         MOV     R0,?XSP + 0
   \   0001DF   A9..         MOV     R1,?XSP + 1
   \   0001E1   88..         MOV     ?V6,R0
   \   0001E3   89..         MOV     ?V7,R1
   \   0001E5   78..         MOV     R0,#?V6
   \   0001E7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001EA   7406         MOV     A,#0x6
   \   0001EC   12....       LCALL   ?XSTACK_DISP102_8
   \   0001EF   AA..         MOV     R2,?V8
   \   0001F1   AB..         MOV     R3,?V9
   \   0001F3   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   0001F6   7402         MOV     A,#0x2
   \   0001F8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001FB   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   0001FE                ; Setup parameters for call to function zclWriteAttrData
   \   0001FE   78..         MOV     R0,#?V2
   \   000200   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000203   7406         MOV     A,#0x6
   \   000205   12....       LCALL   ?XSTACK_DISP102_8
   \   000208   E5..         MOV     A,?V6
   \   00020A   12....       LCALL   ??Subroutine211_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_489:
   \   00020D   35..         ADDC    A,?V7
   \   00020F   FB           MOV     R3,A
   \   000210   E5..         MOV     A,?V6
   \   000212   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   000215   35..         ADDC    A,?V7
   \   000217   F583         MOV     DPH,A
   \   000219   E0           MOVX    A,@DPTR
   \   00021A   F9           MOV     R1,A
   \   00021B   12....       LCALL   ??zclWriteAttrData?relay; Banked call to: zclWriteAttrData
   \   00021E   8039         SJMP    ??zclProcessInWriteUndividedCmd_17
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   000220   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000223                ; Setup parameters for call to function zclReadAttrDataUsingCB
   \   000223   A8..         MOV     R0,?XSP + 0
   \   000225   A9..         MOV     R1,?XSP + 1
   \   000227   88..         MOV     ?V10,R0
   \   000229   89..         MOV     ?V11,R1
   \   00022B   78..         MOV     R0,#?V10
   \   00022D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000230   78..         MOV     R0,#?V8
   \   000232   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000235   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000238   12....       LCALL   ??zclReadAttrDataUsingCB?relay; Banked call to: zclReadAttrDataUsingCB
   \   00023B   7404         MOV     A,#0x4
   \   00023D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000240   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000243   A3           INC     DPTR
   \   000244   A3           INC     DPTR
   \   000245   A3           INC     DPTR
   \   000246   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000249   7406         MOV     A,#0x6
   \   00024B   12....       LCALL   ?XSTACK_DISP102_8
   \   00024E   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_492:
   \   000251   39           ADDC    A,R1
   \   000252   FB           MOV     R3,A
   \   000253   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000256   12....       LCALL   ??zclWriteAttrDataUsingCB?relay; Banked call to: zclWriteAttrDataUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000259   7402         MOV     A,#0x2
   \   00025B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00025E   E9           MOV     A,R1
   \   00025F   FB           MOV     R3,A
   \   000260   EB           MOV     A,R3
   \   000261   7003         JNZ     $+5
   \   000263   02....       LJMP    ??zclProcessInWriteUndividedCmd_14 & 0xFFFF
   \   000266   EE           MOV     A,R6
   \   000267   75F003       MOV     B,#0x3
   \   00026A   A4           MUL     AB
   \   00026B   F8           MOV     R0,A
   \   00026C   A9F0         MOV     R1,B
   \   00026E   E5..         MOV     A,?V0
   \   000270   28           ADD     A,R0
   \   000271   F8           MOV     R0,A
   \   000272   E5..         MOV     A,?V1
   \   000274   39           ADDC    A,R1
   \   000275   F9           MOV     R1,A
   \   000276   EB           MOV     A,R3
   \   000277   8882         MOV     DPL,R0
   \   000279   8983         MOV     DPH,R1
   \   00027B   A3           INC     DPTR
   \   00027C   F0           MOVX    @DPTR,A
   \   00027D   85..82       MOV     DPL,?V2
   \   000280   85..83       MOV     DPH,?V3
   \   000283   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000286   EA           MOV     A,R2
   \   000287   F0           MOVX    @DPTR,A
   \   000288   A3           INC     DPTR
   \   000289   EB           MOV     A,R3
   \   00028A   F0           MOVX    @DPTR,A
   \   00028B   0E           INC     R6
   \   00028C                ; Setup parameters for call to function zclRevertWriteUndividedCmd
   \   00028C   8F..         MOV     ?V2,R7
   \   00028E   75..00       MOV     ?V3,#0x0
   \   000291   78..         MOV     R0,#?V2
   \   000293   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000296   AC..         MOV     R4,?V14
   \   000298   AD..         MOV     R5,?V15
   \   00029A   AA..         MOV     R2,?V4
   \   00029C   AB..         MOV     R3,?V5
   \   00029E   12....       LCALL   ??zclRevertWriteUndividedCmd?relay; Banked call to: zclRevertWriteUndividedCmd
   \   0002A1   7402         MOV     A,#0x2
   \   0002A3   12....       LCALL   ?DEALLOC_XSTACK8
   4481              } // for loop
   4482          
   4483              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0002A6   EE           MOV     A,R6
   \   0002A7   85..82       MOV     DPL,?V0
   \   0002AA   85..83       MOV     DPH,?V1
   \   0002AD   F0           MOVX    @DPTR,A
   4484              if ( writeRspCmd->numAttr  == 0 )
   \   0002AE   7003         JNZ     ??CrossCallReturnLabel_49
   4485              {
   4486                // Since all records were written successful, include a single status record
   4487                // in the resonse command with the status field set to SUCCESS and the
   4488                // attribute ID field omitted.
   4489                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0002B0   12....       LCALL   ?Subroutine44 & 0xFFFF
   4490                writeRspCmd->numAttr = 1;
   4491              }
   4492          
   4493              zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_49:
   \   0002B3                ; Setup parameters for call to function osal_mem_free
   \   0002B3   AA..         MOV     R2,?V14
   \   0002B5   AB..         MOV     R3,?V15
   \   0002B7   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4494            }
   4495          
   4496            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   4497                              pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction,
   4498                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0002BA   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_444:
   \   0002BD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C0   75..01       MOV     ?V2,#0x1
   \   0002C3   78..         MOV     R0,#?V2
   \   0002C5   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002C8   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_484:
   \   0002CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0002CE   78..         MOV     R0,#?V0
   \   0002D0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002D3   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   0002D6   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0002D9   7405         MOV     A,#0x5
   \   0002DB   12....       LCALL   ?DEALLOC_XSTACK8
   4499            zcl_mem_free( writeRspCmd );
   \   0002DE                ; Setup parameters for call to function osal_mem_free
   \   0002DE   AA..         MOV     R2,?V0
   \   0002E0   AB..         MOV     R3,?V1
   \   0002E2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   4500          
   4501            return TRUE;
   \   0002E5   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0002E7   740E         MOV     A,#0xe
   \   0002E9                REQUIRE ?Subroutine4
   \   0002E9                ; // Fall through to label ?Subroutine4
   4502          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   2401         ADD     A,#0x1
   \   000002   F0           MOVX    @DPTR,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3400         ADDC    A,#0x0
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5..         MOV     ?V6,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F5..         MOV     ?V7,A
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D                ; Setup parameters for call to function zclFindAttrRec
   \   00000D   7404         MOV     A,#0x4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_503:
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000003   EF           MOV     A,R7
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine217_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_508:
   \   000009   85..82       MOV     DPL,?V6
   \   00000C   85..83       MOV     DPH,?V7
   \   00000F   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   000012   E5..         MOV     A,?V6
   \   000014   12....       LCALL   ?Subroutine155 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000017   35..         ADDC    A,?V7
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_HandleExternal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getParsedTransSeqNum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerAttrList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerAttrList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRecsList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRecsList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindAttrRec?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindAttrRec

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetReadWriteCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetReadWriteCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAuthorizeCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAuthorizeCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAnalogDataType?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_BuildAnalogData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLengthUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLengthUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclWriteAttrDataUsingCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclWriteAttrDataUsingCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAuthorizeWrite?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAuthorizeWrite

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclRevertWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclRevertWriteUndividedCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   4503          #endif // ZCL_WRITE
   4504          
   4505          #ifdef ZCL_DISCOVER
   4506          /*********************************************************************
   4507           * @fn      zclProcessInDiscAttrs
   4508           *
   4509           * @brief   Process the "Profile" Discover Attributes Commands
   4510           *
   4511           * @param   pInMsg - incoming message to process
   4512           *
   4513           * @return  TRUE if command processed. FALSE, otherwise.
   4514           */
   4515          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   4516          {
   4517            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   4518            zclAttrRec_t attrRec;
   4519            uint16 attrID;
   4520            uint8 numAttrs;
   4521            uint8 i;
   4522          
   4523            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   4524          
   4525            // Find out the number of attributes supported within the specified range
   4526            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   4527            {
   4528              // finds the next attribute on this endpoint/cluster after the range.
   4529              // attributes must be in numerical order in the list.
   4530              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4531              {
   4532                break;
   4533              }
   4534            }
   4535          
   4536            numAttrs = i;  // store range of attributes in buffer
   4537          
   4538              // Process message for either attributes or extended attributes
   4539            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   4540            {
   4541              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   4542            }
   4543            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   4544            {
   4545              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   4546            }
   4547          
   4548            return TRUE;
   4549          }
   4550          
   4551          /*********************************************************************
   4552           * @fn      zclProcessInDiscAttrsCmd
   4553           *
   4554           * @brief   Process the Discover Attributes Command
   4555           *
   4556           * @param   pInMsg - incoming message to process
   4557           *
   4558           * @param   pDiscoverCmd - structure from requesting command
   4559           *
   4560           * @param   attrLenBuf - describes the amount of attributes to be processed
   4561           *
   4562           * @return  none
   4563           */
   4564          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4565          {
   4566            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4567            uint8 discComplete = TRUE;
   4568            zclAttrRec_t attrRec;
   4569            uint16 attrID;
   4570            uint8 i;
   4571          
   4572            // Allocate space for the response command
   4573            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4574                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4575            if ( pDiscoverRsp == NULL )
   4576            {
   4577              return; // EMBEDDED RETURN
   4578            }
   4579          
   4580            if ( numAttrs != 0 )
   4581            {
   4582              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4583              {
   4584                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4585                {
   4586                  break; // should not happen, as numAttrs already calculated
   4587                }
   4588          
   4589                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4590                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4591              }
   4592          
   4593              // Are there more attributes to be discovered?
   4594              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4595              {
   4596                discComplete = FALSE;
   4597              }
   4598            }
   4599          
   4600            pDiscoverRsp->discComplete = discComplete;
   4601            pDiscoverRsp->numAttr = numAttrs;
   4602          
   4603            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4604                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4605                                         true, pInMsg->hdr.transSeqNum );
   4606            zcl_mem_free( pDiscoverRsp );
   4607          
   4608            return;
   4609          }
   4610          
   4611          /*********************************************************************
   4612           * @fn      zclProcessInDiscAttrsExtCmd
   4613           *
   4614           * @brief   Process the Discover Attributes Extended Command
   4615           *
   4616           * @param   pInMsg - incoming message to process
   4617           *
   4618           * @param   pDiscoverCmd - structure from requesting command
   4619           *
   4620           * @param   attrLenBuf - describes the amount of attributes to be processed
   4621           *
   4622           * @return  none
   4623           */
   4624          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4625          {
   4626            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4627            uint8 discComplete = TRUE;
   4628            zclAttrRec_t attrRec;
   4629            uint16 attrID;
   4630            uint8 i;
   4631          
   4632              // Allocate space for the response command
   4633            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4634                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4635            if ( pDiscoverExtRsp == NULL )
   4636            {
   4637              return; // EMBEDDED RETURN
   4638            }
   4639          
   4640          
   4641            if ( numAttrs != 0 )
   4642            {
   4643              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4644              {
   4645                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4646                {
   4647                  break; // Should not happen, as numAttrs already calculated
   4648                }
   4649          
   4650                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4651                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4652                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4653              }
   4654          
   4655              // Are there more attributes to be discovered?
   4656              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4657              {
   4658                discComplete = FALSE;
   4659              }
   4660            }
   4661          
   4662            pDiscoverExtRsp->discComplete = discComplete;
   4663            pDiscoverExtRsp->numAttr = numAttrs;
   4664          
   4665            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4666                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4667                                         true, pInMsg->hdr.transSeqNum );
   4668          
   4669            zcl_mem_free( pDiscoverExtRsp );
   4670          
   4671            return;
   4672          }
   4673          
   4674          /*********************************************************************
   4675           * @fn      zclProcessInDiscCmd
   4676           *
   4677           * @brief   Process the "Profile" Discover Command
   4678           *
   4679           * @param   pInMsg - incoming message to process
   4680           *
   4681           * @return  TRUE if command processed. FALSE, otherwise.
   4682           */
   4683          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4684          {
   4685            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4686            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4687            ZStatus_t status;
   4688            zclCommandRec_t cmdRec;
   4689            uint8 cmdID;
   4690            uint8 i;
   4691            uint8 j;
   4692          
   4693            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4694          
   4695            // Find out the number of commands supported within the specified range
   4696            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4697            {
   4698              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4699              {
   4700                break;  // Command not supported
   4701              }
   4702            }
   4703          
   4704            // Allocate space for the response command
   4705            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4706          
   4707            if ( cmdRsp.pCmdID == NULL )
   4708            {
   4709              return FALSE; // EMBEDDED RETURN
   4710            }
   4711          
   4712            if ( i != 0 )
   4713            {
   4714              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4715              {
   4716                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4717                {
   4718                  break; // Attribute not supported
   4719                }
   4720          
   4721                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4722              }
   4723            }
   4724          
   4725            // Are there more commands to be discovered?
   4726            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4727            {
   4728              cmdRsp.discComplete = FALSE;
   4729            }
   4730            else
   4731            {
   4732              cmdRsp.discComplete = TRUE;
   4733            }
   4734          
   4735            // pass the command requested
   4736            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4737          
   4738            // store number of commands returned
   4739            cmdRsp.numCmd = j;
   4740          
   4741            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4742                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4743                                                true, pInMsg->hdr.transSeqNum );
   4744          
   4745            zcl_mem_free( cmdRsp.pCmdID );
   4746          
   4747            if ( status == ZSuccess )
   4748            {
   4749              return TRUE;
   4750            }
   4751            else
   4752            {
   4753              return FALSE;
   4754            }
   4755          }
   4756          
   4757          #endif // ZCL_DISCOVER
   4758          
   4759          /*********************************************************************
   4760          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     24   zclAnalogDataType
      0     29   zclAuthorizeWrite
        0     14   -> zclGetAuthorizeCB
      1     42   zclBuildHdr
      2     54   zclFindAttrRec
        0     14   -> zclFindAttrRecsList
      2     14   zclFindAttrRecsList
      0     19   zclFindClusterOption
      0     47   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     60   zclGetAttrDataLengthUsingCB
        0     18   -> zclGetReadWriteCB
      0     42   zclGetAuthorizeCB
        0     10   -> zclFindAttrRecsList
      0     47   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     24   zclGetDataTypeLength
      0     28   zclGetReadWriteCB
        0     10   -> zclFindAttrRecsList
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     11   zclParseInConfigReportRspCmd
        0     11   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     37   zclProcessInReadCmd
        0     32   -> osal_mem_alloc
        0     32   -> osal_mem_free
        0     34   -> zclFindAttrRec
        0     32   -> zclGetAuthorizeCB
        0     37   -> zcl_SendReadRsp
      1     41   zclProcessInWriteCmd
        0     36   -> osal_mem_alloc
        0     36   -> osal_mem_free
        0     38   -> zclFindAttrRec
        0     38   -> zclWriteAttrData
        0     38   -> zclWriteAttrDataUsingCB
        0     41   -> zcl_SendWriteRsp
      1     43   zclProcessInWriteUndividedCmd
        0     38   -> osal_mem_alloc
        0     38   -> osal_mem_free
        0     40   -> zclFindAttrRec
        0     38   -> zclGetAttrDataLength
        0     38   -> zclGetAttrDataLengthUsingCB
        0     40   -> zclReadAttrData
        0     42   -> zclReadAttrDataUsingCB
        0     40   -> zclRevertWriteUndividedCmd
        0     40   -> zclWriteAttrData
        0     40   -> zclWriteAttrDataUsingCB
        0     43   -> zcl_SendWriteRsp
      0     58   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      0     62   zclReadAttrDataUsingCB
        0     16   -> zclGetReadWriteCB
      0     73   zclRevertWriteUndividedCmd
        0     33   -> osal_memcpy
        0     32   -> zclFindAttrRec
        0     30   -> zclGetAttrDataLength
        0     32   -> zclWriteAttrDataUsingCB
      1     42   zclSerializeData
        0     18   -> osal_buffer_uint32
        0     17   -> osal_memcpy
      0     47   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      0     58   zclWriteAttrData
        0     18   -> osal_memcpy
        0     15   -> zclAuthorizeWrite
        0     15   -> zclGetAttrDataLength
      0     58   zclWriteAttrDataUsingCB
        0     14   -> zclAuthorizeWrite
        0     14   -> zclGetReadWriteCB
      1     36   zcl_BuildAnalogData
        0     16   -> zclGetAttrDataLength
      0     64   zcl_DeviceOperational
        0     25   -> zclFindAttrRec
        0     25   -> zclReadAttrData
      1     10   zcl_HandleExternal
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption
        0     39   -> zcl_DeviceOperational
        0     44   -> zcl_SendDefaultRspCmd
      0     34   zcl_ReadAttrData
        0     28   -> zclFindAttrRec
        0     28   -> zclReadAttrData
        0     30   -> zclReadAttrDataUsingCB
      1     74   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     33   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     40   zcl_SendConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     40   zcl_SendReadReportCfgRspCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     72   zcl_SendReadRsp
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclGetAttrDataLength
        0     24   -> zclGetAttrDataLengthUsingCB
        0     28   -> zclReadAttrDataUsingCB
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     37   zcl_SendWriteRequest
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     74   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerAttrList
        0     12   -> osal_mem_alloc
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      2      0   zcl_registerForMsg
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      0     14   zcl_registerReadWriteCB
        0     14   -> zclFindAttrRecsList
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       9  ??Subroutine166_0
       6  ??Subroutine167_0
       5  ??Subroutine168_0
       7  ??Subroutine169_0
       1  ??Subroutine170_0
       4  ??Subroutine171_0
       6  ??Subroutine172_0
       4  ??Subroutine173_0
      12  ??Subroutine174_0
       9  ??Subroutine175_0
       9  ??Subroutine176_0
       8  ??Subroutine177_0
       5  ??Subroutine178_0
       7  ??Subroutine179_0
       6  ??Subroutine180_0
       5  ??Subroutine181_0
       8  ??Subroutine182_0
       1  ??Subroutine183_0
       3  ??Subroutine184_0
       4  ??Subroutine185_0
       6  ??Subroutine186_0
      12  ??Subroutine187_0
      36  ??Subroutine188_0
       9  ??Subroutine189_0
      14  ??Subroutine190_0
       3  ??Subroutine191_0
      13  ??Subroutine192_0
       7  ??Subroutine193_0
       9  ??Subroutine194_0
       8  ??Subroutine195_0
       1  ??Subroutine196_0
       5  ??Subroutine197_0
       4  ??Subroutine198_0
       5  ??Subroutine199_0
       6  ??Subroutine200_0
       5  ??Subroutine201_0
       6  ??Subroutine202_0
       6  ??Subroutine203_0
       6  ??Subroutine204_0
       7  ??Subroutine205_0
       6  ??Subroutine206_0
       8  ??Subroutine207_0
       2  ??Subroutine208_0
       8  ??Subroutine209_0
       5  ??Subroutine210_0
       5  ??Subroutine211_0
       1  ??Subroutine212_0
       2  ??Subroutine213_0
       4  ??Subroutine214_0
       9  ??Subroutine215_0
      10  ??Subroutine216_0
       5  ??Subroutine217_0
       6  ??zclAnalogDataType?relay
       6  ??zclAuthorizeWrite?relay
       6  ??zclBuildHdr?relay
       6  ??zclFindAttrRec?relay
       6  ??zclFindAttrRecsList?relay
       6  ??zclFindClusterOption?relay
       6  ??zclGetAttrDataLength?relay
       6  ??zclGetAttrDataLengthUsingCB?relay
       6  ??zclGetAuthorizeCB?relay
       6  ??zclGetClusterOption?relay
       6  ??zclGetDataTypeLength?relay
       6  ??zclGetReadWriteCB?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInConfigReportCmd?relay
       6  ??zclParseInConfigReportRspCmd?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadReportCfgCmd?relay
       6  ??zclParseInReadReportCfgRspCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInReportCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclReadAttrData?relay
       6  ??zclReadAttrDataUsingCB?relay
       6  ??zclRevertWriteUndividedCmd?relay
       6  ??zclSerializeData?relay
       6  ??zclSetSecurityOption?relay
       6  ??zclWriteAttrData?relay
       6  ??zclWriteAttrDataUsingCB?relay
       6  ??zcl_BuildAnalogData?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_HandleExternal?relay
       6  ??zcl_Init?relay
       6  ??zcl_ProcessMessageMSG?relay
       6  ??zcl_ReadAttrData?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendConfigReportCmd?relay
       6  ??zcl_SendConfigReportRspCmd?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadReportCfgCmd?relay
       6  ??zcl_SendReadReportCfgRspCmd?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendReportCmd?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getParsedTransSeqNum?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerAttrList?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerReadWriteCB?relay
       6  ??zcl_registerValidateAttrData?relay
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
       7  ?Subroutine100
       4  ?Subroutine101
      16  ?Subroutine102
       6  ?Subroutine103
      21  ?Subroutine104
       8  ?Subroutine105
      13  ?Subroutine106
       7  ?Subroutine107
       4  ?Subroutine108
      12  ?Subroutine109
       6  ?Subroutine11
      10  ?Subroutine110
       4  ?Subroutine111
      12  ?Subroutine112
      13  ?Subroutine113
      12  ?Subroutine114
      12  ?Subroutine115
      15  ?Subroutine116
      21  ?Subroutine117
      16  ?Subroutine118
       8  ?Subroutine119
       5  ?Subroutine12
      19  ?Subroutine120
      15  ?Subroutine121
      13  ?Subroutine122
      12  ?Subroutine123
       2  ?Subroutine124
       9  ?Subroutine125
       9  ?Subroutine126
      11  ?Subroutine127
       3  ?Subroutine128
      10  ?Subroutine129
      47  ?Subroutine13
       7  ?Subroutine130
       6  ?Subroutine131
      16  ?Subroutine132
       2  ?Subroutine133
       5  ?Subroutine134
       7  ?Subroutine135
      12  ?Subroutine136
       3  ?Subroutine137
       4  ?Subroutine138
      14  ?Subroutine139
       5  ?Subroutine14
       9  ?Subroutine140
      10  ?Subroutine141
      12  ?Subroutine142
       4  ?Subroutine143
       4  ?Subroutine144
       6  ?Subroutine145
       4  ?Subroutine146
      11  ?Subroutine147
       9  ?Subroutine148
       5  ?Subroutine149
      12  ?Subroutine15
       9  ?Subroutine150
       5  ?Subroutine151
      16  ?Subroutine152
      11  ?Subroutine153
       1  ?Subroutine154
       6  ?Subroutine155
       3  ?Subroutine156
       3  ?Subroutine157
       8  ?Subroutine158
       8  ?Subroutine159
      12  ?Subroutine16
      13  ?Subroutine160
       6  ?Subroutine161
       8  ?Subroutine162
       5  ?Subroutine163
       8  ?Subroutine164
       5  ?Subroutine165
       6  ?Subroutine17
       4  ?Subroutine18
      22  ?Subroutine19
       5  ?Subroutine2
      15  ?Subroutine20
      12  ?Subroutine21
      19  ?Subroutine22
      24  ?Subroutine23
      20  ?Subroutine24
      17  ?Subroutine25
      11  ?Subroutine26
       2  ?Subroutine27
       9  ?Subroutine28
      11  ?Subroutine29
       5  ?Subroutine3
       1  ?Subroutine30
       6  ?Subroutine31
      12  ?Subroutine32
       4  ?Subroutine33
      10  ?Subroutine34
       3  ?Subroutine35
      29  ?Subroutine36
      11  ?Subroutine37
      11  ?Subroutine38
       8  ?Subroutine39
       3  ?Subroutine4
      14  ?Subroutine40
       2  ?Subroutine41
       4  ?Subroutine42
       7  ?Subroutine43
      12  ?Subroutine44
      10  ?Subroutine45
       4  ?Subroutine46
       9  ?Subroutine47
      30  ?Subroutine48
       5  ?Subroutine49
       4  ?Subroutine5
       7  ?Subroutine50
       5  ?Subroutine51
       6  ?Subroutine52
      24  ?Subroutine53
      18  ?Subroutine54
       6  ?Subroutine55
      32  ?Subroutine56
       4  ?Subroutine57
       6  ?Subroutine58
      18  ?Subroutine59
       4  ?Subroutine6
       6  ?Subroutine60
       3  ?Subroutine61
      23  ?Subroutine62
      18  ?Subroutine63
      15  ?Subroutine64
       8  ?Subroutine65
       9  ?Subroutine66
      10  ?Subroutine67
       9  ?Subroutine68
      23  ?Subroutine69
       3  ?Subroutine7
       6  ?Subroutine70
      11  ?Subroutine71
       6  ?Subroutine72
      14  ?Subroutine73
      13  ?Subroutine74
      30  ?Subroutine75
      22  ?Subroutine76
       7  ?Subroutine77
      12  ?Subroutine78
       4  ?Subroutine79
       5  ?Subroutine8
       6  ?Subroutine80
      12  ?Subroutine81
       4  ?Subroutine82
       5  ?Subroutine83
      16  ?Subroutine84
      11  ?Subroutine85
      10  ?Subroutine86
      10  ?Subroutine87
       1  ?Subroutine88
       4  ?Subroutine89
       5  ?Subroutine9
       1  ?Subroutine90
      17  ?Subroutine91
       4  ?Subroutine92
      12  ?Subroutine93
      11  ?Subroutine94
       8  ?Subroutine95
       4  ?Subroutine96
       4  ?Subroutine97
       5  ?Subroutine98
      12  ?Subroutine99
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
      60  zclAuthorizeWrite
      88  zclBuildHdr
      92  zclCmdTable
     131  zclFindAttrRec
      37  zclFindAttrRecsList
     103  zclFindClusterOption
      63  zclGetAttrDataLength
      98  zclGetAttrDataLengthUsingCB
      27  zclGetAuthorizeCB
      31  zclGetClusterOption
     166  zclGetDataTypeLength
      29  zclGetReadWriteCB
     199  zclParseHdr
     342  zclParseInConfigReportCmd
     120  zclParseInConfigReportRspCmd
      40  zclParseInDefaultRspCmd
     104  zclParseInReadCmd
      72  zclParseInReadReportCfgCmd
     342  zclParseInReadReportCfgRspCmd
     277  zclParseInReadRspCmd
     144  zclParseInReportCmd
     147  zclParseInWriteCmd
     107  zclParseInWriteRspCmd
     403  zclProcessInReadCmd
     440  zclProcessInWriteCmd
     745  zclProcessInWriteUndividedCmd
     109  zclReadAttrData
      92  zclReadAttrDataUsingCB
     253  zclRevertWriteUndividedCmd
     343  zclSerializeData
      46  zclSetSecurityOption
     154  zclWriteAttrData
     104  zclWriteAttrDataUsingCB
     126  zcl_BuildAnalogData
     123  zcl_DeviceOperational
     174  zcl_HandleExternal
      12  zcl_Init
    1091  zcl_ProcessMessageMSG
     131  zcl_ReadAttrData
       1  zcl_RegisteredMsgTaskID
     429  zcl_SendCommand
     339  zcl_SendConfigReportCmd
     251  zcl_SendConfigReportRspCmd
     136  zcl_SendDefaultRspCmd
     204  zcl_SendRead
     171  zcl_SendReadReportCfgCmd
     367  zcl_SendReadReportCfgRspCmd
     407  zcl_SendReadRsp
     201  zcl_SendReportCmd
     204  zcl_SendWriteRequest
     186  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
       9  zcl_getParsedTransSeqNum
      12  zcl_getRawAFMsg
      83  zcl_registerAttrList
      76  zcl_registerClusterOptionList
      24  zcl_registerForMsg
     105  zcl_registerPlugin
      62  zcl_registerReadWriteCB
      17  zcl_registerValidateAttrData

 
 12 457 bytes in segment BANKED_CODE
    354 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     14 bytes in segment XDATA_Z
 
 12 904 bytes of CODE  memory
     15 bytes of XDATA memory

Errors: none
Warnings: none
