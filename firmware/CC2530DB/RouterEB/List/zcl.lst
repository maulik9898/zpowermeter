###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.30.1.41636 for 8051             04/Nov/2015  16:51:12 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c                      #
#    Command line       =  -f C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\..\Tools\f8wRouter.cfg (-DCPU32MHZ  #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                   #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wConfig.cfg (-DZIGBEEPRO    #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100    #
#                          -DREJOIN_POLL_RATE=440) -f                         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Tools\f8wZCL.cfg                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\Components\stack\zcl\zcl.c -D SECURE=0 -D       #
#                          OSC32K_CRYSTAL_INSTALLED=FALSE -D HAL_KEY=FALSE    #
#                          -D HAL_BOARD_CC2530EB_REV17 -D TC_LINKKEY_JOIN -D  #
#                          NV_INIT -D xNV_RESTORE -D MULTICAST_ENABLED=FALSE  #
#                          -D ZCL_READ -D ZCL_WRITE -D ZCL_REPORT -D          #
#                          FEATURE_SYSTEM_STATS -lC                           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ -lA                     #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\ --diag_suppress         #
#                          Pe001,Pa010 -o C:\Users\paolo\Documents\GitHub\zpo #
#                          wermeter\firmware\CC2530DB\RouterEB\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fir #
#                          mware\CC2530DB\ -I C:\Users\paolo\Documents\GitHub #
#                          \zpowermeter\firmware\CC2530DB\..\Source\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\ha\ -I                       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Source\zmain\ -I                    #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\hal\target\CC2530EB\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\include\ -I          #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\high_level\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\ -I  #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\mac\low_level\srf04\sing #
#                          le_chip\ -I C:\Users\paolo\Documents\GitHub\zpower #
#                          meter\firmware\CC2530DB\..\Components\mt\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\osal\include\ -I         #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\saddr\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\services\sdata\ -I       #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\af\ -I             #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\nwk\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sapi\ -I           #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sec\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\sys\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zcl\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\stack\zdo\ -I            #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\ -I                 #
#                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\..\Components\zmac\f8w\ -Ohz           #
#                          --require_prototypes                               #
#    List file          =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\List\zcl.lst                  #
#    Object file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmwa #
#                          re\CC2530DB\RouterEB\Obj\zcl.r51                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\paolo\Documents\GitHub\zpowermeter\firmware\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2014-06-25 18:07:01 -0700 (Wed, 25 Jun 2014) $
      4            Revision:       $Revision: 39221 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "AF.h"
     45          
     46          #include "zcl.h"
     47          #include "zcl_general.h"
     48          #include "zclReadAttributeFn.h"
     49          #include "zclWriteAttributeFn.h"
     50          
     51          #if defined ( INTER_PAN )
     52            #include "stub_aps.h"
     53          #endif
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          /*** Frame Control ***/
     59          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     60          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     61          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     62          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     63          
     64          /*** Attribute Access Control ***/
     65          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     66          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     67          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     68          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     69          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     70          
     71          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     72          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     73          
     74          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     75                                                  (zclHdr).fc.manuSpecific == 0          && \
     76                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     77          
     78          // Commands that have corresponding responses
     79          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ                   || \
     80                                                  (cmd) == ZCL_CMD_WRITE                  || \
     81                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED        || \
     82                                                  (cmd) == ZCL_CMD_CONFIG_REPORT          || \
     83                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG        || \
     84                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS         || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_RECEIVED || \
     86                                                  (cmd) == ZCL_CMD_DISCOVER_CMDS_GEN      || \
     87                                                  (cmd) == ZCL_CMD_DISCOVER_ATTRS_EXT     || \
     88                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     89          
     90          /*********************************************************************
     91           * CONSTANTS
     92           */
     93          
     94          /*********************************************************************
     95           * TYPEDEFS
     96           */
     97          typedef struct zclLibPlugin
     98          {
     99            struct zclLibPlugin *next;
    100            uint16              startClusterID;    // starting cluster ID
    101            uint16              endClusterID;      // ending cluster ID
    102            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    103          } zclLibPlugin_t;
    104          
    105          // Command record list
    106          typedef struct zclCmdRecsList
    107          {
    108            struct zclCmdRecsList *pNext;
    109            uint8                 endpoint;
    110            uint8                 numCommands;
    111            CONST zclCommandRec_t *pCmdRecs;
    112          } zclCmdRecsList_t;
    113          
    114          // Attribute record list item
    115          typedef struct zclAttrRecsList
    116          {
    117            struct zclAttrRecsList *next;
    118            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    119            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    120            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    121            CONST zclAttrRec_t     *attrs;        // attribute records
    122          } zclAttrRecsList;
    123          
    124          // Cluster option list item
    125          typedef struct zclClusterOptionList
    126          {
    127            struct zclClusterOptionList *next;
    128            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    129            uint8                       numOptions; // Number of the following records
    130            zclOptionRec_t              *options;   // option records
    131          } zclClusterOptionList;
    132          
    133          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    134          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    135          
    136          typedef struct
    137          {
    138            zclParseInProfileCmd_t   pfnParseInProfile;
    139            zclProcessInProfileCmd_t pfnProcessInProfile;
    140          } zclCmdItems_t;
    141          
    142          
    143          /*********************************************************************
    144           * GLOBAL VARIABLES
    145           */
    146          
    147          #if !defined ( ZCL_STANDALONE )

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    148            uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    149          
    150            // The task Id of the Application where the unprocessed Foundation
    151            // Command/Response messages will be sent to.

   \                                 In  segment XDATA_I, align 1, keep-with-next
    152            uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
   \   000001                REQUIRE __INIT_XDATA_I
    153          #endif
    154          
    155          // The Application should register its attribute data validation function

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    156          zclValidateAttrData_t zcl_ValidateAttrDataCB = (zclValidateAttrData_t)NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    157          
    158          // ZCL Sequence number

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    159          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    160          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    161          uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    162          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    163          static uint8 savedZCLTransSeqNum = 0;
   \                     savedZCLTransSeqNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    164          
    165          /*********************************************************************
    166           * EXTERNAL VARIABLES
    167           */
    168          
    169          /*********************************************************************
    170           * EXTERNAL FUNCTIONS
    171           */
    172          
    173          /*********************************************************************
    174           * LOCAL VARIABLES
    175           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    176          static zclLibPlugin_t *plugins = (zclLibPlugin_t *)NULL;
   \                     plugins:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    177          
    178          #if defined ( ZCL_DISCOVER )
    179            static zclCmdRecsList_t *gpCmdList = (zclCmdRecsList_t *)NULL;
    180          #endif
    181          
    182          static zclAttrRecsList *attrList = (zclAttrRecsList *)NULL;
                                         ^
Warning[Pe177]: variable "attrList" was declared but never referenced

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          static zclClusterOptionList *clusterOptionList = (zclClusterOptionList *)NULL;
   \                     clusterOptionList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    184          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    185          static afIncomingMSGPacket_t *rawAFMsg = (afIncomingMSGPacket_t *)NULL;
   \                     rawAFMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    186          
    187          /*********************************************************************
    188           * LOCAL FUNCTIONS
    189           */
    190          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    191          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    192          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    193          
    194          #if defined ( ZCL_DISCOVER )
    195            static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint );
    196          #endif
    197          
    198          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    199          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    200          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    201          
    202          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    203          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen );
    204          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    205          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    206          
    207          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    208          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    209          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    210          
    211          
    212          #ifdef ZCL_REPORT
    213          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    214          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    215          #endif // ZCL_REPORT
    216          
    217          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    218          
    219          #ifdef ZCL_DISCOVER
    220          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID, uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd );
    221          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction, uint16 *attrId, zclAttrRec_t *pAttr );
    222          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd );
    223          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd );
    224          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd );
    225          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    226          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg );
    227          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    228          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 attrLenBuf );
    229          #endif // ZCL_DISCOVER
    230          
    231          /*********************************************************************
    232           * Parse Profile Command Function Table
    233           */
    234          

   \                                 In  segment CODE_C, align 1
    235          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ....         DW ??zclParseInReadCmd?relay
   \   000002   ....         DW ??zclProcessInReadCmd?relay
   \   000004   ....         DW ??zclParseInReadRspCmd?relay
   \   000006   ....         DW ??zcl_HandleExternal?relay
   \   000008   ....         DW ??zclParseInWriteCmd?relay
   \   00000A   ....         DW ??zclProcessInWriteCmd?relay
   \   00000C   ....         DW ??zclParseInWriteCmd?relay
   \   00000E   ....         DW ??zclProcessInWriteUndividedCmd?relay
   \   000010   ....         DW ??zclParseInWriteRspCmd?relay
   \   000012   ....         DW ??zcl_HandleExternal?relay
   \   000014   ....         DW ??zclParseInWriteCmd?relay
   \   000016   ....         DW ??zclProcessInWriteCmd?relay
   \   000018   ....         DW ??zclParseInConfigReportCmd?relay
   \   00001A   ....         DW ??zcl_HandleExternal?relay
   \   00001C   ....         DW ??zclParseInConfigReportRspCmd?relay
   \   00001E   ....         DW ??zcl_HandleExternal?relay
   \   000020   ....         DW ??zclParseInReadReportCfgCmd?relay
   \   000022   ....         DW ??zcl_HandleExternal?relay
   \   000024   ....         DW ??zclParseInReadReportCfgRspCmd?relay
   \   000026   ....         DW ??zcl_HandleExternal?relay
   \   000028   ....         DW ??zclParseInReportCmd?relay
   \   00002A   ....         DW ??zcl_HandleExternal?relay
   \   00002C   ....         DW ??zclParseInDefaultRspCmd?relay
   \   00002E   ....         DW ??zcl_HandleExternal?relay
   \   000030   0000         DW 0H
   \   000032   0000         DW 0H
   \   000034   0000         DW 0H
   \   000036   0000         DW 0H
   \   000038   0000         DW 0H
   \   00003A   0000         DW 0H
   \   00003C   0000         DW 0H
   \   00003E   0000         DW 0H
   \   000040   0000         DW 0H
   \   000042   0000         DW 0H
   \   000044   0000         DW 0H
   \   000046   0000         DW 0H
   \   000048   0000         DW 0H
   \   00004A   0000         DW 0H
   \   00004C   0000         DW 0H
   \   00004E   0000         DW 0H
   \   000050   0000         DW 0H
   \   000052   0000         DW 0H
   \   000054   0000         DW 0H
   \   000056   0000         DW 0H
   \   000058   0000         DW 0H
   \   00005A   0000         DW 0H
    236          {
    237          #ifdef ZCL_READ
    238            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    239            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zcl_HandleExternal              },
    240          #else
    241            /* ZCL_CMD_READ */                { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    242            /* ZCL_CMD_READ_RSP */            { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    243          #endif // ZCL_READ
    244          
    245          #ifdef ZCL_WRITE
    246            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    247            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    248            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zcl_HandleExternal              },
    249            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    250          #else
    251            /* ZCL_CMD_WRITE */               { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    252            /* ZCL_CMD_WRITE_UNDIVIDED */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    253            /* ZCL_CMD_WRITE_RSP */           { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    254            /* ZCL_CMD_WRITE_NO_RSP */        { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    255          #endif // ZCL_WRITE
    256          
    257          #ifdef ZCL_REPORT
    258            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zcl_HandleExternal              },
    259            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zcl_HandleExternal              },
    260            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zcl_HandleExternal              },
    261            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zcl_HandleExternal              },
    262            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zcl_HandleExternal              },
    263          #else
    264            /* ZCL_CMD_CONFIG_REPORT */       { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    265            /* ZCL_CMD_CONFIG_REPORT_RSP */   { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    266            /* ZCL_CMD_READ_REPORT_CFG */     { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    267            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    268            /* ZCL_CMD_REPORT */              { (zclParseInProfileCmd_t)NULL,  (zclProcessInProfileCmd_t)NULL  },
    269          #endif // ZCL_REPORT
    270          
    271            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zcl_HandleExternal              },
    272          
    273          #ifdef ZCL_DISCOVER
    274            /* ZCL_CMD_DISCOVER_ATTRS */                { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    275            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { zclParseInDiscAttrsRspCmd,      zcl_HandleExternal              },
    276            /* *not supported* READ_ATTRS_STRCT */      { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    277            /* *not supported* WRITE_ATTRS_STRCT */     { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    278            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { NULL,                           (zclProcessInProfileCmd_t)NULL  },
    279            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    280            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    281            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { zclParseInDiscCmdsCmd,          zclProcessInDiscCmd             },
    282            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { zclParseInDiscCmdsRspCmd,       zcl_HandleExternal              },
    283            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { zclParseInDiscAttrsCmd,         zclProcessInDiscAttrs           },
    284            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { zclParseInDiscAttrsExtRspCmd,   zcl_HandleExternal              },
    285          #else
    286            /* ZCL_CMD_DISCOVER_ATTRS */                { (zclParseInProfileCmd_t)NULL,    (zclProcessInProfileCmd_t)NULL  },
    287            /* ZCL_CMD_DISCOVER_ATTRS_RSP */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    288            /* *not supported* READ_ATTRS_STRCT */      { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    289            /* *not supported* WRITE_ATTRS_STRCT */     { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    290            /* *not supported* WRITE_ATTRS_STRCT_RSP */ { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    291            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    292            /* ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP */    { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    293            /* ZCL_CMD_DISCOVER_CMDS_GEN */             { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    294            /* ZCL_CMD_DISCOVER_CMDS_GEN_RSP */         { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    295            /* ZCL_CMD_DISCOVER_ATTRS_EXT */            { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    296            /* ZCL_CMD_DISCOVER_ATTRS_EXT_RSP */        { (zclParseInProfileCmd_t)NULL,   (zclProcessInProfileCmd_t)NULL  },
    297          #endif // ZCL_DISCOVER
    298          };
    299          
    300          /*********************************************************************
    301           * PUBLIC FUNCTIONS
    302           *********************************************************************/
    303          
    304          #if !defined ( ZCL_STANDALONE )
    305          /*********************************************************************
    306           * @fn          zcl_Init
    307           *
    308           * @brief       Initialization function for the zcl layer.
    309           *
    310           * @param       task_id - ZCL task id
    311           *
    312           * @return      none
    313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    314          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    315          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    316            zcl_TaskID = task_id;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#zcl_TaskID
   \   000008   F0           MOVX    @DPTR,A
    317          }
   \   000009   02....       LJMP    ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    318          #endif
    319          
    320          #if !defined ( ZCL_STANDALONE )
    321          /*********************************************************************
    322           * @fn          zcl_event_loop
    323           *
    324           * @brief       Event Loop Processor for zcl.
    325           *
    326           * @param       task_id - task id
    327           * @param       events - event bitmap
    328           *
    329           * @return      unprocessed events
    330           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    331          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    332          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
    333            uint8 *msgPtr;
    334          
    335            (void)task_id;  // Intentionally unreferenced parameter
    336          
    337            if ( events & SYS_EVENT_MSG )
   \   000009   EB           MOV     A,R3
   \   00000A   5480         ANL     A,#0x80
   \   00000C   6048         JZ      ??zcl_event_loop_0
    338            {
    339              msgPtr = osal_msg_receive( zcl_TaskID );
   \   00000E                ; Setup parameters for call to function osal_msg_receive
   \   00000E   800E         SJMP    ??zcl_event_loop_1
    340              while ( msgPtr != NULL )
    341              {
    342                uint8 dealloc = TRUE;
    343          
    344                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    345                {
    346                  zcl_ProcessMessageMSG( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??zcl_event_loop_2:
   \   000010                ; Setup parameters for call to function zcl_ProcessMessageMSG
   \   000010   EE           MOV     A,R6
   \   000011   FA           MOV     R2,A
   \   000012   EF           MOV     A,R7
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??zcl_ProcessMessageMSG?relay; Banked call to: zcl_ProcessMessageMSG
    347                }
    348                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    349                {
    350                  // send it to another task to process.
    351                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    352                  dealloc = FALSE;
    353                }
    354          
    355                // Release the memory
    356                if ( dealloc )
    357                {
    358                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_3:
   \   000017                ; Setup parameters for call to function osal_msg_deallocate
   \   000017   EE           MOV     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   EF           MOV     A,R7
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??osal_msg_deallocate?relay; Banked call to: osal_msg_deallocate
    359                }
    360          
    361                // Next
    362                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_1:
   \   00001E                ; Setup parameters for call to function osal_msg_receive
   \   00001E   90....       MOV     DPTR,#zcl_TaskID
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   ??osal_msg_receive?relay; Banked call to: osal_msg_receive
   \   000026   8A..         MOV     ?V2,R2
   \   000028   8B..         MOV     ?V3,R3
   \   00002A   AE..         MOV     R6,?V2
   \   00002C   AF..         MOV     R7,?V3
   \   00002E   EE           MOV     A,R6
   \   00002F   4F           ORL     A,R7
   \   000030   601B         JZ      ??zcl_event_loop_4
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   641A         XRL     A,#0x1a
   \   000039   60D5         JZ      ??zcl_event_loop_2
   \   00003B   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F4           CPL     A
   \   000040   60D5         JZ      ??zcl_event_loop_3
   \   000042                ; Setup parameters for call to function osal_msg_send
   \   000042   EE           MOV     A,R6
   \   000043   FA           MOV     R2,A
   \   000044   EF           MOV     A,R7
   \   000045   FB           MOV     R3,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F9           MOV     R1,A
   \   000048   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
   \   00004B   80D1         SJMP    ??zcl_event_loop_1
    363              }
    364          
    365              // return unprocessed events
    366              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   00004D   AA..         MOV     R2,?V0
   \   00004F   E5..         MOV     A,?V1
   \   000051   6480         XRL     A,#0x80
   \   000053   FB           MOV     R3,A
   \   000054   8004         SJMP    ??zcl_event_loop_5
    367            }
    368          
    369            // Discard unknown events
    370            return 0;
   \                     ??zcl_event_loop_0:
   \   000056   7A00         MOV     R2,#0x0
   \   000058   7B00         MOV     R3,#0x0
   \                     ??zcl_event_loop_5:
   \   00005A   02....       LJMP    ?Subroutine1 & 0xFFFF
    371          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    372          #endif
    373          
    374          #if !defined ( ZCL_STANDALONE )
    375          /*********************************************************************
    376           * @fn      zcl_registerForMsg
    377           *
    378           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    379           *          messages that aren't processed to one task (if a task is
    380           *          registered).
    381           *
    382           * @param   taskId - task Id of the Application where commands will be sent to
    383           *
    384           * @return  TRUE if task registeration successful, FALSE otherwise
    385           *********************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    386          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    387          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
    388            // Allow only the first task
    389            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000006   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F4           CPL     A
   \   00000B   7006         JNZ     ??zcl_registerForMsg_0
    390            {
    391              zcl_RegisteredMsgTaskID = taskId;
   \   00000D   E8           MOV     A,R0
   \   00000E   F0           MOVX    @DPTR,A
    392          
    393              return ( true );
   \   00000F   7901         MOV     R1,#0x1
   \   000011   8002         SJMP    ??zcl_registerForMsg_1
    394            }
    395          
    396            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   000013   7900         MOV     R1,#0x0
   \                     ??zcl_registerForMsg_1:
   \   000015   02....       LJMP    ?Subroutine0 & 0xFFFF
    397          }
    398          #endif
    399          
    400          #if !defined ( ZCL_STANDALONE )
    401          /*********************************************************************
    402           * @fn      zcl_HandleExternal
    403           *
    404           * @brief
    405           *
    406           * @param   pInMsg - incoming message to process
    407           *
    408           * @return  TRUE
    409           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    410          uint8 zcl_HandleExternal( zclIncoming_t *pInMsg )
   \                     zcl_HandleExternal:
    411          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    412            zclIncomingMsg_t *pCmd;
    413          
    414            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000009   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F4           CPL     A
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??zcl_HandleExternal_0 & 0xFFFF
    415            {
    416              return ( TRUE );
    417            }
    418          
    419            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   000013                ; Setup parameters for call to function osal_msg_allocate
   \   000013   7A19         MOV     R2,#0x19
   \   000015   7B00         MOV     R3,#0x0
   \   000017   12....       LCALL   ??osal_msg_allocate?relay; Banked call to: osal_msg_allocate
    420            if ( pCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   607E         JZ      ??zcl_HandleExternal_0
    421            {
    422              // fill in the message
    423              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   00001E   8A82         MOV     DPL,R2
   \   000020   8B83         MOV     DPH,R3
   \   000022   7434         MOV     A,#0x34
   \   000024   12....       LCALL   ??Subroutine175_0 & 0xFFFF
    424              pCmd->zclHdr    = pInMsg->hdr;
   \                     ??CrossCallReturnLabel_323:
   \   000027   A3           INC     DPTR
   \   000028   EA           MOV     A,R2
   \   000029   2402         ADD     A,#0x2
   \   00002B   FC           MOV     R4,A
   \   00002C   E4           CLR     A
   \   00002D   3B           ADDC    A,R3
   \   00002E   FD           MOV     R5,A
   \   00002F   7406         MOV     A,#0x6
   \   000031   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    425              pCmd->clusterId = pInMsg->msg->clusterId;
   \   000034   8E82         MOV     DPL,R6
   \   000036   8F83         MOV     DPH,R7
   \   000038   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   00003B   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   12....       LCALL   ?Subroutine41 & 0xFFFF
    426              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \                     ??CrossCallReturnLabel_473:
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   EA           MOV     A,R2
   \   000054   240A         ADD     A,#0xa
   \   000056   FC           MOV     R4,A
   \   000057   E4           CLR     A
   \   000058   3B           ADDC    A,R3
   \   000059   FD           MOV     R5,A
   \   00005A   740C         MOV     A,#0xc
   \   00005C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    427              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000068   C0E0         PUSH    A
   \   00006A   EA           MOV     A,R2
   \   00006B   2416         ADD     A,#0x16
   \   00006D   F582         MOV     DPL,A
   \   00006F   E4           CLR     A
   \   000070   3B           ADDC    A,R3
   \   000071   F583         MOV     DPH,A
   \   000073   D0E0         POP     A
   \   000075   F0           MOVX    @DPTR,A
    428              pCmd->attrCmd   = pInMsg->attrCmd;
   \   000076   EE           MOV     A,R6
   \   000077   240C         ADD     A,#0xc
   \   000079   F8           MOV     R0,A
   \   00007A   E4           CLR     A
   \   00007B   3F           ADDC    A,R7
   \   00007C   F9           MOV     R1,A
   \   00007D   8882         MOV     DPL,R0
   \   00007F   8983         MOV     DPH,R1
   \   000081   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000084   EA           MOV     A,R2
   \   000085   2417         ADD     A,#0x17
   \   000087   F582         MOV     DPL,A
   \   000089   E4           CLR     A
   \   00008A   3B           ADDC    A,R3
   \   00008B   F583         MOV     DPH,A
   \   00008D   12....       LCALL   ?Subroutine41 & 0xFFFF
    429          
    430              // Application will free the attrCmd buffer
    431              pInMsg->attrCmd = NULL;
   \                     ??CrossCallReturnLabel_474:
   \   000090   E4           CLR     A
   \   000091   F0           MOVX    @DPTR,A
   \   000092   A3           INC     DPTR
   \   000093   F0           MOVX    @DPTR,A
    432          
    433              /* send message through task message */
    434              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000094                ; Setup parameters for call to function osal_msg_send
   \   000094   90....       MOV     DPTR,#zcl_RegisteredMsgTaskID
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F9           MOV     R1,A
   \   000099   12....       LCALL   ??osal_msg_send?relay; Banked call to: osal_msg_send
    435            }
    436          
    437            return ( TRUE );
   \                     ??zcl_HandleExternal_0:
   \   00009C   7901         MOV     R1,#0x1
   \   00009E   02....       LJMP    ?Subroutine2 & 0xFFFF
    438          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine137:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_394:
   \   000003   F9           MOV     R1,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine169_0
   \   000004                ; // Fall through to label ??Subroutine169_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine169_0:
   \   000000   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_350:
   \   000003   FD           MOV     R5,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine132:
   \   000000   A3           INC     DPTR
   \   000001   E0           MOVX    A,@DPTR
   \   000002   C8           XCH     A,R0
   \   000003   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_238:
   \   000006   38           ADDC    A,R0
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine175_0:
   \   000000   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine122:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine179_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine152:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine153:
   \   000000   2414         ADD     A,#0x14
   \   000002   F582         MOV     DPL,A
   \   000004   E4           CLR     A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   EC           MOV     A,R4
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   ED           MOV     A,R5
   \   000004                REQUIRE ??Subroutine202_0
   \   000004                ; // Fall through to label ??Subroutine202_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine202_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetAttrDataLength
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET
    439          #endif
    440          
    441          
    442          /*********************************************************************
    443           * @fn          zcl_getRawAFMsg
    444           *
    445           * @brief       Call to get original unprocessed AF message
    446           *              (not parsed by ZCL).
    447           *
    448           *   NOTE:  This function can only be called during a ZCL callback function
    449           *          and the calling function must NOT change any data in the message.
    450           *
    451           * @param       none
    452           *
    453           * @return      pointer to original AF message, NULL if not processing
    454           *              AF message.
    455           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    456          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    457          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    458            return ( rawAFMsg );
   \   000004   90....       MOV     DPTR,#rawAFMsg
   \   000007   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_446:
   \   00000A   80..         SJMP    ?Subroutine0
    459          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine198_0:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_463:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine140:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    460          
    461          /*********************************************************************
    462           * @fn          zcl_getParsedTransSeqNum
    463           *
    464           * @brief       Call to the get the transaction sequence number from 
    465           *              the incoming message.
    466           *
    467           *   NOTE:  This function can only be called during a ZCL callback function
    468           *          and the calling function must NOT change any data in the message.
    469           *
    470           * @param       none
    471           *
    472           * @return      transaction sequence number.
    473           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    474          uint8 zcl_getParsedTransSeqNum( void )
   \                     zcl_getParsedTransSeqNum:
    475          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    476            return ( savedZCLTransSeqNum );
   \   000004   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009                REQUIRE ?Subroutine0
   \   000009                ; // Fall through to label ?Subroutine0
    477          }
    478          
    479          /*********************************************************************
    480           * @fn          zcl_registerPlugin
    481           *
    482           * @brief       Add a Cluster Library handler
    483           *
    484           * @param       startClusterID - starting cluster ID
    485           * @param       endClusterID - ending cluster ID
    486           * @param       pfnHdlr - function pointer to incoming message handler
    487           *
    488           * @return      ZSuccess if OK
    489           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          ZStatus_t zcl_registerPlugin( uint16 startClusterID, uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr ){
   \                     zcl_registerPlugin:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    491            zclLibPlugin_t *pNewItem;
    492            zclLibPlugin_t *pLoop;
    493          
    494            // Fill in the new profile list
    495            pNewItem = zcl_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A08         MOV     R2,#0x8
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    496            if ( pNewItem == NULL ){
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerPlugin_0
    497              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   8037         SJMP    ??zcl_registerPlugin_1
    498            }
    499          
    500            // Fill in the plugin record.
    501            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_0:
   \   000024   12....       LCALL   ?Subroutine28 & 0xFFFF
    502            pNewItem->startClusterID = startClusterID;
   \                     ??CrossCallReturnLabel_27:
   \   000027   12....       LCALL   ?Subroutine25 & 0xFFFF
    503            pNewItem->endClusterID = endClusterID;
    504            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \                     ??CrossCallReturnLabel_22:
   \   00002A   740C         MOV     A,#0xc
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   EA           MOV     A,R2
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EB           MOV     A,R3
   \   000039   F0           MOVX    @DPTR,A
    505          
    506            // Find spot in list
    507            if (  plugins == NULL )
   \   00003A   90....       MOV     DPTR,#plugins
   \   00003D   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_245:
   \   000040   90....       MOV     DPTR,#plugins
   \   000043   6011         JZ      ??zcl_registerPlugin_2
    508            {
    509              plugins = pNewItem;
    510            }
    511            else
    512            {
    513              // Look for end of list
    514              pLoop = plugins;
   \   000045   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_344:
   \   000048   8003         SJMP    ??zcl_registerPlugin_3
    515              while ( pLoop->next != NULL )
    516              {
    517                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_4:
   \   00004A   EA           MOV     A,R2
   \   00004B   FC           MOV     R4,A
   \   00004C   EB           MOV     A,R3
    518              }
   \                     ??zcl_registerPlugin_3:
   \   00004D   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_243:
   \   000050   70F8         JNZ     ??zcl_registerPlugin_4
    519          
    520              // Put new item at end of list
    521              pLoop->next = pNewItem;
   \   000052   8C82         MOV     DPL,R4
   \   000054   8D83         MOV     DPH,R5
    522            }
   \                     ??zcl_registerPlugin_2:
   \   000056   12....       LCALL   ??Subroutine174_0 & 0xFFFF
    523          
    524            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_306:
   \   000059   7900         MOV     R1,#0x0
   \                     ??zcl_registerPlugin_1:
   \   00005B   02....       LJMP    ?Subroutine1 & 0xFFFF
    525          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   FD           MOV     R5,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005                REQUIRE ??Subroutine155_0
   \   000005                ; // Fall through to label ??Subroutine155_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine155_0:
   \   000000   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_462:
   \   000003   EA           MOV     A,R2
   \   000004   4B           ORL     A,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E4           CLR     A
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   8983         MOV     DPH,R1
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   E5..         MOV     A,?V0
   \   000010   F0           MOVX    @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   A3           INC     DPTR
   \   000001   E5..         MOV     A,?V1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   EE           MOV     A,R6
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   EF           MOV     A,R7
   \   000010   F0           MOVX    @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine129:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine158_0
   \   000001                ; // Fall through to label ??Subroutine158_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine158_0:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   FB           MOV     R3,A
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine174_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    526          
    527          #ifdef ZCL_DISCOVER
    528          /*********************************************************************
    529           * @fn          zcl_registerCmdList
    530           *
    531           * @brief       Register a Command List with ZCL Foundation
    532           *
    533           * @param       endpoint - endpoint the attribute list belongs to
    534           * @param       newCmdList - array of command records
    535           *
    536           * @return      ZSuccess if OK
    537           */
    538          ZStatus_t zcl_registerCmdList( uint8 endpoint, CONST uint8 cmdListSize, CONST zclCommandRec_t newCmdList[] )
    539          {
    540            zclCmdRecsList_t *pNewItem;
    541            zclCmdRecsList_t *pLoop;
    542          
    543            // Fill in the new profile list
    544            pNewItem = zcl_mem_alloc( sizeof( zclCmdRecsList_t ) );
    545            if ( pNewItem == NULL )
    546            {
    547              return (ZMemError);
    548            }
    549          
    550            pNewItem->pNext = (zclCmdRecsList_t *)NULL;
    551            pNewItem->endpoint = endpoint;
    552            pNewItem->numCommands = cmdListSize;
    553            pNewItem->pCmdRecs = newCmdList;
    554          
    555            // Find spot in list
    556            if ( gpCmdList == NULL )
    557            {
    558              gpCmdList = pNewItem;
    559            }
    560            else
    561            {
    562              // Look for end of list
    563              pLoop = gpCmdList;
    564              while ( pLoop->pNext != NULL )
    565              {
    566                pLoop = pLoop->pNext;
    567              }
    568          
    569              // Put new item at end of list
    570              pLoop->pNext = pNewItem;
    571            }
    572          
    573            return ( ZSuccess );
    574          }
    575          #endif  // ZCL_DISCOVER
    576          
    577          
    578          
    579          /*********************************************************************
    580           * @fn          zcl_registerClusterOptionList
    581           *
    582           * @brief       Register a Cluster Option List with ZCL Foundation
    583           *
    584           * @param       endpoint - endpoint the option list belongs to
    585           * @param       numOption - number of options in list
    586           * @param       optionList - array of cluster option records.
    587           *
    588           *              NOTE: This API should be called to enable 'Application
    589           *                    Link Key' security and/or 'APS ACK' for a specific
    590           *                    Cluster. The 'Application Link Key' is discarded
    591           *                    if security isn't enabled on the device.
    592           *                    The default behavior is 'Network Key' when security
    593           *                    is enabled and no 'APS ACK' for the ZCL messages.
    594           *
    595           * @return      ZSuccess if OK
    596           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    597          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    598          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
   \   000007   8A..         MOV     ?V1,R2
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    599            zclClusterOptionList *pNewItem;
    600            zclClusterOptionList *pLoop;
    601          
    602            // Fill in the new profile list
    603            pNewItem = zcl_mem_alloc( sizeof( zclClusterOptionList ) );
   \   00000D                ; Setup parameters for call to function osal_mem_alloc
   \   00000D   7A06         MOV     R2,#0x6
   \   00000F   7B00         MOV     R3,#0x0
   \   000011   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000014   8A..         MOV     ?V2,R2
   \   000016   8B..         MOV     ?V3,R3
   \   000018   A8..         MOV     R0,?V2
   \   00001A   A9..         MOV     R1,?V3
    604            if ( pNewItem == NULL )
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7004         JNZ     ??zcl_registerClusterOptionList_0
    605            {
    606              return (ZMemError);
   \   000020   7910         MOV     R1,#0x10
   \   000022   802D         SJMP    ??zcl_registerClusterOptionList_1
    607            }
    608          
    609            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_0:
   \   000024   12....       LCALL   ?Subroutine28 & 0xFFFF
    610            pNewItem->endpoint = endpoint;
    611            pNewItem->numOptions = numOption;
   \                     ??CrossCallReturnLabel_28:
   \   000027   8882         MOV     DPL,R0
   \   000029   8983         MOV     DPH,R1
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   12....       LCALL   ?Subroutine25 & 0xFFFF
    612            pNewItem->options = optionList;
    613          
    614            // Find spot in list
    615            if ( clusterOptionList == NULL )
   \                     ??CrossCallReturnLabel_23:
   \   000030   90....       MOV     DPTR,#clusterOptionList
   \   000033   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000036   90....       MOV     DPTR,#clusterOptionList
   \   000039   6011         JZ      ??zcl_registerClusterOptionList_2
    616            {
    617              clusterOptionList = pNewItem;
    618            }
    619            else
    620            {
    621              // Look for end of list
    622              pLoop = clusterOptionList;
   \   00003B   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_345:
   \   00003E   8003         SJMP    ??zcl_registerClusterOptionList_3
    623              while ( pLoop->next != NULL )
    624              {
    625                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_4:
   \   000040   EA           MOV     A,R2
   \   000041   FC           MOV     R4,A
   \   000042   EB           MOV     A,R3
    626              }
   \                     ??zcl_registerClusterOptionList_3:
   \   000043   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_244:
   \   000046   70F8         JNZ     ??zcl_registerClusterOptionList_4
    627          
    628              // Put new item at end of list
    629              pLoop->next = pNewItem;
   \   000048   8C82         MOV     DPL,R4
   \   00004A   8D83         MOV     DPH,R5
    630            }
   \                     ??zcl_registerClusterOptionList_2:
   \   00004C   12....       LCALL   ??Subroutine174_0 & 0xFFFF
    631          
    632            return ( ZSuccess );
   \                     ??CrossCallReturnLabel_307:
   \   00004F   7900         MOV     R1,#0x0
   \                     ??zcl_registerClusterOptionList_1:
   \   000051   02....       LJMP    ?Subroutine1 & 0xFFFF
    633          }
    634          
    635          /*********************************************************************
    636           * @fn          zcl_registerValidateAttrData
    637           *
    638           * @brief       Add a validation function for attribute data
    639           *
    640           * @param       pfnValidateAttrData - function pointer to validate routine
    641           *
    642           * @return      ZSuccess if OK
    643           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    644          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    645          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    646            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000004   90....       MOV     DPTR,#zcl_ValidateAttrDataCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    647          
    648            return ( ZSuccess );
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   02....       LJMP    ?Subroutine0 & 0xFFFF
    649          }
    650          
    651          /*********************************************************************
    652           * @fn      zcl_DeviceOperational
    653           *
    654           * @brief   Used to see whether or not the device can send or respond
    655           *          to application level commands.
    656           *
    657           * @param   srcEP - source endpoint
    658           * @param   clusterID - cluster ID
    659           * @param   frameType - command type
    660           * @param   cmd - command ID
    661           *
    662           * @return  TRUE if device is operational, FALSE otherwise
    663           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    664          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID ){
   \                     zcl_DeviceOperational:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    665          	zclAttrRec_t attrRec;
    666          	uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7401         MOV     A,#0x1
   \   000012   F0           MOVX    @DPTR,A
    667          
    668          	(void)profileID;  // Intentionally unreferenced parameter
    669          
    670            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    671            // cannot send or respond to application level commands, other than commands
    672            // to read or write attributes. Note that the Identify cluster cannot be
    673            // disabled, and remains functional regardless of this setting.
    674          	if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )  {
   \   000013   EC           MOV     A,R4
   \   000014   7006         JNZ     ??zcl_DeviceOperational_0
   \   000016   ED           MOV     A,R5
   \   000017   C3           CLR     C
   \   000018   9406         SUBB    A,#0x6
   \   00001A   4048         JC      ??zcl_DeviceOperational_1
    675          		return ( TRUE );
    676          	}
    677          
    678          	if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY ){
   \                     ??zcl_DeviceOperational_0:
   \   00001C   7403         MOV     A,#0x3
   \   00001E   6A           XRL     A,R2
   \   00001F   4B           ORL     A,R3
   \   000020   6042         JZ      ??zcl_DeviceOperational_1
    679          		return ( TRUE );
    680          	}
    681          
    682            // Is device enabled?
    683          	ReadAttributeFn callback = findReadAttributeFn(srcEP, ZCL_CLUSTER_ID_GEN_BASIC);
    684          	callback(&attrRec);
   \   000022                ; Setup parameters for indirect call
   \   000022   7401         MOV     A,#0x1
   \   000024   12....       LCALL   ?XSTACK_DISP101_8
   \   000027   EA           MOV     A,R2
   \   000028   FE           MOV     R6,A
   \   000029   EB           MOV     A,R3
   \   00002A   FF           MOV     R7,A
   \   00002B                ; Setup parameters for call to function findReadAttributeFn
   \   00002B   7A00         MOV     R2,#0x0
   \   00002D   7B00         MOV     R3,#0x0
   \   00002F   12....       LCALL   ??findReadAttributeFn?relay; Banked call to: findReadAttributeFn
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ?CALL_IND
    685          	zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   00003D                ; Setup parameters for call to function zclReadAttrData
   \   00003D   E4           CLR     A
   \   00003E   F5..         MOV     ?V4,A
   \   000040   F5..         MOV     ?V5,A
   \   000042   78..         MOV     R0,#?V4
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000047   7403         MOV     A,#0x3
   \   000049   12....       LCALL   ?XSTACK_DISP102_8
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP101_8
   \   000051   12....       LCALL   ??zclReadAttrData?relay; Banked call to: zclReadAttrData
   \   000054   7402         MOV     A,#0x2
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
    686          	return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \   000059   85..82       MOV     DPL,?XSP + 0
   \   00005C   85..83       MOV     DPH,?XSP + 1
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   6401         XRL     A,#0x1
   \   000062   7004         JNZ     ??zcl_DeviceOperational_2
   \                     ??zcl_DeviceOperational_1:
   \   000064   7901         MOV     R1,#0x1
   \   000066   8002         SJMP    ??zcl_DeviceOperational_3
   \                     ??zcl_DeviceOperational_2:
   \   000068   7900         MOV     R1,#0x0
   \                     ??zcl_DeviceOperational_3:
   \   00006A   740C         MOV     A,#0xc
   \   00006C                REQUIRE ?Subroutine3
   \   00006C                ; // Fall through to label ?Subroutine3
    687          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine156_0
   \   000003                ; // Fall through to label ??Subroutine156_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine156_0:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    688          
    689          /*********************************************************************
    690           * @fn      zcl_SendCommand
    691           *
    692           * @brief   Used to send Profile and Cluster Specific Command messages.
    693           *
    694           *          NOTE: The calling application is responsible for incrementing
    695           *                the Sequence Number.
    696           *
    697           * @param   srcEp - source endpoint
    698           * @param   destAddr - destination address
    699           * @param   clusterID - cluster ID
    700           * @param   cmd - command ID
    701           * @param   specific - whether the command is Cluster Specific
    702           * @param   direction - client/server direction of the command
    703           * @param   disableDefaultRsp - disable Default Response command
    704           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    705           * @param   seqNumber - identification number for the transaction
    706           * @param   cmdFormatLen - length of the command to be sent
    707           * @param   cmdFormat - command to be sent
    708           *
    709           * @return  ZSuccess if OK
    710           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    711          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    712                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    713                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    714                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    715          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V10,R1
   \   00000C   8A..         MOV     ?V14,R2
   \   00000E   8B..         MOV     ?V15,R3
   \   000010   8C..         MOV     ?V2,R4
   \   000012   8D..         MOV     ?V3,R5
    716            endPointDesc_t *epDesc;
    717            zclFrameHdr_t hdr;
    718            uint8 *msgBuf;
    719            uint16 msgLen;
    720            uint8 *pBuf;
    721            uint8 options;
    722            ZStatus_t status;
    723          
    724            epDesc = afFindEndPointDesc( srcEP );
   \   000014                ; Setup parameters for call to function afFindEndPointDesc
   \   000014   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   000017   8A..         MOV     ?V12,R2
   \   000019   8B..         MOV     ?V13,R3
    725            if ( epDesc == NULL )
   \   00001B   EA           MOV     A,R2
   \   00001C   45..         ORL     A,?V13
   \   00001E   7005         JNZ     ??zcl_SendCommand_0
    726            {
    727              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   7902         MOV     R1,#0x2
   \   000022   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    728            }
    729          
    730          #if defined ( INTER_PAN )
    731            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    732            {
    733              options = AF_TX_OPTIONS_NONE;
    734            }
    735            else
    736          #endif
    737            {
    738              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_0:
   \   000025                ; Setup parameters for call to function zclGetClusterOption
   \   000025   AA..         MOV     R2,?V2
   \   000027   AB..         MOV     R3,?V3
   \   000029   A9..         MOV     R1,?V10
   \   00002B   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   00002E   E9           MOV     A,R1
   \   00002F   F5..         MOV     ?V7,A
    739          
    740              // The cluster might not have been defined to use security but if this message
    741              // is in response to another message that was using APS security this message
    742              // will be sent with APS security
    743              if ( !( options & AF_EN_SECURITY ) )
   \   000031   A2E6         MOV     C,0xE0 /* A   */.6
   \   000033   401C         JC      ??zcl_SendCommand_2
    744              {
    745                afIncomingMSGPacket_t *origPkt = zcl_getRawAFMsg();
   \   000035   90....       MOV     DPTR,#rawAFMsg
   \   000038   12....       LCALL   ??Subroutine178_0 & 0xFFFF
    746          
    747                if ( ( origPkt != NULL ) && ( origPkt->SecurityUse == TRUE ) )
   \                     ??CrossCallReturnLabel_334:
   \   00003B   6014         JZ      ??zcl_SendCommand_2
   \   00003D   E8           MOV     A,R0
   \   00003E   2419         ADD     A,#0x19
   \   000040   F582         MOV     DPL,A
   \   000042   E4           CLR     A
   \   000043   39           ADDC    A,R1
   \   000044   F583         MOV     DPH,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   6401         XRL     A,#0x1
   \   000049   7006         JNZ     ??zcl_SendCommand_2
    748                {
    749                  options |= AF_EN_SECURITY;
   \   00004B   E5..         MOV     A,?V7
   \   00004D   D2E6         SETB    0xE0 /* A   */.6
   \   00004F   F5..         MOV     ?V7,A
    750                }
    751              }
    752            }
    753          
    754            zcl_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_2:
   \   000051                ; Setup parameters for call to function osal_memset
   \   000051   7C06         MOV     R4,#0x6
   \   000053   7D00         MOV     R5,#0x0
   \   000055   7900         MOV     R1,#0x0
   \   000057   AA..         MOV     R2,?XSP + 0
   \   000059   AB..         MOV     R3,?XSP + 1
   \   00005B   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
    755          
    756            // Not Profile wide command (like READ, WRITE)
    757            if ( specific )
   \   00005E   741F         MOV     A,#0x1f
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   000066   6015         JZ      ??zcl_SendCommand_3
    758            {
    759              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   000068   E0           MOVX    A,@DPTR
   \   000069   54FC         ANL     A,#0xfc
   \   00006B   F8           MOV     R0,A
   \   00006C   A3           INC     DPTR
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   4401         ORL     A,#0x1
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   8003         SJMP    ??zcl_SendCommand_4
    760            }
    761            else
    762            {
    763              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_3:
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   54FC         ANL     A,#0xfc
    764            }
   \                     ??zcl_SendCommand_4:
   \   000080   12....       LCALL   ?Subroutine119 & 0xFFFF
    765          
    766            if ( ( epDesc->simpleDesc == NULL ) ||
    767                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    768                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??CrossCallReturnLabel_195:
   \   000083   A3           INC     DPTR
   \   000084   12....       LCALL   ??Subroutine177_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_341:
   \   000087   602B         JZ      ??zcl_SendCommand_5
   \   000089   741E         MOV     A,#0x1e
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   FE           MOV     R6,A
   \   000090                ; Setup parameters for call to function zcl_DeviceOperational
   \   000090   8882         MOV     DPL,R0
   \   000092   8983         MOV     DPH,R1
   \   000094   A3           INC     DPTR
   \   000095   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000098   EE           MOV     A,R6
   \   000099   FD           MOV     R5,A
   \   00009A   7402         MOV     A,#0x2
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   5403         ANL     A,#0x3
   \   0000A2   FC           MOV     R4,A
   \   0000A3   AA..         MOV     R2,?V2
   \   0000A5   AB..         MOV     R3,?V3
   \   0000A7   A9..         MOV     R1,?V10
   \   0000A9   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000AC   7402         MOV     A,#0x2
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B1   E9           MOV     A,R1
   \   0000B2   7005         JNZ     ??zcl_SendCommand_6
    769            {
    770              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   0000B4   7901         MOV     R1,#0x1
   \   0000B6   02....       LJMP    ??zcl_SendCommand_1 & 0xFFFF
    771            }
   \                     ??zcl_SendCommand_6:
   \   0000B9   7422         MOV     A,#0x22
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   12....       LCALL   ??Subroutine178_0 & 0xFFFF
    772          
    773            // Fill in the Maufacturer Code
    774            if ( manuCode != 0 )
   \                     ??CrossCallReturnLabel_335:
   \   0000C1   6012         JZ      ??CrossCallReturnLabel_308
    775            {
    776              hdr.fc.manuSpecific = 1;
   \   0000C3   85..82       MOV     DPL,?XSP + 0
   \   0000C6   85..83       MOV     DPH,?XSP + 1
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   4404         ORL     A,#0x4
   \   0000CC   F0           MOVX    @DPTR,A
    777              hdr.manuCode = manuCode;
   \   0000CD   7402         MOV     A,#0x2
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   12....       LCALL   ??Subroutine174_0 & 0xFFFF
    778            }
    779          
    780            // Set the Command Direction
    781            if ( direction )
   \                     ??CrossCallReturnLabel_308:
   \   0000D5   7420         MOV     A,#0x20
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_152:
   \   0000DD   6005         JZ      ??zcl_SendCommand_7
    782            {
    783              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   4408         ORL     A,#0x8
   \   0000E2   8003         SJMP    ??zcl_SendCommand_8
    784            }
    785            else
    786            {
    787              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_7:
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   54F7         ANL     A,#0xf7
   \                     ??zcl_SendCommand_8:
   \   0000E7   F0           MOVX    @DPTR,A
    788            }
    789          
    790            // Set the Disable Default Response field
    791            if ( disableDefaultRsp )
   \   0000E8   7421         MOV     A,#0x21
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   0000F0   6005         JZ      ??zcl_SendCommand_9
    792            {
    793              hdr.fc.disableDefaultRsp = 1;
   \   0000F2   E0           MOVX    A,@DPTR
   \   0000F3   4410         ORL     A,#0x10
   \   0000F5   8003         SJMP    ??zcl_SendCommand_10
    794            }
    795            else
    796            {
    797              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_9:
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   54EF         ANL     A,#0xef
   \                     ??zcl_SendCommand_10:
   \   0000FA   F0           MOVX    @DPTR,A
    798            }
    799          
    800            // Fill in the Transaction Sequence Number
    801            hdr.transSeqNum = seqNum;
   \   0000FB   7424         MOV     A,#0x24
   \   0000FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000100   E0           MOVX    A,@DPTR
   \   000101   C0E0         PUSH    A
   \   000103   7404         MOV     A,#0x4
   \   000105   12....       LCALL   ?XSTACK_DISP0_8
   \   000108   D0E0         POP     A
   \   00010A   F0           MOVX    @DPTR,A
    802          
    803            // Fill in the command
    804            hdr.commandID = cmd;
   \   00010B   7405         MOV     A,#0x5
   \   00010D   12....       LCALL   ?XSTACK_DISP0_8
   \   000110   EE           MOV     A,R6
   \   000111   F0           MOVX    @DPTR,A
    805          
    806            // calculate the needed buffer size
    807            msgLen = zclCalcHdrSize( &hdr );
   \   000112   75..03       MOV     ?V0,#0x3
   \   000115   85..82       MOV     DPL,?XSP + 0
   \   000118   85..83       MOV     DPH,?XSP + 1
   \   00011B   E0           MOVX    A,@DPTR
   \   00011C   5404         ANL     A,#0x4
   \   00011E   6003         JZ      ??zcl_SendCommand_11
   \   000120   75..05       MOV     ?V0,#0x5
   \                     ??zcl_SendCommand_11:
   \   000123   7425         MOV     A,#0x25
   \   000125   12....       LCALL   ?XSTACK_DISP0_8
   \   000128   12....       LCALL   ??Subroutine193_0 & 0xFFFF
    808            msgLen += cmdFormatLen;
   \                     ??CrossCallReturnLabel_412:
   \   00012B   E5..         MOV     A,?V0
   \   00012D   2E           ADD     A,R6
   \   00012E   F5..         MOV     ?V0,A
   \   000130   E4           CLR     A
   \   000131   3F           ADDC    A,R7
   \   000132   F5..         MOV     ?V1,A
    809          
    810            // Allocate the buffer needed
    811            msgBuf = zcl_mem_alloc( msgLen );
   \   000134                ; Setup parameters for call to function osal_mem_alloc
   \   000134   AA..         MOV     R2,?V0
   \   000136   FB           MOV     R3,A
   \   000137   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00013A   8A..         MOV     ?V8,R2
   \   00013C   8B..         MOV     ?V9,R3
    812            if ( msgBuf != NULL )
   \   00013E   EA           MOV     A,R2
   \   00013F   45..         ORL     A,?V9
   \   000141   6067         JZ      ??zcl_SendCommand_12
    813            {
    814              // Fill in the ZCL Header
    815              pBuf = zclBuildHdr( &hdr, msgBuf );
    816          
    817              // Fill in the command frame
    818              zcl_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   000143                ; Setup parameters for call to function osal_memcpy
   \   000143   7427         MOV     A,#0x27
   \   000145   12....       LCALL   ?XSTACK_DISP0_8
   \   000148   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00014B   75..00       MOV     ?V6,#0x0
   \   00014E   78..         MOV     R0,#?V4
   \   000150   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000153                ; Setup parameters for call to function zclBuildHdr
   \   000153   AC..         MOV     R4,?V8
   \   000155   AD..         MOV     R5,?V9
   \   000157   7403         MOV     A,#0x3
   \   000159   12....       LCALL   ?XSTACK_DISP101_8
   \   00015C   12....       LCALL   ??zclBuildHdr?relay  ; Banked call to: zclBuildHdr
   \   00015F   EE           MOV     A,R6
   \   000160   FC           MOV     R4,A
   \   000161   EF           MOV     A,R7
   \   000162   FD           MOV     R5,A
   \   000163   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000166   7403         MOV     A,#0x3
   \   000168   12....       LCALL   ?DEALLOC_XSTACK8
    819          
    820              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    821                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   00016B                ; Setup parameters for call to function AF_DataRequest
   \   00016B   75..1E       MOV     ?V4,#0x1e
   \   00016E   78..         MOV     R0,#?V4
   \   000170   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000173   75....       MOV     ?V4,#zcl_TransID & 0xff
   \   000176   75....       MOV     ?V5,#(zcl_TransID >> 8) & 0xff
   \   000179   78..         MOV     R0,#?V4
   \   00017B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00017E   78..         MOV     R0,#?V8
   \   000180   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000183   78..         MOV     R0,#?V0
   \   000185   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000188   78..         MOV     R0,#?V2
   \   00018A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00018D   A9..         MOV     R1,?V7
   \   00018F   AC..         MOV     R4,?V12
   \   000191   AD..         MOV     R5,?V13
   \   000193   AA..         MOV     R2,?V14
   \   000195   AB..         MOV     R3,?V15
   \   000197   12....       LCALL   ??AF_DataRequest?relay; Banked call to: AF_DataRequest
   \   00019A   7409         MOV     A,#0x9
   \   00019C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00019F   E9           MOV     A,R1
   \   0001A0   FE           MOV     R6,A
    822              zcl_mem_free ( msgBuf );
   \   0001A1                ; Setup parameters for call to function osal_mem_free
   \   0001A1   AA..         MOV     R2,?V8
   \   0001A3   AB..         MOV     R3,?V9
   \   0001A5   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0001A8   8002         SJMP    ??zcl_SendCommand_13
    823            }
    824            else
    825            {
    826              status = ZMemError;
   \                     ??zcl_SendCommand_12:
   \   0001AA   7E10         MOV     R6,#0x10
    827            }
    828          
    829            return ( status );
   \                     ??zcl_SendCommand_13:
   \   0001AC   EE           MOV     A,R6
   \   0001AD   F9           MOV     R1,A
   \                     ??zcl_SendCommand_1:
   \   0001AE   7406         MOV     A,#0x6
   \   0001B0   02....       LJMP    ?Subroutine4 & 0xFFFF
    830          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine177_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine178_0
   \   000002                ; // Fall through to label ??Subroutine178_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine178_0:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_388:
   \   000003   E8           MOV     A,R0
   \   000004   49           ORL     A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine138:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_390:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine201_0
   \   000003                ; // Fall through to label ??Subroutine201_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine201_0:
   \   000000   7F10         MOV     R7,#0x10
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine119:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V12
   \   000004   85..83       MOV     DPH,?V13
   \   000007   22           RET
    831          
    832          #ifdef ZCL_READ
    833          /*********************************************************************
    834           * @fn      zcl_SendRead
    835           *
    836           * @brief   Send a Read command
    837           *
    838           * @param   srcEP - Application's endpoint
    839           * @param   dstAddr - destination address
    840           * @param   clusterID - cluster ID
    841           * @param   readCmd - read command to be sent
    842           * @param   direction - direction of the command
    843           * @param   seqNum - transaction sequence number
    844           *
    845           * @return  ZSuccess if OK
    846           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    847          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    848                                  uint16 clusterID, zclReadCmd_t *readCmd,
    849                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    850          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine66 & 0xFFFF
    851            uint16 dataLen;
    852            uint8 *buf;
    853            uint8 *pBuf;
    854            ZStatus_t status;
    855          
    856            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_99:
   \   000017   E0           MOVX    A,@DPTR
   \   000018   25E0         ADD     A,0xE0 /* A   */
   \   00001A   F5..         MOV     ?V6,A
   \   00001C   E4           CLR     A
   \   00001D   33           RLC     A
   \   00001E   F5..         MOV     ?V7,A
    857          
    858            buf = zcl_mem_alloc( dataLen );
   \   000020                ; Setup parameters for call to function osal_mem_alloc
   \   000020   AA..         MOV     R2,?V6
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000026   8A..         MOV     ?V0,R2
   \   000028   8B..         MOV     ?V1,R3
    859            if ( buf != NULL )
   \   00002A   EA           MOV     A,R2
   \   00002B   45..         ORL     A,?V1
   \   00002D   7003         JNZ     $+5
   \   00002F   02....       LJMP    ??zcl_SendRead_0 & 0xFFFF
    860            {
    861              uint8 i;
    862          
    863              // Load the buffer - serially
    864              pBuf = buf;
   \   000032   A8..         MOV     R0,?V0
   \   000034   A9..         MOV     R1,?V1
    865              for (i = 0; i < readCmd->numAttr; i++)
   \   000036   75..00       MOV     ?V3,#0x0
   \   000039   801F         SJMP    ??zcl_SendRead_1
    866              {
    867                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_2:
   \   00003B   AA..         MOV     R2,?V3
   \   00003D   EA           MOV     A,R2
   \   00003E   2A           ADD     A,R2
   \   00003F   FA           MOV     R2,A
   \   000040   E4           CLR     A
   \   000041   33           RLC     A
   \   000042   FB           MOV     R3,A
   \   000043   E5..         MOV     A,?V4
   \   000045   2A           ADD     A,R2
   \   000046   F582         MOV     DPL,A
   \   000048   E5..         MOV     A,?V5
   \   00004A   3B           ADDC    A,R3
   \   00004B   F583         MOV     DPH,A
   \   00004D   A3           INC     DPTR
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ?Subroutine133 & 0xFFFF
    868                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
   \                     ??CrossCallReturnLabel_215:
   \   000055   12....       LCALL   ?Subroutine125 & 0xFFFF
    869              }
   \                     ??CrossCallReturnLabel_249:
   \   000058   05..         INC     ?V3
   \                     ??zcl_SendRead_1:
   \   00005A   85..82       MOV     DPL,?V4
   \   00005D   85..83       MOV     DPH,?V5
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   E5..         MOV     A,?V3
   \   000064   C3           CLR     C
   \   000065   9A           SUBB    A,R2
   \   000066   40D3         JC      ??zcl_SendRead_2
    870          
    871              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    872                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000068                ; Setup parameters for call to function zcl_SendCommand
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   78..         MOV     R0,#?V6
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741C         MOV     A,#0x1c
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   E4           CLR     A
   \   00007E   F5..         MOV     ?V4,A
   \   000080   F5..         MOV     ?V5,A
   \   000082   78..         MOV     R0,#?V4
   \   000084   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000087   741E         MOV     A,#0x1e
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   00008F   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000092   741E         MOV     A,#0x1e
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   00009A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00009D   75..00       MOV     ?V3,#0x0
   \   0000A0   78..         MOV     R0,#?V3
   \   0000A2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A5   78..         MOV     R0,#?V3
   \   0000A7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AA   EE           MOV     A,R6
   \   0000AB   FC           MOV     R4,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   FD           MOV     R5,A
   \   0000AE   AA..         MOV     R2,?V8
   \   0000B0   AB..         MOV     R3,?V9
   \   0000B2   A9..         MOV     R1,?V2
   \   0000B4   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000B7   740B         MOV     A,#0xb
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000BC   E9           MOV     A,R1
   \   0000BD   FE           MOV     R6,A
    873              zcl_mem_free( buf );
   \   0000BE                ; Setup parameters for call to function osal_mem_free
   \   0000BE   AA..         MOV     R2,?V0
   \   0000C0   AB..         MOV     R3,?V1
   \   0000C2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000C5   8002         SJMP    ??zcl_SendRead_3
    874            }
    875            else
    876            {
    877              status = ZMemError;
   \                     ??zcl_SendRead_0:
   \   0000C7   7E10         MOV     R6,#0x10
    878            }
    879          
    880            return ( status );
   \                     ??zcl_SendRead_3:
   \   0000C9   02....       LJMP    ?Subroutine9 & 0xFFFF
    881          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine125:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005                REQUIRE ??Subroutine157_0
   \   000005                ; // Fall through to label ??Subroutine157_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine157_0:
   \   000000   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_401:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   08           INC     R0
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   80..         SJMP    ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine160_0:
   \   000000   7F0C         MOV     R7,#0xc
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine130:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V5,A
   \   000007                ; Setup parameters for indirect call
   \   000007                ; Setup parameters for call to function findReadAttributeFn
   \   000007   85..82       MOV     DPL,?V4
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V3,A
   \   000003   78..         MOV     R0,#?V3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine133:
   \   000000   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_400:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   A882         MOV     R0,DPL
   \   000007   A983         MOV     R1,DPH
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine151:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   22           RET
    882          
    883          /*********************************************************************
    884           * @fn      zcl_SendReadRsp
    885           *
    886           * @brief   Send a Read Response command.
    887           *
    888           * @param   srcEP - Application's endpoint
    889           * @param   dstAddr - destination address
    890           * @param   clusterID - cluster ID
    891           * @param   readRspCmd - read response command to be sent
    892           * @param   direction - direction of the command
    893           * @param   seqNum - transaction sequence number
    894           *
    895           * @return  ZSuccess if OK
    896           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    897          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,  uint16 clusterID, zclReadRspCmd_t *readRspCmd, uint8 direction, uint8 disableDefaultRsp, uint8 seqNum ){
   \                     zcl_SendReadRsp:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
    898          	uint8 *buf;
    899          	uint16 len = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
    900           	ZStatus_t status;
    901           	uint8 i;
    902          
    903           	// calculate the size of the command
    904          	for ( i = 0; i < readRspCmd->numAttr; i++ ) {
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   00001D   8038         SJMP    ??zcl_SendReadRsp_0
    905              	zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_1:
   \   00001F   E5..         MOV     A,?V2
   \   000021   75F006       MOV     B,#0x6
   \   000024   A4           MUL     AB
   \   000025   F8           MOV     R0,A
   \   000026   A9F0         MOV     R1,B
   \   000028   E5..         MOV     A,?V4
   \   00002A   28           ADD     A,R0
   \   00002B   F582         MOV     DPL,A
   \   00002D   E5..         MOV     A,?V5
   \   00002F   12....       LCALL   ?Subroutine109 & 0xFFFF
    906          
    907              	len += 2 + 1; // Attribute ID + Status
   \                     ??CrossCallReturnLabel_185:
   \   000032   2403         ADD     A,#0x3
   \   000034   FE           MOV     R6,A
   \   000035   E4           CLR     A
   \   000036   3F           ADDC    A,R7
   \   000037   FF           MOV     R7,A
    908          
    909              	if ( statusRec->status == ZCL_STATUS_SUCCESS ) {
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   7018         JNZ     ??CrossCallReturnLabel_227
    910                		len++; // Attribute Data Type length
    911          
    912                 		len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
   \   00003D                ; Setup parameters for call to function zclGetAttrDataLength
   \   00003D   8882         MOV     DPL,R0
   \   00003F   8983         MOV     DPH,R1
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   12....       LCALL   ?Subroutine80 & 0xFFFF
    913              	}
    914            	}
   \                     ??CrossCallReturnLabel_128:
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F9           MOV     R1,A
   \   00004A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00004D   8B..         MOV     ?V1,R3
   \   00004F   EA           MOV     A,R2
   \   000050   2401         ADD     A,#0x1
   \   000052   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000055   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_0:
   \   000057   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00005A   40C3         JC      ??zcl_SendReadRsp_1
    915          
    916            	buf = zcl_mem_alloc( len );
   \   00005C                ; Setup parameters for call to function osal_mem_alloc
   \   00005C   EE           MOV     A,R6
   \   00005D   FA           MOV     R2,A
   \   00005E   EF           MOV     A,R7
   \   00005F   FB           MOV     R3,A
   \   000060   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000063   8A..         MOV     ?V0,R2
   \   000065   8B..         MOV     ?V1,R3
    917            	if ( buf != NULL ){
   \   000067   EA           MOV     A,R2
   \   000068   45..         ORL     A,?V1
   \   00006A   7003         JNZ     $+5
   \   00006C   02....       LJMP    ??zcl_SendReadRsp_2 & 0xFFFF
    918              	// Load the buffer - serially
    919              	uint8 *pBuf = buf;
   \   00006F   AC..         MOV     R4,?V0
   \   000071   AD..         MOV     R5,?V1
    920          
    921              	for ( i = 0; i < readRspCmd->numAttr; i++ ){
   \   000073   75..00       MOV     ?V2,#0x0
   \   000076   804F         SJMP    ??zcl_SendReadRsp_3
    922                		zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zcl_SendReadRsp_4:
   \   000078   E5..         MOV     A,?V2
   \   00007A   75F006       MOV     B,#0x6
   \   00007D   A4           MUL     AB
   \   00007E   F8           MOV     R0,A
   \   00007F   A9F0         MOV     R1,B
   \   000081   E5..         MOV     A,?V4
   \   000083   28           ADD     A,R0
   \   000084   F582         MOV     DPL,A
   \   000086   E5..         MOV     A,?V5
   \   000088   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_434:
   \   00008B   AA82         MOV     R2,DPL
   \   00008D   AB83         MOV     R3,DPH
    923          
    924                		*pBuf++ = LO_UINT16( statusRec->attrID );
   \   00008F   12....       LCALL   ?Subroutine31 & 0xFFFF
    925                		*pBuf++ = HI_UINT16( statusRec->attrID );
   \                     ??CrossCallReturnLabel_33:
   \   000092   12....       LCALL   ?Subroutine64 & 0xFFFF
    926                		*pBuf++ = statusRec->status;
   \                     ??CrossCallReturnLabel_93:
   \   000095   12....       LCALL   ?Subroutine40 & 0xFFFF
    927          
    928                		if ( statusRec->status == ZCL_STATUS_SUCCESS ) {
   \                     ??CrossCallReturnLabel_45:
   \   000098   E0           MOVX    A,@DPTR
   \   000099   702A         JNZ     ??zcl_SendReadRsp_5
    929                  		*pBuf++ = statusRec->dataType;
   \   00009B   EA           MOV     A,R2
   \   00009C   2403         ADD     A,#0x3
   \   00009E   08           INC     R0
   \   00009F   E4           CLR     A
   \   0000A0   3B           ADDC    A,R3
   \   0000A1   F9           MOV     R1,A
   \   0000A2   8882         MOV     DPL,R0
   \   0000A4   8983         MOV     DPH,R1
   \   0000A6   12....       LCALL   ?Subroutine64 & 0xFFFF
    930          
    931          	          // Copy attribute data to the buffer to be sent out
    932          	          pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
   \                     ??CrossCallReturnLabel_94:
   \   0000A9                ; Setup parameters for call to function zclSerializeData
   \   0000A9   8A82         MOV     DPL,R2
   \   0000AB   8B83         MOV     DPH,R3
   \   0000AD   A3           INC     DPTR
   \   0000AE   A3           INC     DPTR
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   12....       LCALL   ??Subroutine198_0 & 0xFFFF
    933              		}
    934              	} // for loop
   \                     ??CrossCallReturnLabel_447:
   \   0000B4   8882         MOV     DPL,R0
   \   0000B6   8983         MOV     DPH,R1
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   F9           MOV     R1,A
   \   0000BA   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000BD   8A..         MOV     ?V10,R2
   \   0000BF   8B..         MOV     ?V11,R3
   \   0000C1   AC..         MOV     R4,?V10
   \   0000C3   AD..         MOV     R5,?V11
   \                     ??zcl_SendReadRsp_5:
   \   0000C5   05..         INC     ?V2
   \                     ??zcl_SendReadRsp_3:
   \   0000C7   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   0000CA   40AC         JC      ??zcl_SendReadRsp_4
    935          
    936              	status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,  direction, disableDefaultRsp, 0, seqNum, len, buf );
   \   0000CC                ; Setup parameters for call to function zcl_SendCommand
   \   0000CC   78..         MOV     R0,#?V0
   \   0000CE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D1   8E..         MOV     ?V4,R6
   \   0000D3   8F..         MOV     ?V5,R7
   \   0000D5   78..         MOV     R0,#?V4
   \   0000D7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DA   741C         MOV     A,#0x1c
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   0000E2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E5   E4           CLR     A
   \   0000E6   F5..         MOV     ?V4,A
   \   0000E8   F5..         MOV     ?V5,A
   \   0000EA   78..         MOV     R0,#?V4
   \   0000EC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EF   741E         MOV     A,#0x1e
   \   0000F1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F4   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   0000F7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FA   741E         MOV     A,#0x1e
   \   0000FC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FF   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000105   75..00       MOV     ?V2,#0x0
   \   000108   78..         MOV     R0,#?V2
   \   00010A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00010D   75..01       MOV     ?V2,#0x1
   \   000110   78..         MOV     R0,#?V2
   \   000112   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000115   AC..         MOV     R4,?V6
   \   000117   AD..         MOV     R5,?V7
   \   000119   AA..         MOV     R2,?V8
   \   00011B   AB..         MOV     R3,?V9
   \   00011D   A9..         MOV     R1,?V3
   \   00011F   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000122   740B         MOV     A,#0xb
   \   000124   12....       LCALL   ?DEALLOC_XSTACK8
   \   000127   E9           MOV     A,R1
   \   000128   FE           MOV     R6,A
    937              	zcl_mem_free( buf );
   \   000129                ; Setup parameters for call to function osal_mem_free
   \   000129   AA..         MOV     R2,?V0
   \   00012B   AB..         MOV     R3,?V1
   \   00012D   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000130   8002         SJMP    ??zcl_SendReadRsp_6
    938          	} else {
    939              	status = ZMemError;
   \                     ??zcl_SendReadRsp_2:
   \   000132   7E10         MOV     R6,#0x10
    940          	}
    941          
    942          	return ( status );
   \                     ??zcl_SendReadRsp_6:
   \   000134   02....       LJMP    ?Subroutine9 & 0xFFFF
    943          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine159_0
   \   000006                ; // Fall through to label ??Subroutine159_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine159_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V2
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine109:
   \   000000   12....       LCALL   ??Subroutine168_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_281:
   \   000003   EE           MOV     A,R6
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine146:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V1
   \   000004   F9           MOV     R1,A
   \   000005   EE           MOV     A,R6
   \   000006   28           ADD     A,R0
   \   000007   FE           MOV     R6,A
   \   000008   EF           MOV     A,R7
   \   000009   39           ADDC    A,R1
   \   00000A   FF           MOV     R7,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine168_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   A882         MOV     R0,DPL
   \   000006   A983         MOV     R1,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine171_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V2,A
   \   000003   78..         MOV     R0,#?V2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine154:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine135:
   \   000000   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine150:
   \   000000   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_242:
   \   000003   0C           INC     R4
   \   000004   AD83         MOV     R5,DPH
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   EA           MOV     A,R2
   \   000001   2402         ADD     A,#0x2
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   3B           ADDC    A,R3
   \   000006   F9           MOV     R1,A
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine121:
   \   000000   12....       LCALL   ?Subroutine150 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003                ; Setup parameters for call to function zclSerializeData
   \   000003                ; Setup parameters for call to function zclSerializeData
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   12....       LCALL   ?Subroutine120 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine120:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   AC82         MOV     R4,DPL
   \   000004   AD83         MOV     R5,DPH
   \   000006   8A82         MOV     DPL,R2
   \   000008   8B83         MOV     DPH,R3
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine196_0:
   \   000000   39           ADDC    A,R1
   \   000001   F583         MOV     DPH,A
   \   000003   A3           INC     DPTR
   \   000004   22           RET
    944          #endif // ZCL_READ
    945          
    946          #ifdef ZCL_WRITE
    947          /*********************************************************************
    948           * @fn      sendWriteRequest
    949           *
    950           * @brief   Send a Write command
    951           *
    952           * @param   dstAddr - destination address
    953           * @param   clusterID - cluster ID
    954           * @param   writeCmd - write command to be sent
    955           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    956           * @param   direction - direction of the command
    957           * @param   seqNum - transaction sequence number
    958           *
    959           * @return  ZSuccess if OK
    960           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    961          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
    962                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
    963                                          uint8 disableDefaultRsp, uint8 seqNum )
    964          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
    965            uint8 *buf;
    966            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
    967            ZStatus_t status;
    968            uint8 i;
    969          
    970            for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   00001D   800E         SJMP    ??CrossCallReturnLabel_187
    971            {
    972              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   00001F   E5..         MOV     A,?V2
   \   000021   75F006       MOV     B,#0x6
   \   000024   12....       LCALL   ?Subroutine76 & 0xFFFF
    973          
    974              dataLen += 2 + 1; // Attribute ID + Attribute Type
    975          
    976              // Attribute Data
    977              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    978            }
   \                     ??CrossCallReturnLabel_121:
   \   000027   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002A   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   00002D   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000030   40ED         JC      ??zcl_SendWriteRequest_0
    979          
    980            buf = zcl_mem_alloc( dataLen );
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   EE           MOV     A,R6
   \   000033   FA           MOV     R2,A
   \   000034   EF           MOV     A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV     ?V0,R2
   \   00003B   8B..         MOV     ?V1,R3
    981            if ( buf != NULL )
   \   00003D   EA           MOV     A,R2
   \   00003E   45..         ORL     A,?V1
   \   000040   7003         JNZ     $+5
   \   000042   02....       LJMP    ??zcl_SendWriteRequest_1 & 0xFFFF
    982            {
    983              // Load the buffer - serially
    984              uint8 *pBuf = buf;
   \   000045   AC..         MOV     R4,?V0
   \   000047   AD..         MOV     R5,?V1
    985              for ( i = 0; i < writeCmd->numAttr; i++ )
   \   000049   75..00       MOV     ?V2,#0x0
   \   00004C   8015         SJMP    ??zcl_SendWriteRequest_2
    986              {
    987                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_3:
   \   00004E   E5..         MOV     A,?V2
   \   000050   75F006       MOV     B,#0x6
   \   000053   12....       LCALL   ?Subroutine11 & 0xFFFF
    988          
    989                *pBuf++ = LO_UINT16( statusRec->attrID );
    990                *pBuf++ = HI_UINT16( statusRec->attrID );
    991                *pBuf++ = statusRec->dataType;
    992          
    993                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    994              }
   \                     ??CrossCallReturnLabel_0:
   \   000056   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000059   8A..         MOV     ?V10,R2
   \   00005B   8B..         MOV     ?V11,R3
   \   00005D   AC..         MOV     R4,?V10
   \   00005F   AD..         MOV     R5,?V11
   \   000061   05..         INC     ?V2
   \                     ??zcl_SendWriteRequest_2:
   \   000063   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000066   40E6         JC      ??zcl_SendWriteRequest_3
    995          
    996              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
    997                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000068                ; Setup parameters for call to function zcl_SendCommand
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   8E..         MOV     ?V4,R6
   \   00006F   8F..         MOV     ?V5,R7
   \   000071   78..         MOV     R0,#?V4
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000076   741D         MOV     A,#0x1d
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_296:
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000081   E4           CLR     A
   \   000082   F5..         MOV     ?V4,A
   \   000084   F5..         MOV     ?V5,A
   \   000086   78..         MOV     R0,#?V4
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   741F         MOV     A,#0x1f
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_297:
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000096   741F         MOV     A,#0x1f
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_298:
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   75..00       MOV     ?V2,#0x0
   \   0000A4   78..         MOV     R0,#?V2
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A9   7420         MOV     A,#0x20
   \   0000AB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AE   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_299:
   \   0000B1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B4   AC..         MOV     R4,?V6
   \   0000B6   AD..         MOV     R5,?V7
   \   0000B8   AA..         MOV     R2,?V8
   \   0000BA   AB..         MOV     R3,?V9
   \   0000BC   A9..         MOV     R1,?V3
   \   0000BE   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000C1   740B         MOV     A,#0xb
   \   0000C3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C6   E9           MOV     A,R1
   \   0000C7   FE           MOV     R6,A
    998              zcl_mem_free( buf );
   \   0000C8                ; Setup parameters for call to function osal_mem_free
   \   0000C8   AA..         MOV     R2,?V0
   \   0000CA   AB..         MOV     R3,?V1
   \   0000CC   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000CF   8002         SJMP    ??zcl_SendWriteRequest_4
    999            }
   1000            else
   1001            {
   1002              status = ZMemError;
   \                     ??zcl_SendWriteRequest_1:
   \   0000D1   7E10         MOV     R6,#0x10
   1003            }
   1004          
   1005            return ( status);
   \                     ??zcl_SendWriteRequest_4:
   \   0000D3   02....       LJMP    ?Subroutine9 & 0xFFFF
   1006          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine110:
   \   000000   8B..         MOV     ?V1,R3
   \   000002   EA           MOV     A,R2
   \   000003   2403         ADD     A,#0x3
   \   000005   12....       LCALL   ?Subroutine146 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000008   05..         INC     ?V2
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003                ; Setup parameters for call to function zclGetAttrDataLength
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   12....       LCALL   ?Subroutine129 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine144:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V4
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V5
   \   00000B                REQUIRE ??Subroutine168_0
   \   00000B                ; // Fall through to label ??Subroutine168_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine144 & 0xFFFF
   \                     ??CrossCallReturnLabel_282:
   \   000003   12....       LCALL   ?Subroutine154 & 0xFFFF
   \                     ??CrossCallReturnLabel_241:
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   8882         MOV     DPL,R0
   \   00000C   8983         MOV     DPH,R1
   \   00000E   A3           INC     DPTR
   \   00000F   12....       LCALL   ?Subroutine135 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   000012   E8           MOV     A,R0
   \   000013   2402         ADD     A,#0x2
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   39           ADDC    A,R1
   \   000018   FB           MOV     R3,A
   \   000019   8A..         MOV     ?V10,R2
   \   00001B   8B..         MOV     ?V11,R3
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine121 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   00002A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine128:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V10
   \   000008   85..83       MOV     DPH,?V11
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   22           RET
   1007          
   1008          /*********************************************************************
   1009           * @fn      zcl_SendWriteRsp
   1010           *
   1011           * @brief   Send a Write Response command
   1012           *
   1013           * @param   dstAddr - destination address
   1014           * @param   clusterID - cluster ID
   1015           * @param   wrtieRspCmd - write response command to be sent
   1016           * @param   direction - direction of the command
   1017           * @param   seqNum - transaction sequence number
   1018           *
   1019           * @return  ZSuccess if OK
   1020           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1021          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
   1022                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
   1023                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1024          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine51 & 0xFFFF
   1025            uint16 dataLen;
   1026            uint8 *buf;
   1027            ZStatus_t status;
   1028          
   1029            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1030          
   1031            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_58:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1032            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendWriteRsp_0 & 0xFFFF
   1033            {
   1034              // Load the buffer - serially
   1035              uint8 i;
   1036              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1037              for ( i = 0; i < writeRspCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_10
   1038              {
   1039                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_1:
   \   00002E   12....       LCALL   ?Subroutine37 & 0xFFFF
   1040                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1041                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1042              }
   \                     ??CrossCallReturnLabel_41:
   \   000031   5001         JNC     ??zcl_SendWriteRsp_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendWriteRsp_2:
   \   000034   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendWriteRsp_1
   1043          
   1044              // If there's only a single status record and its status field is set to
   1045              // SUCCESS then omit the attribute ID field.
   1046              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000044   7401         MOV     A,#0x1
   \   000046   6A           XRL     A,R2
   \   000047   700A         JNZ     ??zcl_SendWriteRsp_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   7006         JNZ     ??zcl_SendWriteRsp_3
   1047              {
   1048                dataLen = 1;
   \   00004D   75..01       MOV     ?V6,#0x1
   \   000050   75..00       MOV     ?V7,#0x0
   1049              }
   1050          
   1051              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1052                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   000053                ; Setup parameters for call to function zcl_SendCommand
   \   000053   78..         MOV     R0,#?V0
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   78..         MOV     R0,#?V6
   \   00005A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005D   741C         MOV     A,#0x1c
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   000065   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000068   E4           CLR     A
   \   000069   F5..         MOV     ?V4,A
   \   00006B   F5..         MOV     ?V5,A
   \   00006D   78..         MOV     R0,#?V4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   741E         MOV     A,#0x1e
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00007D   741E         MOV     A,#0x1e
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000088   75..00       MOV     ?V3,#0x0
   \   00008B   78..         MOV     R0,#?V3
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000090   75..04       MOV     ?V3,#0x4
   \   000093   78..         MOV     R0,#?V3
   \   000095   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000098   EE           MOV     A,R6
   \   000099   FC           MOV     R4,A
   \   00009A   EF           MOV     A,R7
   \   00009B   FD           MOV     R5,A
   \   00009C   AA..         MOV     R2,?V8
   \   00009E   AB..         MOV     R3,?V9
   \   0000A0   A9..         MOV     R1,?V2
   \   0000A2   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000A5   740B         MOV     A,#0xb
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   E9           MOV     A,R1
   \   0000AB   FE           MOV     R6,A
   1053              zcl_mem_free( buf );
   \   0000AC                ; Setup parameters for call to function osal_mem_free
   \   0000AC   AA..         MOV     R2,?V0
   \   0000AE   AB..         MOV     R3,?V1
   \   0000B0   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000B3   8002         SJMP    ??zcl_SendWriteRsp_4
   1054            }
   1055            else
   1056            {
   1057              status = ZMemError;
   \                     ??zcl_SendWriteRsp_0:
   \   0000B5   7E10         MOV     R6,#0x10
   1058            }
   1059          
   1060            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   0000B7                REQUIRE ?Subroutine9
   \   0000B7                ; // Fall through to label ?Subroutine9
   1061          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ?Subroutine130 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   75F003       MOV     B,#0x3
   \   000007   A4           MUL     AB
   \   000008   F5..         MOV     ?V6,A
   \   00000A   E5F0         MOV     A,B
   \   00000C   F5..         MOV     ?V7,A
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E                ; Setup parameters for call to function osal_mem_alloc
   \   00000E   AA..         MOV     R2,?V6
   \   000010   FB           MOV     R3,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   EC           MOV     A,R4
   \   000001   75F003       MOV     B,#0x3
   \   000004   A4           MUL     AB
   \   000005   FA           MOV     R2,A
   \   000006   ABF0         MOV     R3,B
   \   000008   E5..         MOV     A,?V4
   \   00000A   2A           ADD     A,R2
   \   00000B   FA           MOV     R2,A
   \   00000C   E5..         MOV     A,?V5
   \   00000E   3B           ADDC    A,R3
   \   00000F   FB           MOV     R3,A
   \   000010   8A82         MOV     DPL,R2
   \   000012   8B83         MOV     DPH,R3
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine133 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000018   EA           MOV     A,R2
   \   000019   2402         ADD     A,#0x2
   \   00001B   FA           MOV     R2,A
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   12....       LCALL   ??Subroutine157_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000007   12....       LCALL   ?Subroutine125 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   00000A   0C           INC     R4
   \   00000B   22           RET
   1062          #endif // ZCL_WRITE
   1063          
   1064          #ifdef ZCL_REPORT
   1065          /*********************************************************************
   1066           * @fn      zcl_SendConfigReportCmd
   1067           *
   1068           * @brief   Send a Configure Reporting command
   1069           *
   1070           * @param   dstAddr - destination address
   1071           * @param   clusterID - cluster ID
   1072           * @param   cfgReportCmd - configure reporting command to be sent
   1073           * @param   direction - direction of the command
   1074           * @param   seqNum - transaction sequence number
   1075           *
   1076           * @return  ZSuccess if OK
   1077           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1078          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1079                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1080                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1081          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1082            uint8 *buf;
   1083            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1084            ZStatus_t status;
   1085            uint8 i;
   1086          
   1087            // Find out the data length
   1088            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   00001D   8009         SJMP    ??zcl_SendConfigReportCmd_0
   1089            {
   1090              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1091          
   1092              dataLen += 1 + 2; // Direction + Attribute ID
   1093          
   1094              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1095              {
   1096                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1097          
   1098                // Find out the size of the Reportable Change field (for Analog data types)
   1099                if ( zclAnalogDataType( reportRec->dataType ) )
   1100                {
   1101                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1102                }
   1103              }
   1104              else
   1105              {
   1106                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendConfigReportCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1107              }
   \                     ??zcl_SendConfigReportCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_0:
   \   000028   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   00002B   5040         JNC     ??zcl_SendConfigReportCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00C       MOV     B,#0xc
   \   000032   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_438:
   \   000035   EE           MOV     A,R6
   \   000036   2403         ADD     A,#0x3
   \   000038   FE           MOV     R6,A
   \   000039   E4           CLR     A
   \   00003A   3F           ADDC    A,R7
   \   00003B   FF           MOV     R7,A
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   70E0         JNZ     ??zcl_SendConfigReportCmd_1
   \   00003F   EE           MOV     A,R6
   \   000040   2405         ADD     A,#0x5
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E582         MOV     A,DPL
   \   000048   2403         ADD     A,#0x3
   \   00004A   F5..         MOV     ?V2,A
   \   00004C   E4           CLR     A
   \   00004D   3583         ADDC    A,DPH
   \   00004F   F5..         MOV     ?V3,A
   \   000051                ; Setup parameters for call to function zclAnalogDataType
   \   000051   85..82       MOV     DPL,?V2
   \   000054   F583         MOV     DPH,A
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F9           MOV     R1,A
   \   000058   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005B   E9           MOV     A,R1
   \   00005C   60C8         JZ      ??zcl_SendConfigReportCmd_3
   \   00005E                ; Setup parameters for call to function zclGetDataTypeLength
   \   00005E   85..82       MOV     DPL,?V2
   \   000061   85..83       MOV     DPH,?V3
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F9           MOV     R1,A
   \   000066   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000069   EE           MOV     A,R6
   \   00006A   29           ADD     A,R1
   \   00006B   80B5         SJMP    ??zcl_SendConfigReportCmd_2
   1108            }
   1109          
   1110            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_4:
   \   00006D                ; Setup parameters for call to function osal_mem_alloc
   \   00006D   EE           MOV     A,R6
   \   00006E   FA           MOV     R2,A
   \   00006F   EF           MOV     A,R7
   \   000070   FB           MOV     R3,A
   \   000071   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000074   8A..         MOV     ?V2,R2
   \   000076   8B..         MOV     ?V3,R3
   1111            if ( buf != NULL )
   \   000078   EA           MOV     A,R2
   \   000079   45..         ORL     A,?V3
   \   00007B   7003         JNZ     $+5
   \   00007D   02....       LJMP    ??zcl_SendConfigReportCmd_5 & 0xFFFF
   1112            {
   1113              // Load the buffer - serially
   1114              uint8 *pBuf = buf;
   \   000080   8A..         MOV     ?V6,R2
   \   000082   8B..         MOV     ?V7,R3
   1115          
   1116              for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000084   75..00       MOV     ?V0,#0x0
   \   000087   8009         SJMP    ??zcl_SendConfigReportCmd_6
   1117              {
   1118                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1119          
   1120                *pBuf++ = reportRec->direction;
   1121                *pBuf++ = LO_UINT16( reportRec->attrID );
   1122                *pBuf++ = HI_UINT16( reportRec->attrID );
   1123          
   1124                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1125                {
   1126                  *pBuf++ = reportRec->dataType;
   1127                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1128                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1129                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1130                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1131          
   1132                  if ( zclAnalogDataType( reportRec->dataType ) )
   1133                  {
   1134                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1135                  }
   1136                }
   1137                else
   1138                {
   1139                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_7:
   \   000089   E5..         MOV     A,?V4
   \   00008B   2408         ADD     A,#0x8
   \   00008D   12....       LCALL   ?Subroutine20 & 0xFFFF
   1140                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1141                }
   \                     ??CrossCallReturnLabel_12:
   \   000090   05..         INC     ?V0
   \                     ??zcl_SendConfigReportCmd_6:
   \   000092   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000095   5054         JNC     ??zcl_SendConfigReportCmd_8
   \   000097   E5..         MOV     A,?V0
   \   000099   75F00C       MOV     B,#0xc
   \   00009C   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   00009F   A882         MOV     R0,DPL
   \   0000A1   A983         MOV     R1,DPH
   \   0000A3   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000A6   A3           INC     DPTR
   \   0000A7   A882         MOV     R0,DPL
   \   0000A9   A983         MOV     R1,DPH
   \   0000AB   85..82       MOV     DPL,?V4
   \   0000AE   85..83       MOV     DPH,?V5
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   70D5         JNZ     ??zcl_SendConfigReportCmd_7
   \   0000B4   E5..         MOV     A,?V4
   \   0000B6   2403         ADD     A,#0x3
   \   0000B8   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   0000BB   2404         ADD     A,#0x4
   \   0000BD   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0000C0   2406         ADD     A,#0x6
   \   0000C2   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000C5   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000C8   E9           MOV     A,R1
   \   0000C9   60C5         JZ      ??CrossCallReturnLabel_12
   \   0000CB                ; Setup parameters for call to function zclSerializeData
   \   0000CB   AC..         MOV     R4,?V6
   \   0000CD   AD..         MOV     R5,?V7
   \   0000CF   85..82       MOV     DPL,?V4
   \   0000D2   85..83       MOV     DPH,?V5
   \   0000D5   A3           INC     DPTR
   \   0000D6   A3           INC     DPTR
   \   0000D7   A3           INC     DPTR
   \   0000D8   A3           INC     DPTR
   \   0000D9   A3           INC     DPTR
   \   0000DA   A3           INC     DPTR
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   12....       LCALL   ?Subroutine77 & 0xFFFF
   1142              } // for loop
   \                     ??CrossCallReturnLabel_123:
   \   0000E2   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   0000E5   8A..         MOV     ?V6,R2
   \   0000E7   8B..         MOV     ?V7,R3
   \   0000E9   80A5         SJMP    ??CrossCallReturnLabel_12
   1143          
   1144              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1145                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_8:
   \   0000EB                ; Setup parameters for call to function zcl_SendCommand
   \   0000EB   78..         MOV     R0,#?V2
   \   0000ED   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F0   8E..         MOV     ?V4,R6
   \   0000F2   8F..         MOV     ?V5,R7
   \   0000F4   78..         MOV     R0,#?V4
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   7420         MOV     A,#0x20
   \   0000FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FE   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000104   E4           CLR     A
   \   000105   F5..         MOV     ?V4,A
   \   000107   F5..         MOV     ?V5,A
   \   000109   78..         MOV     R0,#?V4
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   7422         MOV     A,#0x22
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000119   7422         MOV     A,#0x22
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000121   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000124   75..00       MOV     ?V0,#0x0
   \   000127   78..         MOV     R0,#?V0
   \   000129   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00012C   75..06       MOV     ?V0,#0x6
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000134   AC..         MOV     R4,?V12
   \   000136   AD..         MOV     R5,?V13
   \   000138   AA..         MOV     R2,?V14
   \   00013A   AB..         MOV     R3,?V15
   \   00013C   A9..         MOV     R1,?V1
   \   00013E   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000141   740B         MOV     A,#0xb
   \   000143   12....       LCALL   ?DEALLOC_XSTACK8
   \   000146   E9           MOV     A,R1
   \   000147   FE           MOV     R6,A
   1146              zcl_mem_free( buf );
   \   000148                ; Setup parameters for call to function osal_mem_free
   \   000148   AA..         MOV     R2,?V2
   \   00014A   AB..         MOV     R3,?V3
   \   00014C   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   00014F   8002         SJMP    ??zcl_SendConfigReportCmd_9
   1147            }
   1148            else
   1149            {
   1150              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_5:
   \   000151   7E10         MOV     R6,#0x10
   1151            }
   1152          
   1153            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   000153                REQUIRE ?Subroutine10
   \   000153                ; // Fall through to label ?Subroutine10
   1154          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   EE           MOV     A,R6
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ??Subroutine201_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006                REQUIRE ??Subroutine161_0
   \   000006                ; // Fall through to label ??Subroutine161_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine161_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   E5..         MOV     A,?V0
   \   000004   C3           CLR     C
   \   000005   98           SUBB    A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine118:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000003                REQUIRE ??Subroutine165_0
   \   000003                ; // Fall through to label ??Subroutine165_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine165_0:
   \   000000   12....       LCALL   ??Subroutine167_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V8,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V9,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   12....       LCALL   ?Subroutine128 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   F5..         MOV     ?V10,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V5
   \   000005   F5..         MOV     ?V11,A
   \   000007   85..82       MOV     DPL,?V10
   \   00000A   F583         MOV     DPH,A
   \   00000C   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   00000F   88..         MOV     ?V6,R0
   \   000011   89..         MOV     ?V7,R1
   \   000013   E5..         MOV     A,?V4
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL   ?Subroutine145 & 0xFFFF
   \                     ??CrossCallReturnLabel_439:
   \   000003   8582..       MOV     ?V4,DPL
   \   000006   8583..       MOV     ?V5,DPH
   \   000009   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_274:
   \   00000C   85..82       MOV     DPL,?V4
   \   00000F   85..83       MOV     DPH,?V5
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   FA           MOV     R2,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   FB           MOV     R3,A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine142 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_399:
   \   000014   12....       LCALL   ??Subroutine165_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_272:
   \   000017   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine142:
   \   000000   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine148:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ??Subroutine166_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000003   E5..         MOV     A,?V4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine116:
   \   000000   F8           MOV     R0,A
   \   000001   E4           CLR     A
   \   000002   35..         ADDC    A,?V5
   \   000004   F9           MOV     R1,A
   \   000005   8882         MOV     DPL,R0
   \   000007   8983         MOV     DPH,R1
   \   000009                REQUIRE ??Subroutine166_0
   \   000009                ; // Fall through to label ??Subroutine166_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine166_0:
   \   000000   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   8882         MOV     DPL,R0
   \   000005   8983         MOV     DPH,R1
   \   000007   A3           INC     DPTR
   \   000008   12....       LCALL   ?Subroutine147 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine147:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007                REQUIRE ??Subroutine167_0
   \   000007                ; // Fall through to label ??Subroutine167_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine167_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   8582..       MOV     ?V6,DPL
   \   000005   8583..       MOV     ?V7,DPH
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   12....       LCALL   ?Subroutine116 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003                ; Setup parameters for call to function zclAnalogDataType
   \   000003   85..82       MOV     DPL,?V10
   \   000006   85..83       MOV     DPH,?V11
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   78..         MOV     R0,#?V0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine145:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V8
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V9
   \   00000B                REQUIRE ??Subroutine196_0
   \   00000B                ; // Fall through to label ??Subroutine196_0
   1155          
   1156          /*********************************************************************
   1157           * @fn      zcl_SendConfigReportRspCmd
   1158           *
   1159           * @brief   Send a Configure Reporting Response command
   1160           *
   1161           * @param   dstAddr - destination address
   1162           * @param   clusterID - cluster ID
   1163           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1164           * @param   direction - direction of the command
   1165           * @param   seqNum - transaction sequence number
   1166           *
   1167           * @return  ZSuccess if OK
   1168           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1169          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1170                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1171                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1172          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine66 & 0xFFFF
   1173            uint16 dataLen;
   1174            uint8 *buf;
   1175            ZStatus_t status;
   1176          
   1177            // Atrribute list (Status, Direction and Attribute ID)
   1178            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \                     ??CrossCallReturnLabel_100:
   \   000017   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   85....       MOV     ?V6,?V0
   \   000020   85....       MOV     ?V7,?V1
   1179          
   1180            buf = zcl_mem_alloc( dataLen );
   \   000023                ; Setup parameters for call to function osal_mem_alloc
   \   000023   AA..         MOV     R2,?V6
   \   000025   AB..         MOV     R3,?V7
   \   000027   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002A   8A..         MOV     ?V0,R2
   \   00002C   8B..         MOV     ?V1,R3
   1181            if ( buf != NULL )
   \   00002E   EA           MOV     A,R2
   \   00002F   45..         ORL     A,?V1
   \   000031   7003         JNZ     $+5
   \   000033   02....       LJMP    ??zcl_SendConfigReportRspCmd_0 & 0xFFFF
   1182            {
   1183              // Load the buffer - serially
   1184              uint8 *pBuf = buf;
   1185              uint8 i;
   1186          
   1187              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000036   7C00         MOV     R4,#0x0
   \   000038   8041         SJMP    ??zcl_SendConfigReportRspCmd_1
   1188              {
   1189                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   00003A   8C..         MOV     ?V10,R4
   \   00003C   75..00       MOV     ?V11,#0x0
   \   00003F   7402         MOV     A,#0x2
   \   000041   78..         MOV     R0,#?V10
   \   000043   12....       LCALL   ?S_SHL
   \   000046   E5..         MOV     A,?V4
   \   000048   25..         ADD     A,?V10
   \   00004A   F8           MOV     R0,A
   \   00004B   E5..         MOV     A,?V5
   \   00004D   35..         ADDC    A,?V11
   \   00004F   F9           MOV     R1,A
   \   000050   8882         MOV     DPL,R0
   \   000052   8983         MOV     DPH,R1
   \   000054   A3           INC     DPTR
   \   000055   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000058   A3           INC     DPTR
   \   000059   AA82         MOV     R2,DPL
   \   00005B   AB83         MOV     R3,DPH
   1190                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   00005D   8882         MOV     DPL,R0
   \   00005F   8983         MOV     DPH,R1
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine32 & 0xFFFF
   1191                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_270:
   \   000065   E8           MOV     A,R0
   \   000066   2403         ADD     A,#0x3
   \   000068   F8           MOV     R0,A
   \   000069   5001         JNC     ??zcl_SendConfigReportRspCmd_3
   \   00006B   09           INC     R1
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00006C   8882         MOV     DPL,R0
   \   00006E   8983         MOV     DPH,R1
   \   000070   12....       LCALL   ??Subroutine162_0 & 0xFFFF
   1192                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \                     ??CrossCallReturnLabel_269:
   \   000073   8882         MOV     DPL,R0
   \   000075   8983         MOV     DPH,R1
   \   000077   12....       LCALL   ?Subroutine32 & 0xFFFF
   1193              }
   \                     ??CrossCallReturnLabel_271:
   \   00007A   0C           INC     R4
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   00007B   85..82       MOV     DPL,?V4
   \   00007E   85..83       MOV     DPH,?V5
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F8           MOV     R0,A
   \   000083   EC           MOV     A,R4
   \   000084   C3           CLR     C
   \   000085   98           SUBB    A,R0
   \   000086   40B2         JC      ??zcl_SendConfigReportRspCmd_2
   1194          
   1195              // If there's only a single status record and its status field is set to
   1196              // SUCCESS then omit the attribute ID field.
   1197              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000088   7401         MOV     A,#0x1
   \   00008A   68           XRL     A,R0
   \   00008B   700A         JNZ     ??zcl_SendConfigReportRspCmd_4
   \   00008D   A3           INC     DPTR
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   7006         JNZ     ??zcl_SendConfigReportRspCmd_4
   1198              {
   1199                dataLen = 1;
   \   000091   75..01       MOV     ?V6,#0x1
   \   000094   75..00       MOV     ?V7,#0x0
   1200              }
   1201          
   1202              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1203                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1204                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   000097                ; Setup parameters for call to function zcl_SendCommand
   \   000097   78..         MOV     R0,#?V0
   \   000099   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009C   78..         MOV     R0,#?V6
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   741C         MOV     A,#0x1c
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000AC   E4           CLR     A
   \   0000AD   F5..         MOV     ?V4,A
   \   0000AF   F5..         MOV     ?V5,A
   \   0000B1   78..         MOV     R0,#?V4
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   741E         MOV     A,#0x1e
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000BE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000C1   741E         MOV     A,#0x1e
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0000C9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000CC   75..00       MOV     ?V3,#0x0
   \   0000CF   78..         MOV     R0,#?V3
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   75..07       MOV     ?V3,#0x7
   \   0000D7   78..         MOV     R0,#?V3
   \   0000D9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000DC   EE           MOV     A,R6
   \   0000DD   FC           MOV     R4,A
   \   0000DE   EF           MOV     A,R7
   \   0000DF   FD           MOV     R5,A
   \   0000E0   AA..         MOV     R2,?V8
   \   0000E2   AB..         MOV     R3,?V9
   \   0000E4   A9..         MOV     R1,?V2
   \   0000E6   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000E9   740B         MOV     A,#0xb
   \   0000EB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000EE   E9           MOV     A,R1
   \   0000EF   FE           MOV     R6,A
   1205              zcl_mem_free( buf );
   \   0000F0                ; Setup parameters for call to function osal_mem_free
   \   0000F0   AA..         MOV     R2,?V0
   \   0000F2   AB..         MOV     R3,?V1
   \   0000F4   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000F7   8002         SJMP    ??zcl_SendConfigReportRspCmd_5
   1206            }
   1207            else
   1208            {
   1209              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   0000F9   7E10         MOV     R6,#0x10
   1210            }
   1211          
   1212            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_5:
   \   0000FB   02....       LJMP    ?Subroutine9 & 0xFFFF
   1213          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine162_0
   \   000001                ; // Fall through to label ??Subroutine162_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine162_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001                REQUIRE ??Subroutine163_0
   \   000001                ; // Fall through to label ??Subroutine163_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine163_0:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004                REQUIRE ??Subroutine164_0
   \   000004                ; // Fall through to label ??Subroutine164_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine164_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   0A           INC     R2
   \   000003   AB83         MOV     R3,DPH
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0,A
   \   000003   75..00       MOV     ?V1,#0x0
   \   000006   7402         MOV     A,#0x2
   \   000008   78..         MOV     R0,#?V0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET
   1214          
   1215          /*********************************************************************
   1216           * @fn      zcl_SendReadReportCfgCmd
   1217           *
   1218           * @brief   Send a Read Reporting Configuration command
   1219           *
   1220           * @param   dstAddr - destination address
   1221           * @param   clusterID - cluster ID
   1222           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1223           * @param   direction - direction of the command
   1224           * @param   seqNum - transaction sequence number
   1225           *
   1226           * @return  ZSuccess if OK
   1227           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1228          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1229                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1230                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1231          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V2,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FE           MOV     R6,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FF           MOV     R7,A
   \   00000F   7414         MOV     A,#0x14
   \   000011   12....       LCALL   ?XSTACK_DISP0_8
   \   000014   12....       LCALL   ?Subroutine51 & 0xFFFF
   1232            uint16 dataLen;
   1233            uint8 *buf;
   1234            ZStatus_t status;
   1235          
   1236            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1237          
   1238            buf = zcl_mem_alloc( dataLen );
   \                     ??CrossCallReturnLabel_59:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00001A   8A..         MOV     ?V0,R2
   \   00001C   8B..         MOV     ?V1,R3
   1239            if ( buf != NULL )
   \   00001E   EA           MOV     A,R2
   \   00001F   45..         ORL     A,?V1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??zcl_SendReadReportCfgCmd_0 & 0xFFFF
   1240            {
   1241              // Load the buffer - serially
   1242              uint8 *pBuf = buf;
   \   000026   A8..         MOV     R0,?V0
   \   000028   A9..         MOV     R1,?V1
   1243              uint8 i;
   1244          
   1245              for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00002A   7C00         MOV     R4,#0x0
   \   00002C   8009         SJMP    ??CrossCallReturnLabel_11
   1246              {
   1247                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   00002E   12....       LCALL   ?Subroutine37 & 0xFFFF
   1248                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1249                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1250              }
   \                     ??CrossCallReturnLabel_42:
   \   000031   5001         JNC     ??zcl_SendReadReportCfgCmd_2
   \   000033   0B           INC     R3
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000034   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000037   85..82       MOV     DPL,?V4
   \   00003A   85..83       MOV     DPH,?V5
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   FA           MOV     R2,A
   \   00003F   EC           MOV     A,R4
   \   000040   C3           CLR     C
   \   000041   9A           SUBB    A,R2
   \   000042   40EA         JC      ??zcl_SendReadReportCfgCmd_1
   1251          
   1252              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1253                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000044                ; Setup parameters for call to function zcl_SendCommand
   \   000044   78..         MOV     R0,#?V0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   78..         MOV     R0,#?V6
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   741C         MOV     A,#0x1c
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000059   E4           CLR     A
   \   00005A   F5..         MOV     ?V4,A
   \   00005C   F5..         MOV     ?V5,A
   \   00005E   78..         MOV     R0,#?V4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   741E         MOV     A,#0x1e
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006E   741E         MOV     A,#0x1e
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   000076   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000079   75..00       MOV     ?V3,#0x0
   \   00007C   78..         MOV     R0,#?V3
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000081   75..08       MOV     ?V3,#0x8
   \   000084   78..         MOV     R0,#?V3
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000089   EE           MOV     A,R6
   \   00008A   FC           MOV     R4,A
   \   00008B   EF           MOV     A,R7
   \   00008C   FD           MOV     R5,A
   \   00008D   AA..         MOV     R2,?V8
   \   00008F   AB..         MOV     R3,?V9
   \   000091   A9..         MOV     R1,?V2
   \   000093   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000096   740B         MOV     A,#0xb
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009B   E9           MOV     A,R1
   \   00009C   FE           MOV     R6,A
   1254              zcl_mem_free( buf );
   \   00009D                ; Setup parameters for call to function osal_mem_free
   \   00009D   AA..         MOV     R2,?V0
   \   00009F   AB..         MOV     R3,?V1
   \   0000A1   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000A4   8002         SJMP    ??zcl_SendReadReportCfgCmd_3
   1255            }
   1256            else
   1257            {
   1258              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   0000A6   7E10         MOV     R6,#0x10
   1259            }
   1260          
   1261            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   0000A8   02....       LJMP    ?Subroutine9 & 0xFFFF
   1262          }
   1263          
   1264          /*********************************************************************
   1265           * @fn      zcl_SendReadReportCfgRspCmd
   1266           *
   1267           * @brief   Send a Read Reporting Configuration Response command
   1268           *
   1269           * @param   dstAddr - destination address
   1270           * @param   clusterID - cluster ID
   1271           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1272           * @param   direction - direction of the command
   1273           * @param   seqNum - transaction sequence number
   1274           *
   1275           * @return  ZSuccess if OK
   1276           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1277          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1278                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1279                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1280          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V1,R1
   \   000007   8A..         MOV     ?V14,R2
   \   000009   8B..         MOV     ?V15,R3
   \   00000B   8C..         MOV     ?V12,R4
   \   00000D   8D..         MOV     ?V13,R5
   1281            uint8 *buf;
   1282            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1283            ZStatus_t status;
   1284            uint8 i;
   1285          
   1286            // Find out the data length
   1287            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V0,R6
   \   000015   7418         MOV     A,#0x18
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   00001D   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_0
   1288            {
   1289              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1290          
   1291              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1292          
   1293              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1294              {
   1295                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1296                {
   1297                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1298          
   1299                  // Find out the size of the Reportable Change field (for Analog data types)
   1300                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1301                  {
   1302                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1303                  }
   1304                }
   1305                else
   1306                {
   1307                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   00001F   EE           MOV     A,R6
   \   000020   2402         ADD     A,#0x2
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000022   FE           MOV     R6,A
   \   000023   E4           CLR     A
   \   000024   3F           ADDC    A,R7
   \   000025   FF           MOV     R7,A
   1308                }
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   000026   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   000028   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   00002B   504C         JNC     ??zcl_SendReadReportCfgRspCmd_4
   \   00002D   E5..         MOV     A,?V0
   \   00002F   75F00D       MOV     B,#0xd
   \   000032   A4           MUL     AB
   \   000033   F8           MOV     R0,A
   \   000034   A9F0         MOV     R1,B
   \   000036   E5..         MOV     A,?V8
   \   000038   28           ADD     A,R0
   \   000039   F582         MOV     DPL,A
   \   00003B   E5..         MOV     A,?V9
   \   00003D   12....       LCALL   ?Subroutine109 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   000040   2404         ADD     A,#0x4
   \   000042   FE           MOV     R6,A
   \   000043   E4           CLR     A
   \   000044   3F           ADDC    A,R7
   \   000045   FF           MOV     R7,A
   \   000046   E0           MOVX    A,@DPTR
   \   000047   70DD         JNZ     ??zcl_SendReadReportCfgRspCmd_3
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   70D2         JNZ     ??zcl_SendReadReportCfgRspCmd_1
   \   00004D   EE           MOV     A,R6
   \   00004E   2405         ADD     A,#0x5
   \   000050   FE           MOV     R6,A
   \   000051   E4           CLR     A
   \   000052   3F           ADDC    A,R7
   \   000053   FF           MOV     R7,A
   \   000054   E8           MOV     A,R0
   \   000055   2404         ADD     A,#0x4
   \   000057   F5..         MOV     ?V2,A
   \   000059   E4           CLR     A
   \   00005A   39           ADDC    A,R1
   \   00005B   F5..         MOV     ?V3,A
   \   00005D                ; Setup parameters for call to function zclAnalogDataType
   \   00005D   85..82       MOV     DPL,?V2
   \   000060   F583         MOV     DPH,A
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F9           MOV     R1,A
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60BC         JZ      ??zcl_SendReadReportCfgRspCmd_3
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   85..82       MOV     DPL,?V2
   \   00006D   85..83       MOV     DPH,?V3
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F9           MOV     R1,A
   \   000072   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000075   EE           MOV     A,R6
   \   000076   29           ADD     A,R1
   \   000077   80A9         SJMP    ??zcl_SendReadReportCfgRspCmd_2
   1309              }
   1310            }
   1311          
   1312            buf = zcl_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   000079                ; Setup parameters for call to function osal_mem_alloc
   \   000079   EE           MOV     A,R6
   \   00007A   FA           MOV     R2,A
   \   00007B   EF           MOV     A,R7
   \   00007C   FB           MOV     R3,A
   \   00007D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000080   8A..         MOV     ?V2,R2
   \   000082   8B..         MOV     ?V3,R3
   1313            if ( buf != NULL )
   \   000084   EA           MOV     A,R2
   \   000085   45..         ORL     A,?V3
   \   000087   7003         JNZ     $+5
   \   000089   02....       LJMP    ??zcl_SendReadReportCfgRspCmd_5 & 0xFFFF
   1314            {
   1315              // Load the buffer - serially
   1316              uint8 *pBuf = buf;
   \   00008C   8A..         MOV     ?V6,R2
   \   00008E   8B..         MOV     ?V7,R3
   1317          
   1318              for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000090   75..00       MOV     ?V0,#0x0
   \   000093   8009         SJMP    ??zcl_SendReadReportCfgRspCmd_6
   1319              {
   1320                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1321          
   1322                *pBuf++ = reportRspRec->status;
   1323                *pBuf++ = reportRspRec->direction;
   1324                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1325                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1326          
   1327                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1328                {
   1329                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1330                  {
   1331                    *pBuf++ = reportRspRec->dataType;
   1332                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1333                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1334                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1335                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1336          
   1337                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1338                    {
   1339                      pBuf = zclSerializeData( reportRspRec->dataType,
   1340                                               reportRspRec->reportableChange, pBuf );
   1341                    }
   1342                  }
   1343                  else
   1344                  {
   1345                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000095   E5..         MOV     A,?V4
   \   000097   2409         ADD     A,#0x9
   \   000099   12....       LCALL   ?Subroutine20 & 0xFFFF
   1346                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1347                  }
   \                     ??CrossCallReturnLabel_13:
   \   00009C   05..         INC     ?V0
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   00009E   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   0000A1   506C         JNC     ??zcl_SendReadReportCfgRspCmd_8
   \   0000A3   E5..         MOV     A,?V0
   \   0000A5   75F00D       MOV     B,#0xd
   \   0000A8   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   ?Subroutine118 & 0xFFFF
   \                     ??CrossCallReturnLabel_273:
   \   0000B2   E5..         MOV     A,?V4
   \   0000B4   2402         ADD     A,#0x2
   \   0000B6   F8           MOV     R0,A
   \   0000B7   E4           CLR     A
   \   0000B8   35..         ADDC    A,?V5
   \   0000BA   F9           MOV     R1,A
   \   0000BB   8882         MOV     DPL,R0
   \   0000BD   8983         MOV     DPH,R1
   \   0000BF   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000C2   85..82       MOV     DPL,?V4
   \   0000C5   85..83       MOV     DPH,?V5
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   70D1         JNZ     ??CrossCallReturnLabel_13
   \   0000CB   85..82       MOV     DPL,?V6
   \   0000CE   85..83       MOV     DPH,?V7
   \   0000D1   A3           INC     DPTR
   \   0000D2   A882         MOV     R0,DPL
   \   0000D4   A983         MOV     R1,DPH
   \   0000D6   8A82         MOV     DPL,R2
   \   0000D8   8B83         MOV     DPH,R3
   \   0000DA   E0           MOVX    A,@DPTR
   \   0000DB   70B8         JNZ     ??zcl_SendReadReportCfgRspCmd_7
   \   0000DD   E5..         MOV     A,?V4
   \   0000DF   2404         ADD     A,#0x4
   \   0000E1   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   0000E4   2405         ADD     A,#0x5
   \   0000E6   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000E9   2407         ADD     A,#0x7
   \   0000EB   12....       LCALL   ?Subroutine14 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000EE   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   0000F1   E9           MOV     A,R1
   \   0000F2   60A8         JZ      ??CrossCallReturnLabel_13
   \   0000F4                ; Setup parameters for call to function zclSerializeData
   \   0000F4   AC..         MOV     R4,?V6
   \   0000F6   AD..         MOV     R5,?V7
   \   0000F8   E5..         MOV     A,?V4
   \   0000FA   240B         ADD     A,#0xb
   \   0000FC   F582         MOV     DPL,A
   \   0000FE   E4           CLR     A
   \   0000FF   35..         ADDC    A,?V5
   \   000101   F583         MOV     DPH,A
   \   000103   12....       LCALL   ?Subroutine77 & 0xFFFF
   1348                }
   1349              }
   \                     ??CrossCallReturnLabel_124:
   \   000106   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000109   8A..         MOV     ?V6,R2
   \   00010B   8B..         MOV     ?V7,R3
   \   00010D   808D         SJMP    ??CrossCallReturnLabel_13
   1350          
   1351              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1352                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1353                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00010F                ; Setup parameters for call to function zcl_SendCommand
   \   00010F   78..         MOV     R0,#?V2
   \   000111   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000114   8E..         MOV     ?V4,R6
   \   000116   8F..         MOV     ?V5,R7
   \   000118   78..         MOV     R0,#?V4
   \   00011A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00011D   7420         MOV     A,#0x20
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000125   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000128   E4           CLR     A
   \   000129   F5..         MOV     ?V4,A
   \   00012B   F5..         MOV     ?V5,A
   \   00012D   78..         MOV     R0,#?V4
   \   00012F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000132   7422         MOV     A,#0x22
   \   000134   12....       LCALL   ?XSTACK_DISP0_8
   \   000137   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00013A   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00013D   7422         MOV     A,#0x22
   \   00013F   12....       LCALL   ?XSTACK_DISP0_8
   \   000142   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000148   75..00       MOV     ?V0,#0x0
   \   00014B   78..         MOV     R0,#?V0
   \   00014D   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000150   75..09       MOV     ?V0,#0x9
   \   000153   78..         MOV     R0,#?V0
   \   000155   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000158   AC..         MOV     R4,?V12
   \   00015A   AD..         MOV     R5,?V13
   \   00015C   AA..         MOV     R2,?V14
   \   00015E   AB..         MOV     R3,?V15
   \   000160   A9..         MOV     R1,?V1
   \   000162   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   000165   740B         MOV     A,#0xb
   \   000167   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016A   E9           MOV     A,R1
   \   00016B   FE           MOV     R6,A
   1354              zcl_mem_free( buf );
   \   00016C                ; Setup parameters for call to function osal_mem_free
   \   00016C   AA..         MOV     R2,?V2
   \   00016E   AB..         MOV     R3,?V3
   \   000170   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   000173   8002         SJMP    ??zcl_SendReadReportCfgRspCmd_9
   1355            }
   1356            else
   1357            {
   1358              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   000175   7E10         MOV     R6,#0x10
   1359            }
   1360          
   1361            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000177   02....       LJMP    ?Subroutine10 & 0xFFFF
   1362          }
   1363          
   1364          /*********************************************************************
   1365           * @fn      zcl_SendReportCmd
   1366           *
   1367           * @brief   Send a Report command
   1368           *
   1369           * @param   dstAddr - destination address
   1370           * @param   clusterID - cluster ID
   1371           * @param   reportCmd - report command to be sent
   1372           * @param   direction - direction of the command
   1373           * @param   seqNum - transaction sequence number
   1374           *
   1375           * @return  ZSuccess if OK
   1376           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1377          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1378                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1379                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1380          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V3,R1
   \   000007   8A..         MOV     ?V8,R2
   \   000009   8B..         MOV     ?V9,R3
   \   00000B   8C..         MOV     ?V6,R4
   \   00000D   8D..         MOV     ?V7,R5
   1381            uint16 dataLen = 0;
   \   00000F   7E00         MOV     R6,#0x0
   \   000011   7F00         MOV     R7,#0x0
   1382            uint8 *buf;
   1383            ZStatus_t status;
   1384            uint8 i;
   1385          
   1386            // calculate the size of the command
   1387            for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000013   8E..         MOV     ?V2,R6
   \   000015   7414         MOV     A,#0x14
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   00001D   800E         SJMP    ??CrossCallReturnLabel_188
   1388            {
   1389              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   00001F   E5..         MOV     A,?V2
   \   000021   75F005       MOV     B,#0x5
   \   000024   12....       LCALL   ?Subroutine76 & 0xFFFF
   1390          
   1391              dataLen += 2 + 1; // Attribute ID + data type
   1392          
   1393              // Attribute Data
   1394              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1395            }
   \                     ??CrossCallReturnLabel_122:
   \   000027   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002A   12....       LCALL   ?Subroutine110 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   00002D   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000030   40ED         JC      ??zcl_SendReportCmd_0
   1396          
   1397            buf = zcl_mem_alloc( dataLen );
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   EE           MOV     A,R6
   \   000033   FA           MOV     R2,A
   \   000034   EF           MOV     A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000039   8A..         MOV     ?V0,R2
   \   00003B   8B..         MOV     ?V1,R3
   1398            if ( buf != NULL )
   \   00003D   EA           MOV     A,R2
   \   00003E   45..         ORL     A,?V1
   \   000040   7003         JNZ     $+5
   \   000042   02....       LJMP    ??zcl_SendReportCmd_1 & 0xFFFF
   1399            {
   1400              // Load the buffer - serially
   1401              uint8 *pBuf = buf;
   \   000045   AC..         MOV     R4,?V0
   \   000047   AD..         MOV     R5,?V1
   1402          
   1403              for ( i = 0; i < reportCmd->numAttr; i++ )
   \   000049   75..00       MOV     ?V2,#0x0
   \   00004C   8015         SJMP    ??zcl_SendReportCmd_2
   1404              {
   1405                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_3:
   \   00004E   E5..         MOV     A,?V2
   \   000050   75F005       MOV     B,#0x5
   \   000053   12....       LCALL   ?Subroutine11 & 0xFFFF
   1406          
   1407                *pBuf++ = LO_UINT16( reportRec->attrID );
   1408                *pBuf++ = HI_UINT16( reportRec->attrID );
   1409                *pBuf++ = reportRec->dataType;
   1410          
   1411                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1412              }
   \                     ??CrossCallReturnLabel_1:
   \   000056   12....       LCALL   ??zclSerializeData?relay; Banked call to: zclSerializeData
   \   000059   8A..         MOV     ?V10,R2
   \   00005B   8B..         MOV     ?V11,R3
   \   00005D   AC..         MOV     R4,?V10
   \   00005F   AD..         MOV     R5,?V11
   \   000061   05..         INC     ?V2
   \                     ??zcl_SendReportCmd_2:
   \   000063   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000066   40E6         JC      ??zcl_SendReportCmd_3
   1413          
   1414              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1415                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000068                ; Setup parameters for call to function zcl_SendCommand
   \   000068   78..         MOV     R0,#?V0
   \   00006A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006D   8E..         MOV     ?V4,R6
   \   00006F   8F..         MOV     ?V5,R7
   \   000071   78..         MOV     R0,#?V4
   \   000073   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000076   741C         MOV     A,#0x1c
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_300:
   \   00007E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000081   E4           CLR     A
   \   000082   F5..         MOV     ?V4,A
   \   000084   F5..         MOV     ?V5,A
   \   000086   78..         MOV     R0,#?V4
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   741E         MOV     A,#0x1e
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_301:
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000096   741E         MOV     A,#0x1e
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_302:
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A1   75..00       MOV     ?V2,#0x0
   \   0000A4   78..         MOV     R0,#?V2
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000A9   75..0A       MOV     ?V2,#0xa
   \   0000AC   78..         MOV     R0,#?V2
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000B1   AC..         MOV     R4,?V6
   \   0000B3   AD..         MOV     R5,?V7
   \   0000B5   AA..         MOV     R2,?V8
   \   0000B7   AB..         MOV     R3,?V9
   \   0000B9   A9..         MOV     R1,?V3
   \   0000BB   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   0000BE   740B         MOV     A,#0xb
   \   0000C0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C3   E9           MOV     A,R1
   \   0000C4   FE           MOV     R6,A
   1416              zcl_mem_free( buf );
   \   0000C5                ; Setup parameters for call to function osal_mem_free
   \   0000C5   AA..         MOV     R2,?V0
   \   0000C7   AB..         MOV     R3,?V1
   \   0000C9   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   \   0000CC   8002         SJMP    ??zcl_SendReportCmd_4
   1417            }
   1418            else
   1419            {
   1420              status = ZMemError;
   \                     ??zcl_SendReportCmd_1:
   \   0000CE   7E10         MOV     R6,#0x10
   1421            }
   1422          
   1423            return ( status );
   \                     ??zcl_SendReportCmd_4:
   \   0000D0   02....       LJMP    ?Subroutine9 & 0xFFFF
   1424          }
   1425          #endif // ZCL_REPORT
   1426          
   1427          /*********************************************************************
   1428           * @fn      zcl_SendDefaultRspCmd
   1429           *
   1430           * @brief   Send a Default Response command
   1431           *
   1432           *          Note: The manufacturer code field should be set if this
   1433           *          command is being sent in response to a manufacturer specific
   1434           *          command.
   1435           *
   1436           * @param   dstAddr - destination address
   1437           * @param   clusterID - cluster ID
   1438           * @param   defaultRspCmd - default response command to be sent
   1439           * @param   direction - direction of the command
   1440           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1441           * @param   seqNum - transaction sequence number
   1442           *
   1443           * @return  ZSuccess if OK
   1444           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1445          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1446                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1447                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1448          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   \   00000C   740C         MOV     A,#0xc
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   12....       LCALL   ?Subroutine93 & 0xFFFF
   1449            uint8 buf[2]; // Command ID and Status;
   1450          
   1451            // Load the buffer - serially
   1452            buf[0] = defaultRspCmd->commandID;
   \                     ??CrossCallReturnLabel_155:
   \   000014   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   000017   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   1453            buf[1] = defaultRspCmd->statusCode;
   \                     ??CrossCallReturnLabel_475:
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   C0E0         PUSH    A
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   D0E0         POP     A
   \   000025   F0           MOVX    @DPTR,A
   1454          
   1455            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1456                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   000026                ; Setup parameters for call to function zcl_SendCommand
   \   000026   A8..         MOV     R0,?XSP + 0
   \   000028   A9..         MOV     R1,?XSP + 1
   \   00002A   88..         MOV     ?V0,R0
   \   00002C   89..         MOV     ?V1,R1
   \   00002E   78..         MOV     R0,#?V0
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   75..02       MOV     ?V0,#0x2
   \   000036   75..00       MOV     ?V1,#0x0
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   7416         MOV     A,#0x16
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000049   7415         MOV     A,#0x15
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000051   7416         MOV     A,#0x16
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00005C   7416         MOV     A,#0x16
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000067   75..00       MOV     ?V0,#0x0
   \   00006A   78..         MOV     R0,#?V0
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00006F   75..0B       MOV     ?V0,#0xb
   \   000072   78..         MOV     R0,#?V0
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000077   EE           MOV     A,R6
   \   000078   F9           MOV     R1,A
   \   000079   12....       LCALL   ??zcl_SendCommand?relay; Banked call to: zcl_SendCommand
   \   00007C   740B         MOV     A,#0xb
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000081   7402         MOV     A,#0x2
   \   000083   12....       LCALL   ?DEALLOC_XSTACK8
   \   000086   02....       LJMP    ?Subroutine2 & 0xFFFF
   1457          }
   1458          
   1459          #ifdef ZCL_DISCOVER
   1460          /*********************************************************************
   1461           * @fn      zcl_SendDiscoverCmdsCmd
   1462           *
   1463           * @brief   Send a Discover Commands command
   1464           *
   1465           * @param   dstAddr - destination address
   1466           * @param   clusterID - cluster ID
   1467           * @param   cmdType - requesting command ID
   1468           * @param   pDiscoverCmd - discover command to be sent
   1469           * @param   direction - direction of the command
   1470           * @param   seqNum - transaction sequence number
   1471           *
   1472           * @return  ZSuccess if OK
   1473           */
   1474          ZStatus_t zcl_SendDiscoverCmdsCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   1475                                            uint8 cmdType, zclDiscoverCmdsCmd_t *pDiscoverCmd,
   1476                                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1477          {
   1478            uint8 payload[2]; // size of startCmdID and maxCmdID
   1479            ZStatus_t status;
   1480          
   1481            payload[0] = pDiscoverCmd->startCmdID;
   1482            payload[1] = pDiscoverCmd->maxCmdID;
   1483          
   1484            // Send message for either commands received or generated
   1485            if ( cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1486            {
   1487              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED, FALSE,
   1488                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1489            }
   1490            else  // generated
   1491            {
   1492              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN, FALSE,
   1493                                          direction, disableDefaultRsp, 0, seqNum, sizeof(payload), payload );
   1494            }
   1495          
   1496            return ( status );
   1497          }
   1498          
   1499          /*********************************************************************
   1500           * @fn      zcl_SendDiscoverCmdsRspCmd
   1501           *
   1502           * @brief   Send a Discover Commands Response command
   1503           *
   1504           * @param   dstAddr - destination address
   1505           * @param   clusterID - cluster ID
   1506           * @param   pDiscoverRspCmd - response command to be sent
   1507           * @param   direction - direction of the command
   1508           * @param   seqNum - transaction sequence number
   1509           *
   1510           * @return  ZSuccess if OK
   1511           */
   1512          ZStatus_t zcl_SendDiscoverCmdsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1513                                                uint16 clusterID, zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd,
   1514                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1515          {
   1516            uint8 payloadSize = ( 1 + pDiscoverRspCmd->numCmd );  // size of discovery complete field plus cmds
   1517            uint8 *pCmdBuf;
   1518            uint8 i;
   1519            ZStatus_t status = ZSuccess;
   1520          
   1521            // allocate memory
   1522            pCmdBuf = zcl_mem_alloc( payloadSize );
   1523            if ( pCmdBuf != NULL )
   1524            {
   1525              uint8 *pBuf = pCmdBuf;
   1526          
   1527              // Load the buffer - serially
   1528              *pBuf++ = pDiscoverRspCmd->discComplete;
   1529              for ( i = 0; i < pDiscoverRspCmd->numCmd; i++ )
   1530              {
   1531                *pBuf++ = pDiscoverRspCmd->pCmdID[i];
   1532              }
   1533          
   1534              // Send response message for either commands received or generated
   1535              if( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   1536              {
   1537                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_RECEIVED_RSP, FALSE,
   1538                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1539              }
   1540              else if ( pDiscoverRspCmd->cmdType == ZCL_CMD_DISCOVER_CMDS_GEN )
   1541              {
   1542                status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_CMDS_GEN_RSP, FALSE,
   1543                                          direction, disableDefaultRsp, 0, seqNum, payloadSize, pCmdBuf );
   1544              }
   1545          
   1546              zcl_mem_free( pCmdBuf );
   1547            }
   1548            else
   1549            {
   1550              status = ZMemError;
   1551            }
   1552          
   1553            return ( status );
   1554          }
   1555          
   1556          /*********************************************************************
   1557           * @fn      zcl_SendDiscoverAttrsCmd
   1558           *
   1559           * @brief   Send a Discover Attributes command
   1560           *
   1561           * @param   dstAddr - destination address
   1562           * @param   clusterID - cluster ID
   1563           * @param   pDiscoverCmd - discover command to be sent
   1564           * @param   direction - direction of the command
   1565           * @param   seqNum - transaction sequence number
   1566           *
   1567           * @return  ZSuccess if OK
   1568           */
   1569          ZStatus_t zcl_SendDiscoverAttrsCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1570                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverCmd,
   1571                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1572          {
   1573            uint8 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1574            uint8 *buf;
   1575            ZStatus_t status;
   1576          
   1577            buf = zcl_mem_alloc( dataLen );
   1578            if ( buf != NULL )
   1579            {
   1580              // Load the buffer - serially
   1581              uint8 *pBuf = buf;
   1582              *pBuf++ = LO_UINT16(pDiscoverCmd->startAttr);
   1583              *pBuf++ = HI_UINT16(pDiscoverCmd->startAttr);
   1584              *pBuf++ = pDiscoverCmd->maxAttrIDs;
   1585          
   1586              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS, FALSE,
   1587                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1588              zcl_mem_free( buf );
   1589            }
   1590            else
   1591            {
   1592              status = ZMemError;
   1593            }
   1594          
   1595            return ( status );
   1596          }
   1597          
   1598          /*********************************************************************
   1599           * @fn      zcl_SendDiscoverAttrsRspCmd
   1600           *
   1601           * @brief   Send a Discover Attributes Response command
   1602           *
   1603           * @param   dstAddr - destination address
   1604           * @param   clusterID - cluster ID
   1605           * @param   reportRspCmd - report response command to be sent
   1606           * @param   direction - direction of the command
   1607           * @param   seqNum - transaction sequence number
   1608           *
   1609           * @return  ZSuccess if OK
   1610           */
   1611          ZStatus_t zcl_SendDiscoverAttrsRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1612                                    uint16 clusterID, zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd,
   1613                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1614          {
   1615            uint16 dataLen = 1; // Discovery complete
   1616            uint8 *buf;
   1617            ZStatus_t status;
   1618          
   1619            // calculate the size of the command
   1620            dataLen += pDiscoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1621          
   1622            buf = zcl_mem_alloc( dataLen );
   1623            if ( buf != NULL )
   1624            {
   1625              // Load the buffer - serially
   1626              uint8 i;
   1627              uint8 *pBuf = buf;
   1628          
   1629              *pBuf++ = pDiscoverRspCmd->discComplete;
   1630          
   1631              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1632              {
   1633                *pBuf++ = LO_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1634                *pBuf++ = HI_UINT16(pDiscoverRspCmd->attrList[i].attrID);
   1635                *pBuf++ = pDiscoverRspCmd->attrList[i].dataType;
   1636              }
   1637          
   1638              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_RSP, FALSE,
   1639                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1640              zcl_mem_free( buf );
   1641            }
   1642            else
   1643            {
   1644              status = ZMemError;
   1645            }
   1646          
   1647            return ( status );
   1648          }
   1649          
   1650          /*********************************************************************
   1651           * @fn      zcl_SendDiscoverAttrsExt
   1652           *
   1653           * @brief   Send a Discover Attributes Extended command
   1654           *
   1655           * @param   dstAddr - destination address
   1656           * @param   clusterID - cluster ID
   1657           * @param   pDiscoverAttrsExt:
   1658           *            - startAttrID: the first attribute to be selected
   1659           *            - maxAttrIDs: maximum number of returned attributes
   1660           * @param   direction - direction of the command
   1661           * @param   seqNum - transaction sequence number
   1662           *
   1663           * @return  ZSuccess if OK
   1664           */
   1665          ZStatus_t zcl_SendDiscoverAttrsExt( uint8 srcEP, afAddrType_t *dstAddr,
   1666                                      uint16 clusterID, zclDiscoverAttrsCmd_t *pDiscoverAttrsExt,
   1667                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1668          {
   1669            uint8 buf[3];  // Buffer size equal to Start Attribute ID and Max Attribute IDs
   1670            ZStatus_t status;
   1671          
   1672            // Load the buffer - serially
   1673            buf[0] = LO_UINT16(pDiscoverAttrsExt->startAttr);
   1674            buf[1] = HI_UINT16(pDiscoverAttrsExt->startAttr);
   1675            buf[2] = pDiscoverAttrsExt->maxAttrIDs;
   1676          
   1677            status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT, FALSE,
   1678                                      direction, disableDefaultRsp, 0, seqNum, sizeof( buf ), buf );
   1679          
   1680            return ( status );
   1681          }
   1682          
   1683          /*********************************************************************
   1684           * @fn      zcl_SendDiscoverAttrsExtRsp
   1685           *
   1686           * @brief   Send a Discover Attributes Extended Response command
   1687           *
   1688           * @param   dstAddr - destination address
   1689           * @param   clusterID - cluster ID
   1690           * @param   pDiscoverRspCmd:
   1691           *            - discComplete: indicates whether all requested attributes returned
   1692           *            - attrID: attribute ID
   1693           *            - attrDataType: data type of the given attribute
   1694           *            - attrAccessControl: access control of the given attribute
   1695           * @param   direction - direction of the command
   1696           * @param   seqNum - transaction sequence number
   1697           *
   1698           * @return  ZSuccess if OK
   1699           */
   1700          ZStatus_t zcl_SendDiscoverAttrsExtRsp( uint8 srcEP, afAddrType_t *dstAddr,
   1701                                                uint16 clusterID, zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd,
   1702                                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1703          {
   1704            uint8 *buf;
   1705            uint8 i;
   1706            uint16 dataLen = 1; // Discovery complete
   1707            ZStatus_t status;
   1708          
   1709            // calculate the size of the command
   1710            dataLen += pDiscoverRspCmd->numAttr * (2 + 1 + 1); // Attribute ID, Data Type, and Access Control
   1711          
   1712            buf = zcl_mem_alloc( dataLen );
   1713            if ( buf != NULL )
   1714            {
   1715              // Load the buffer - serially
   1716              uint8 *pBuf = buf;
   1717              *pBuf++ = pDiscoverRspCmd->discComplete;
   1718              for ( i = 0; i < pDiscoverRspCmd->numAttr; i++ )
   1719              {
   1720                *pBuf++ = LO_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1721                *pBuf++ = HI_UINT16(pDiscoverRspCmd->aExtAttrInfo[i].attrID);
   1722                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrDataType;
   1723                *pBuf++ = pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl;
   1724              }
   1725          
   1726              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_ATTRS_EXT_RSP, FALSE,
   1727                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1728              zcl_mem_free( buf );
   1729            }
   1730            else
   1731            {
   1732              status = ZMemError;
   1733            }
   1734          
   1735            return ( status );
   1736          }
   1737          #endif // ZCL_DISCOVER
   1738          
   1739          /*********************************************************************
   1740           * @fn      zcl_ProcessMessageMSG
   1741           *
   1742           * @brief   Data message processor callback.  This function processes
   1743           *          any incoming data - probably from other devices.  So, based
   1744           *          on cluster ID, perform the intended action.
   1745           *
   1746           * @param   pkt - incoming message
   1747           *
   1748           * @return  zclProcMsgStatus_t
   1749           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1750          zclProcMsgStatus_t zcl_ProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zcl_ProcessMessageMSG:
   1751          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1752            endPointDesc_t *epDesc;
   1753            zclIncoming_t inMsg;
   1754            zclLibPlugin_t *pInPlugin;
   1755            zclDefaultRspCmd_t defautlRspCmd;
   1756            uint8 options;
   1757            uint8 securityEnable;
   1758            uint8 interPanMsg;
   1759            ZStatus_t status = ZFailure;
   1760            uint8 defaultResponseSent = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   1761          
   1762            if ( pkt->cmd.DataLength == 0 )
   \   000011   EE           MOV     A,R6
   \   000012   2420         ADD     A,#0x20
   \   000014   F5..         MOV     ?V4,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   F5..         MOV     ?V5,A
   \   00001A   85..82       MOV     DPL,?V4
   \   00001D   F583         MOV     DPH,A
   \   00001F   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000022   7005         JNZ     ??zcl_ProcessMessageMSG_0
   1763            {
   1764              return ( ZCL_PROC_INVALID );   // Error, ignore the message
   \   000024   7901         MOV     R1,#0x1
   \   000026   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1765            }
   1766          
   1767            // Initialize
   1768            rawAFMsg = (afIncomingMSGPacket_t *)pkt;
   \                     ??zcl_ProcessMessageMSG_0:
   \   000029   90....       MOV     DPTR,#rawAFMsg
   \   00002C   EE           MOV     A,R6
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   EF           MOV     A,R7
   \   000030   F0           MOVX    @DPTR,A
   1769            inMsg.msg = pkt;
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   EE           MOV     A,R6
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   EF           MOV     A,R7
   \   00003A   F0           MOVX    @DPTR,A
   1770            inMsg.attrCmd = NULL;
   \   00003B   740E         MOV     A,#0xe
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   E4           CLR     A
   \   000041   F0           MOVX    @DPTR,A
   \   000042   A3           INC     DPTR
   \   000043   F0           MOVX    @DPTR,A
   1771            inMsg.pData = NULL;
   \   000044   740A         MOV     A,#0xa
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E4           CLR     A
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   F0           MOVX    @DPTR,A
   1772            inMsg.pDataLen = 0;
   \   00004D   740C         MOV     A,#0xc
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   E4           CLR     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   A3           INC     DPTR
   \   000055   F0           MOVX    @DPTR,A
   1773          
   1774            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   000056   EE           MOV     A,R6
   \   000057   2422         ADD     A,#0x22
   \   000059   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   00005C   12....       LCALL   ??Subroutine169_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   00005F   7404         MOV     A,#0x4
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   AA82         MOV     R2,DPL
   \   000066   AB83         MOV     R3,DPH
   \   000068   12....       LCALL   ??zclParseHdr?relay  ; Banked call to: zclParseHdr
   \   00006B   8A..         MOV     ?V6,R2
   \   00006D   8B..         MOV     ?V7,R3
   \   00006F   A8..         MOV     R0,?V6
   \   000071   A9..         MOV     R1,?V7
   \   000073   740A         MOV     A,#0xa
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   1775            inMsg.pDataLen = pkt->cmd.DataLength;
   1776            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \                     ??CrossCallReturnLabel_309:
   \   00007B   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_458:
   \   00007E   EA           MOV     A,R2
   \   00007F   C3           CLR     C
   \   000080   98           SUBB    A,R0
   \   000081   F8           MOV     R0,A
   \   000082   EB           MOV     A,R3
   \   000083   99           SUBB    A,R1
   \   000084   F9           MOV     R1,A
   \   000085   85..82       MOV     DPL,?V0
   \   000088   85..83       MOV     DPH,?V1
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   28           ADD     A,R0
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   39           ADDC    A,R1
   \   000091   F9           MOV     R1,A
   \   000092   740C         MOV     A,#0xc
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   1777          
   1778            // Temporary workaround to allow callback functions access to the 
   1779            // transaction sequence number.  Callback functions will call 
   1780            // zcl_getParsedTransSeqNum() to retrieve this number.
   1781            savedZCLTransSeqNum = inMsg.hdr.transSeqNum;
   \                     ??CrossCallReturnLabel_310:
   \   00009A   7408         MOV     A,#0x8
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   90....       MOV     DPTR,#savedZCLTransSeqNum
   \   0000A3   F0           MOVX    @DPTR,A
   1782            
   1783            // Find the wanted endpoint
   1784            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   0000A4   EE           MOV     A,R6
   \   0000A5   2414         ADD     A,#0x14
   \   0000A7   12....       LCALL   ?Subroutine106 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F9           MOV     R1,A
   \   0000AC   12....       LCALL   ??afFindEndPointDesc?relay; Banked call to: afFindEndPointDesc
   \   0000AF   8A82         MOV     DPL,R2
   \   0000B1   8B83         MOV     DPH,R3
   1785            if ( epDesc == NULL )
   \   0000B3   E582         MOV     A,DPL
   \   0000B5   4583         ORL     A,DPH
   \   0000B7   700C         JNZ     ??zcl_ProcessMessageMSG_2
   1786            {
   1787              rawAFMsg = NULL;
   \   0000B9   90....       MOV     DPTR,#rawAFMsg
   \   0000BC   E4           CLR     A
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   A3           INC     DPTR
   \   0000BF   F0           MOVX    @DPTR,A
   1788              return ( ZCL_PROC_EP_NOT_FOUND );   // Error, ignore the message
   \   0000C0   7902         MOV     R1,#0x2
   \   0000C2   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1789            }
   1790          
   1791            if ( ( epDesc->simpleDesc == NULL ) ||
   1792                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1793                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \                     ??zcl_ProcessMessageMSG_2:
   \   0000C5   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   0000C8   602B         JZ      ??zcl_ProcessMessageMSG_3
   \   0000CA   EE           MOV     A,R6
   \   0000CB   2404         ADD     A,#0x4
   \   0000CD   F5..         MOV     ?V4,A
   \   0000CF   E4           CLR     A
   \   0000D0   3F           ADDC    A,R7
   \   0000D1   F5..         MOV     ?V5,A
   \   0000D3                ; Setup parameters for call to function zcl_DeviceOperational
   \   0000D3   A3           INC     DPTR
   \   0000D4   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0000D7   740B         MOV     A,#0xb
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FD           MOV     R5,A
   \   0000DE   7406         MOV     A,#0x6
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   5403         ANL     A,#0x3
   \   0000E6   FC           MOV     R4,A
   \   0000E7   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   0000EA   12....       LCALL   ??zcl_DeviceOperational?relay; Banked call to: zcl_DeviceOperational
   \   0000ED   7402         MOV     A,#0x2
   \   0000EF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F2   E9           MOV     A,R1
   \   0000F3   700C         JNZ     ??zcl_ProcessMessageMSG_4
   1794            {
   1795              rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_3:
   \   0000F5   90....       MOV     DPTR,#rawAFMsg
   \   0000F8   E4           CLR     A
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   A3           INC     DPTR
   \   0000FB   F0           MOVX    @DPTR,A
   1796              return ( ZCL_PROC_NOT_OPERATIONAL ); // Error, ignore the message
   \   0000FC   7903         MOV     R1,#0x3
   \   0000FE   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1797            }
   1798          
   1799          #if defined ( INTER_PAN )
   1800            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1801            {
   1802              // No foundation command is supported thru Inter-PAN communication.
   1803              // But the Light Link cluster uses a different Frame Control format
   1804              // for it's Inter-PAN messages, where the messages could be confused
   1805              // with the foundation commands.
   1806              if ( zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1807              {
   1808                rawAFMsg = NULL;
   1809                return ( ZCL_PROC_INTERPAN_FOUNDATION_CMD );
   1810              }
   1811          
   1812              interPanMsg = TRUE;
   1813              options = AF_TX_OPTIONS_NONE;
   1814            }
   1815            else
   1816          #endif
   1817            {
   1818              interPanMsg = FALSE;
   1819              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \                     ??zcl_ProcessMessageMSG_4:
   \   000101                ; Setup parameters for call to function zclGetClusterOption
   \   000101   12....       LCALL   ?Subroutine57 & 0xFFFF
   1820            }
   \                     ??CrossCallReturnLabel_75:
   \   000104   12....       LCALL   ??zclGetClusterOption?relay; Banked call to: zclGetClusterOption
   \   000107   E9           MOV     A,R1
   \   000108   F5..         MOV     ?V3,A
   1821          
   1822            // Find the appropriate plugin
   1823            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   00010A   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_459:
   \   00010D   EA           MOV     A,R2
   \   00010E   FC           MOV     R4,A
   \   00010F   EB           MOV     A,R3
   \   000110   FD           MOV     R5,A
   \   000111   90....       MOV     DPTR,#plugins
   \   000114   8004         SJMP    ??zcl_ProcessMessageMSG_5
   \                     ??zcl_ProcessMessageMSG_6:
   \   000116   8882         MOV     DPL,R0
   \   000118   8983         MOV     DPH,R1
   \                     ??zcl_ProcessMessageMSG_5:
   \   00011A   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_338:
   \   00011D   7003         JNZ     $+5
   \   00011F   02....       LJMP    ??zcl_ProcessMessageMSG_7 & 0xFFFF
   \   000122   8882         MOV     DPL,R0
   \   000124   8983         MOV     DPH,R1
   \   000126   A3           INC     DPTR
   \   000127   A3           INC     DPTR
   \   000128   E0           MOVX    A,@DPTR
   \   000129   F5..         MOV     ?V6,A
   \   00012B   A3           INC     DPTR
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   F5..         MOV     ?V7,A
   \   00012F   C3           CLR     C
   \   000130   EC           MOV     A,R4
   \   000131   95..         SUBB    A,?V6
   \   000133   ED           MOV     A,R5
   \   000134   95..         SUBB    A,?V7
   \   000136   40DE         JC      ??zcl_ProcessMessageMSG_6
   \   000138   8882         MOV     DPL,R0
   \   00013A   8983         MOV     DPH,R1
   \   00013C   A3           INC     DPTR
   \   00013D   A3           INC     DPTR
   \   00013E   A3           INC     DPTR
   \   00013F   A3           INC     DPTR
   \   000140   C3           CLR     C
   \   000141   E0           MOVX    A,@DPTR
   \   000142   9C           SUBB    A,R4
   \   000143   A3           INC     DPTR
   \   000144   E0           MOVX    A,@DPTR
   \   000145   9D           SUBB    A,R5
   \   000146   40CE         JC      ??zcl_ProcessMessageMSG_6
   \   000148   E8           MOV     A,R0
   \   000149   FC           MOV     R4,A
   \   00014A   E9           MOV     A,R1
   \   00014B   FD           MOV     R5,A
   \   00014C   7404         MOV     A,#0x4
   \   00014E   12....       LCALL   ?XSTACK_DISP0_8
   \   000151   E0           MOVX    A,@DPTR
   \   000152   5407         ANL     A,#0x7
   \   000154   700D         JNZ     ??zcl_ProcessMessageMSG_8
   \   000156   7409         MOV     A,#0x9
   \   000158   12....       LCALL   ?XSTACK_DISP0_8
   \   00015B   E0           MOVX    A,@DPTR
   \   00015C   640B         XRL     A,#0xb
   \   00015E   7003         JNZ     $+5
   \   000160   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1824          
   1825            // Local and remote Security options must match except for Default Response command
   1826            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1827            {
   1828              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zcl_ProcessMessageMSG_8:
   \   000163   E5..         MOV     A,?V3
   \   000165   A2E6         MOV     C,0xE0 /* A   */.6
   \   000167   4003         JC      $+5
   \   000169   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   \   00016C   EE           MOV     A,R6
   \   00016D   2419         ADD     A,#0x19
   \   00016F   F582         MOV     DPL,A
   \   000171   E4           CLR     A
   \   000172   3F           ADDC    A,R7
   \   000173   F583         MOV     DPH,A
   \   000175   E0           MOVX    A,@DPTR
   \   000176   6003         JZ      $+5
   \   000178   02....       LJMP    ??zcl_ProcessMessageMSG_9 & 0xFFFF
   1829          
   1830              // Make sure that Clusters specifically defined to use security are received secure,
   1831              // any other cluster that wants to use APS security will be allowed
   1832              if ( ( securityEnable == TRUE ) && ( pkt->SecurityUse == FALSE ) )
   1833              {
   1834                if ( UNICAST_MSG( inMsg.msg ) )
   \   00017B   7402         MOV     A,#0x2
   \   00017D   12....       LCALL   ?XSTACK_DISP0_8
   \   000180   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   000183   707D         JNZ     ??zcl_ProcessMessageMSG_10
   \   000185   7402         MOV     A,#0x2
   \   000187   12....       LCALL   ?XSTACK_DISP0_8
   \   00018A   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_342:
   \   00018D   7073         JNZ     ??zcl_ProcessMessageMSG_10
   1835                {
   1836                  // Send a Default Response command back with no Application Link Key security
   1837                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   00018F                ; Setup parameters for call to function zclSetSecurityOption
   \   00018F   7C00         MOV     R4,#0x0
   \   000191   85..82       MOV     DPL,?V0
   \   000194   85..83       MOV     DPH,?V1
   \   000197   E0           MOVX    A,@DPTR
   \   000198   F9           MOV     R1,A
   \   000199   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1838          
   1839                  defautlRspCmd.statusCode = status;
   \   00019C   7401         MOV     A,#0x1
   \   00019E   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A1   7401         MOV     A,#0x1
   \   0001A3   F0           MOVX    @DPTR,A
   1840                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0001A4   7409         MOV     A,#0x9
   \   0001A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A9   12....       LCALL   ?Subroutine91 & 0xFFFF
   1841                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1842                                         inMsg.msg->clusterId, &defautlRspCmd,
   1843                                         !inMsg.hdr.fc.direction, true,
   1844                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_149:
   \   0001AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001AF   12....       LCALL   ??Subroutine171_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_303:
   \   0001B2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001B5   7407         MOV     A,#0x7
   \   0001B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BA   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0001BD   75..01       MOV     ?V2,#0x1
   \   0001C0   78..         MOV     R0,#?V2
   \   0001C2   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001C5   7408         MOV     A,#0x8
   \   0001C7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CA   12....       LCALL   ??Subroutine200_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_468:
   \   0001CD   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0001D0   7405         MOV     A,#0x5
   \   0001D2   12....       LCALL   ?XSTACK_DISP100_8
   \   0001D5   88..         MOV     ?V2,R0
   \   0001D7   89..         MOV     ?V3,R1
   \   0001D9   78..         MOV     R0,#?V2
   \   0001DB   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0001DE   7409         MOV     A,#0x9
   \   0001E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E3   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0001E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E9   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   0001EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0001EF   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   0001F2   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   0001F5   7407         MOV     A,#0x7
   \   0001F7   12....       LCALL   ?DEALLOC_XSTACK8
   1845          
   1846                  zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   0001FA                ; Setup parameters for call to function zclSetSecurityOption
   \   0001FA   7C01         MOV     R4,#0x1
   \   0001FC   12....       LCALL   ?Subroutine57 & 0xFFFF
   1847                }
   \                     ??CrossCallReturnLabel_76:
   \   0001FF   12....       LCALL   ??zclSetSecurityOption?relay; Banked call to: zclSetSecurityOption
   1848          
   1849                rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_10:
   \   000202   90....       MOV     DPTR,#rawAFMsg
   \   000205   E4           CLR     A
   \   000206   F0           MOVX    @DPTR,A
   \   000207   A3           INC     DPTR
   \   000208   F0           MOVX    @DPTR,A
   1850                return ( ZCL_PROC_NOT_SECURE );   // Error, ignore the message
   \   000209   7905         MOV     R1,#0x5
   \   00020B   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1851              }
   1852            }
   \                     ??zcl_ProcessMessageMSG_7:
   \   00020E   7C00         MOV     R4,#0x0
   \   000210   7D00         MOV     R5,#0x0
   1853          
   1854            // Is this a foundation type message
   1855            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zcl_ProcessMessageMSG_9:
   \   000212   7404         MOV     A,#0x4
   \   000214   12....       LCALL   ?XSTACK_DISP0_8
   \   000217   E0           MOVX    A,@DPTR
   \   000218   F8           MOV     R0,A
   \   000219   5403         ANL     A,#0x3
   \   00021B   6003         JZ      $+5
   \   00021D   02....       LJMP    ??zcl_ProcessMessageMSG_11 & 0xFFFF
   1856            {
   1857              if ( inMsg.hdr.fc.manuSpecific )
   \   000220   E8           MOV     A,R0
   \   000221   5404         ANL     A,#0x4
   \   000223   6005         JZ      ??zcl_ProcessMessageMSG_12
   1858              {
   1859                // We don't support any manufacturer specific command
   1860                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000225   7E84         MOV     R6,#-0x7c
   \   000227   02....       LJMP    ??zcl_ProcessMessageMSG_13 & 0xFFFF
   1861              }
   1862              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1863                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zcl_ProcessMessageMSG_12:
   \   00022A   7409         MOV     A,#0x9
   \   00022C   12....       LCALL   ?XSTACK_DISP0_8
   \   00022F   E0           MOVX    A,@DPTR
   \   000230   F5..         MOV     ?V4,A
   \   000232   C3           CLR     C
   \   000233   9417         SUBB    A,#0x17
   \   000235   4003         JC      $+5
   \   000237   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   \   00023A   75..00       MOV     ?V5,#0x0
   \   00023D   7402         MOV     A,#0x2
   \   00023F   78..         MOV     R0,#?V4
   \   000241   12....       LCALL   ?S_SHL
   \   000244   74..         MOV     A,#zclCmdTable & 0xff
   \   000246   25..         ADD     A,?V4
   \   000248   F582         MOV     DPL,A
   \   00024A   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   00024C   35..         ADDC    A,?V5
   \   00024E   F583         MOV     DPH,A
   \   000250   E4           CLR     A
   \   000251   93           MOVC    A,@A+DPTR
   \   000252   F8           MOV     R0,A
   \   000253   7401         MOV     A,#0x1
   \   000255   93           MOVC    A,@A+DPTR
   \   000256   F9           MOV     R1,A
   \   000257   E8           MOV     A,R0
   \   000258   49           ORL     A,R1
   \   000259   7003         JNZ     $+5
   \   00025B   02....       LJMP    ??zcl_ProcessMessageMSG_14 & 0xFFFF
   1864              {
   1865                zclParseCmd_t parseCmd;
   1866          
   1867                parseCmd.endpoint = pkt->endPoint;
   \   00025E   85..82       MOV     DPL,?V0
   \   000261   85..83       MOV     DPH,?V1
   \   000264   E0           MOVX    A,@DPTR
   \   000265   C0E0         PUSH    A
   \   000267   7410         MOV     A,#0x10
   \   000269   12....       LCALL   ?XSTACK_DISP0_8
   \   00026C   D0E0         POP     A
   \   00026E   F0           MOVX    @DPTR,A
   1868                parseCmd.dataLen = inMsg.pDataLen;
   \   00026F   740C         MOV     A,#0xc
   \   000271   12....       LCALL   ?XSTACK_DISP0_8
   \   000274   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000277   12....       LCALL   ?XSTACK_DISP0_8
   \   00027A   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   1869                parseCmd.pData = inMsg.pData;
   \                     ??CrossCallReturnLabel_311:
   \   00027D   740A         MOV     A,#0xa
   \   00027F   12....       LCALL   ?XSTACK_DISP0_8
   \   000282   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_356:
   \   000285   7413         MOV     A,#0x13
   \   000287   12....       LCALL   ?XSTACK_DISP0_8
   \   00028A   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   1870          
   1871                // Parse the command, remember that the return value is a pointer to allocated memory
   1872                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \                     ??CrossCallReturnLabel_312:
   \   00028D                ; Setup parameters for indirect call
   \   00028D   7410         MOV     A,#0x10
   \   00028F   12....       LCALL   ?XSTACK_DISP101_8
   \   000292   7409         MOV     A,#0x9
   \   000294   12....       LCALL   ?XSTACK_DISP0_8
   \   000297   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00029A   12....       LCALL   ?S_SHL
   \   00029D   74..         MOV     A,#zclCmdTable & 0xff
   \   00029F   25..         ADD     A,?V0
   \   0002A1   F582         MOV     DPL,A
   \   0002A3   74..         MOV     A,#(zclCmdTable >> 8) & 0xff
   \   0002A5   35..         ADDC    A,?V1
   \   0002A7   F583         MOV     DPH,A
   \   0002A9   E4           CLR     A
   \   0002AA   93           MOVC    A,@A+DPTR
   \   0002AB   C0E0         PUSH    A
   \   0002AD   7401         MOV     A,#0x1
   \   0002AF   93           MOVC    A,@A+DPTR
   \   0002B0   F583         MOV     DPH,A
   \   0002B2   D082         POP     DPL
   \   0002B4   12....       LCALL   ?CALL_IND
   \   0002B7   8A..         MOV     ?V0,R2
   \   0002B9   8B..         MOV     ?V1,R3
   \   0002BB   A8..         MOV     R0,?V0
   \   0002BD   A9..         MOV     R1,?V1
   \   0002BF   740E         MOV     A,#0xe
   \   0002C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002C4   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   1873                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \                     ??CrossCallReturnLabel_313:
   \   0002C7   E8           MOV     A,R0
   \   0002C8   49           ORL     A,R1
   \   0002C9   6045         JZ      ??zcl_ProcessMessageMSG_15
   \   0002CB   7409         MOV     A,#0x9
   \   0002CD   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D0   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   0002D3   12....       LCALL   ?S_SHL
   \   0002D6   74..         MOV     A,#(zclCmdTable + 2) & 0xff
   \   0002D8   25..         ADD     A,?V0
   \   0002DA   F582         MOV     DPL,A
   \   0002DC   74..         MOV     A,#((zclCmdTable + 2) >> 8) & 0xff
   \   0002DE   35..         ADDC    A,?V1
   \   0002E0   F583         MOV     DPH,A
   \   0002E2   E4           CLR     A
   \   0002E3   93           MOVC    A,@A+DPTR
   \   0002E4   F8           MOV     R0,A
   \   0002E5   7401         MOV     A,#0x1
   \   0002E7   93           MOVC    A,@A+DPTR
   \   0002E8   F9           MOV     R1,A
   \   0002E9   8882         MOV     DPL,R0
   \   0002EB   8983         MOV     DPH,R1
   \   0002ED   E582         MOV     A,DPL
   \   0002EF   4583         ORL     A,DPH
   \   0002F1   6012         JZ      ??zcl_ProcessMessageMSG_16
   1874                {
   1875                  // Process the command
   1876                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0002F3                ; Setup parameters for indirect call
   \   0002F3   7402         MOV     A,#0x2
   \   0002F5   12....       LCALL   ?XSTACK_DISP101_8
   \   0002F8   12....       LCALL   ?CALL_IND
   1877                  {
   1878                    // Couldn't find attribute in the table.
   1879                  }
   1880                }
   1881          
   1882                // Free the buffer
   1883                if ( inMsg.attrCmd )
   \   0002FB   740E         MOV     A,#0xe
   \   0002FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000300   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_339:
   \   000303   600B         JZ      ??zcl_ProcessMessageMSG_15
   1884                {
   1885                  zcl_mem_free( inMsg.attrCmd );
   \                     ??zcl_ProcessMessageMSG_16:
   \   000305                ; Setup parameters for call to function osal_mem_free
   \   000305   740E         MOV     A,#0xe
   \   000307   12....       LCALL   ?XSTACK_DISP0_8
   \   00030A   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   1886                }
   \                     ??CrossCallReturnLabel_448:
   \   00030D   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   1887          
   1888                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zcl_ProcessMessageMSG_15:
   \   000310   7409         MOV     A,#0x9
   \   000312   12....       LCALL   ?XSTACK_DISP0_8
   \   000315   E0           MOVX    A,@DPTR
   \   000316   F8           MOV     R0,A
   \   000317   6054         JZ      ??zcl_ProcessMessageMSG_17
   \   000319   7402         MOV     A,#0x2
   \   00031B   68           XRL     A,R0
   \   00031C   604F         JZ      ??zcl_ProcessMessageMSG_17
   \   00031E   7403         MOV     A,#0x3
   \   000320   68           XRL     A,R0
   \   000321   604A         JZ      ??zcl_ProcessMessageMSG_17
   \   000323   7406         MOV     A,#0x6
   \   000325   68           XRL     A,R0
   \   000326   6045         JZ      ??zcl_ProcessMessageMSG_17
   \   000328   7408         MOV     A,#0x8
   \   00032A   68           XRL     A,R0
   \   00032B   6040         JZ      ??zcl_ProcessMessageMSG_17
   \   00032D   740C         MOV     A,#0xc
   \   00032F   68           XRL     A,R0
   \   000330   603B         JZ      ??zcl_ProcessMessageMSG_17
   \   000332   7411         MOV     A,#0x11
   \   000334   68           XRL     A,R0
   \   000335   6036         JZ      ??zcl_ProcessMessageMSG_17
   \   000337   7413         MOV     A,#0x13
   \   000339   68           XRL     A,R0
   \   00033A   6031         JZ      ??zcl_ProcessMessageMSG_17
   \   00033C   7415         MOV     A,#0x15
   \   00033E   68           XRL     A,R0
   \   00033F   602C         JZ      ??zcl_ProcessMessageMSG_17
   \   000341   740B         MOV     A,#0xb
   \   000343   68           XRL     A,R0
   \   000344   6027         JZ      ??zcl_ProcessMessageMSG_17
   1889                {
   1890                  rawAFMsg = NULL;
   1891                  return ( ZCL_PROC_SUCCESS ); // We're done
   1892                }
   1893          
   1894                status = ZSuccess;
   \   000346   7E00         MOV     R6,#0x0
   \   000348   8043         SJMP    ??zcl_ProcessMessageMSG_13
   1895              }
   1896              else
   1897              {
   1898                // Unsupported message
   1899                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zcl_ProcessMessageMSG_14:
   \   00034A   7E82         MOV     R6,#-0x7e
   \   00034C   803F         SJMP    ??zcl_ProcessMessageMSG_13
   1900              }
   1901            }
   1902            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1903            {
   1904              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zcl_ProcessMessageMSG_11:
   \   00034E   EC           MOV     A,R4
   \   00034F   4D           ORL     A,R5
   \   000350   602B         JZ      ??zcl_ProcessMessageMSG_18
   \   000352   8C82         MOV     DPL,R4
   \   000354   8D83         MOV     DPH,R5
   \   000356   A3           INC     DPTR
   \   000357   A3           INC     DPTR
   \   000358   A3           INC     DPTR
   \   000359   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   00035C   601F         JZ      ??zcl_ProcessMessageMSG_18
   1905              {
   1906                // The return value of the plugin function will be
   1907                //  ZSuccess - Supported and need default response
   1908                //  ZFailure - Unsupported
   1909                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1910                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1911                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1912                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1913                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   00035E                ; Setup parameters for indirect call
   \   00035E   7402         MOV     A,#0x2
   \   000360   12....       LCALL   ?XSTACK_DISP101_8
   \   000363   12....       LCALL   ?CALL_IND
   \   000366   E9           MOV     A,R1
   \   000367   FE           MOV     R6,A
   1914                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000368   74FF         MOV     A,#-0x1
   \   00036A   6E           XRL     A,R6
   \   00036B   700B         JNZ     ??zcl_ProcessMessageMSG_19
   1915                {
   1916                  rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_17:
   \   00036D   90....       MOV     DPTR,#rawAFMsg
   \   000370   E4           CLR     A
   \   000371   F0           MOVX    @DPTR,A
   \   000372   A3           INC     DPTR
   \   000373   F0           MOVX    @DPTR,A
   1917                  return ( ZCL_PROC_SUCCESS ); // We're done
   \   000374   F9           MOV     R1,A
   \   000375   02....       LJMP    ??zcl_ProcessMessageMSG_1 & 0xFFFF
   1918                }
   1919              }
   1920          
   1921              if ( status == ZFailure )
   \                     ??zcl_ProcessMessageMSG_19:
   \   000378   7401         MOV     A,#0x1
   \   00037A   6E           XRL     A,R6
   \   00037B   7010         JNZ     ??zcl_ProcessMessageMSG_13
   1922              {
   1923                // Unsupported message
   1924                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zcl_ProcessMessageMSG_18:
   \   00037D   7404         MOV     A,#0x4
   \   00037F   12....       LCALL   ?XSTACK_DISP0_8
   \   000382   E0           MOVX    A,@DPTR
   \   000383   5404         ANL     A,#0x4
   \   000385   6004         JZ      ??zcl_ProcessMessageMSG_20
   1925                {
   1926                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   \   000387   7E83         MOV     R6,#-0x7d
   \   000389   8002         SJMP    ??zcl_ProcessMessageMSG_13
   1927                }
   1928                else
   1929                {
   1930                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   \                     ??zcl_ProcessMessageMSG_20:
   \   00038B   7E81         MOV     R6,#-0x7f
   1931                }
   1932              }
   1933            }
   1934          
   1935            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zcl_ProcessMessageMSG_13:
   \   00038D   7402         MOV     A,#0x2
   \   00038F   12....       LCALL   ?XSTACK_DISP0_8
   \   000392   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000395   7074         JNZ     ??zcl_ProcessMessageMSG_21
   \   000397   7402         MOV     A,#0x2
   \   000399   12....       LCALL   ?XSTACK_DISP0_8
   \   00039C   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_343:
   \   00039F   706A         JNZ     ??zcl_ProcessMessageMSG_21
   \   0003A1   7404         MOV     A,#0x4
   \   0003A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A6   E0           MOVX    A,@DPTR
   \   0003A7   5410         ANL     A,#0x10
   \   0003A9   7060         JNZ     ??zcl_ProcessMessageMSG_21
   1936            {
   1937              // Send a Default Response command back
   1938              defautlRspCmd.statusCode = status;
   \   0003AB   7401         MOV     A,#0x1
   \   0003AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B0   EE           MOV     A,R6
   \   0003B1   F0           MOVX    @DPTR,A
   1939              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0003B2   7409         MOV     A,#0x9
   \   0003B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B7   12....       LCALL   ?Subroutine91 & 0xFFFF
   1940              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1941                                     inMsg.msg->clusterId, &defautlRspCmd,
   1942                                     !inMsg.hdr.fc.direction, true,
   1943                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_150:
   \   0003BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003BD   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0003C0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C3   7407         MOV     A,#0x7
   \   0003C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C8   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   0003CB   75..01       MOV     ?V0,#0x1
   \   0003CE   78..         MOV     R0,#?V0
   \   0003D0   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003D3   7408         MOV     A,#0x8
   \   0003D5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D8   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   0003DB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003DE   7405         MOV     A,#0x5
   \   0003E0   12....       LCALL   ?XSTACK_DISP100_8
   \   0003E3   88..         MOV     ?V0,R0
   \   0003E5   89..         MOV     ?V1,R1
   \   0003E7   78..         MOV     R0,#?V0
   \   0003E9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003EC   7409         MOV     A,#0x9
   \   0003EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F1   12....       LCALL   ?Subroutine60 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0003F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F7   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   0003FA   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FD   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000400   12....       LCALL   ??zcl_SendDefaultRspCmd?relay; Banked call to: zcl_SendDefaultRspCmd
   \   000403   7407         MOV     A,#0x7
   \   000405   12....       LCALL   ?DEALLOC_XSTACK8
   1944              defaultResponseSent = TRUE;
   \   000408   75..01       MOV     ?V2,#0x1
   1945            }
   1946          
   1947            rawAFMsg = NULL;
   \                     ??zcl_ProcessMessageMSG_21:
   \   00040B   90....       MOV     DPTR,#rawAFMsg
   \   00040E   E4           CLR     A
   \   00040F   F0           MOVX    @DPTR,A
   \   000410   A3           INC     DPTR
   \   000411   F0           MOVX    @DPTR,A
   1948            if ( status == ZSuccess )
   \   000412   EE           MOV     A,R6
   \   000413   7004         JNZ     ??zcl_ProcessMessageMSG_22
   1949            {
   1950              return ( ZCL_PROC_SUCCESS );
   \   000415   7900         MOV     R1,#0x0
   \   000417   801F         SJMP    ??zcl_ProcessMessageMSG_1
   1951            }
   1952            else if ( status == ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND )
   \                     ??zcl_ProcessMessageMSG_22:
   \   000419   7484         MOV     A,#-0x7c
   \   00041B   6E           XRL     A,R6
   \   00041C   700E         JNZ     ??zcl_ProcessMessageMSG_23
   1953            {
   1954              if ( defaultResponseSent )
   \   00041E   E5..         MOV     A,?V2
   \   000420   A2E0         MOV     C,0xE0 /* A   */.0
   \   000422   5004         JNC     ??zcl_ProcessMessageMSG_24
   1955              {
   1956                return ( ZCL_PROC_MANUFACTURER_SPECIFIC_DR );
   \   000424   7907         MOV     R1,#0x7
   \   000426   8010         SJMP    ??zcl_ProcessMessageMSG_1
   1957              }
   1958              else
   1959              {
   1960                return ( ZCL_PROC_MANUFACTURER_SPECIFIC );
   \                     ??zcl_ProcessMessageMSG_24:
   \   000428   7906         MOV     R1,#0x6
   \   00042A   800C         SJMP    ??zcl_ProcessMessageMSG_1
   1961              }
   1962            }
   1963            else
   1964            {
   1965              if ( defaultResponseSent )
   \                     ??zcl_ProcessMessageMSG_23:
   \   00042C   E5..         MOV     A,?V2
   \   00042E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000430   5004         JNC     ??zcl_ProcessMessageMSG_25
   1966              {
   1967                return ( ZCL_PROC_NOT_HANDLED_DR );
   \   000432   7909         MOV     R1,#0x9
   \   000434   8002         SJMP    ??zcl_ProcessMessageMSG_1
   1968              }
   1969              else
   1970              {
   1971                return ( ZCL_PROC_NOT_HANDLED );
   \                     ??zcl_ProcessMessageMSG_25:
   \   000436   7908         MOV     R1,#0x8
   \                     ??zcl_ProcessMessageMSG_1:
   \   000438   7415         MOV     A,#0x15
   \   00043A   12....       LCALL   ?DEALLOC_XSTACK8
   1972              }
   1973            }
   \   00043D                REQUIRE ?Subroutine6
   \   00043D                ; // Fall through to label ?Subroutine6
   1974          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7F08         MOV     R7,#0x8
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine106:
   \   000000   F5..         MOV     ?V0,A
   \   000002   E4           CLR     A
   \   000003   3F           ADDC    A,R7
   \   000004   F5..         MOV     ?V1,A
   \   000006                ; Setup parameters for call to function zclParseHdr
   \   000006                ; Setup parameters for call to function afFindEndPointDesc
   \   000006   85..82       MOV     DPL,?V0
   \   000009   F583         MOV     DPH,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   F0           MOVX    @DPTR,A
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008                ; Setup parameters for call to function zcl_SendDefaultRspCmd
   \   000008   7408         MOV     A,#0x8
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   7409         MOV     A,#0x9
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   12....       LCALL   ?Subroutine132 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000003   F9           MOV     R1,A
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_392:
   \   000003   C8           XCH     A,R0
   \   000004   2415         ADD     A,#0x15
   \   000006   F582         MOV     DPL,A
   \   000008   E4           CLR     A
   \   000009   38           ADDC    A,R0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_349:
   \   000006   FD           MOV     R5,A
   \   000007   7409         MOV     A,#0x9
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_461:
   \   000009   85..82       MOV     DPL,?V0
   \   00000C   85..83       MOV     DPH,?V1
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine170_0
   \   000003                ; // Fall through to label ??Subroutine170_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine170_0:
   \   000000   12....       LCALL   ?Subroutine137 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000003   E582         MOV     A,DPL
   \   000005   4583         ORL     A,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003                REQUIRE ??Subroutine177_0
   \   000003                ; // Fall through to label ??Subroutine177_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine127:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_393:
   \   000003   F583         MOV     DPH,A
   \   000005   8882         MOV     DPL,R0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine139:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ??Subroutine179_0
   \   000004                ; // Fall through to label ??Subroutine179_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine183_0:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_383:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   85..82       MOV     DPL,?V4
   \   000003   85..83       MOV     DPH,?V5
   \   000006                REQUIRE ??Subroutine198_0
   \   000006                ; // Fall through to label ??Subroutine198_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_471:
   \   000003   F5..         MOV     ?V0,A
   \   000005   78..         MOV     R0,#?V0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine200_0:
   \   000000   12....       LCALL   ?Subroutine136 & 0xFFFF
   \                     ??CrossCallReturnLabel_472:
   \   000003   F5..         MOV     ?V2,A
   \   000005   78..         MOV     R0,#?V2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine136:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   6401         XRL     A,#0x1
   \   000008   5401         ANL     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_386:
   \   000003                ; Setup parameters for indirect call
   \   000003   7411         MOV     A,#0x11
   \   000005   22           RET
   1975          
   1976          /*********************************************************************
   1977           * PRIVATE FUNCTIONS
   1978           *********************************************************************/
   1979          
   1980          /*********************************************************************
   1981           * @fn      zclParseHdr
   1982           *
   1983           * @brief   Parse header of the ZCL format
   1984           *
   1985           * @param   hdr - place to put the frame control information
   1986           * @param   pData - incoming buffer to parse
   1987           *
   1988           * @return  pointer past the header
   1989           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1990          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1991          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0,R2
   \   000007   8B..         MOV     ?V1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1992            // Clear the header
   1993            zcl_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   00000D                ; Setup parameters for call to function osal_memset
   \   00000D   7C06         MOV     R4,#0x6
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   1994          
   1995            // Parse the Frame Control
   1996            hdr->fc.type = zcl_FCType( *pData );
   \   000016   85..82       MOV     DPL,?V0
   \   000019   85..83       MOV     DPH,?V1
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   54FC         ANL     A,#0xfc
   \   00001F   F8           MOV     R0,A
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   8E82         MOV     DPL,R6
   \   000025   8F83         MOV     DPH,R7
   \   000027   E0           MOVX    A,@DPTR
   \   000028   5403         ANL     A,#0x3
   \   00002A   FA           MOV     R2,A
   \   00002B   E8           MOV     A,R0
   \   00002C   4A           ORL     A,R2
   \   00002D   F8           MOV     R0,A
   \   00002E   12....       LCALL   ?Subroutine38 & 0xFFFF
   1997            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_43:
   \   000031   A2E2         MOV     C,0xE0 /* A   */.2
   \   000033   5004         JNC     ??zclParseHdr_0
   \   000035   D2F0         SETB    B.0
   \   000037   8002         SJMP    ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000039   C2F0         CLR     B.0
   \                     ??zclParseHdr_1:
   \   00003B   E8           MOV     A,R0
   \   00003C   54FB         ANL     A,#0xfb
   \   00003E   FA           MOV     R2,A
   \   00003F   A2F0         MOV     C,B.0
   \   000041   E4           CLR     A
   \   000042   33           RLC     A
   \   000043   F5..         MOV     ?V2,A
   \   000045   75..00       MOV     ?V3,#0x0
   \   000048   7402         MOV     A,#0x2
   \   00004A   78..         MOV     R0,#?V2
   \   00004C   12....       LCALL   ?S_SHL
   \   00004F   EA           MOV     A,R2
   \   000050   45..         ORL     A,?V2
   \   000052   12....       LCALL   ?Subroutine38 & 0xFFFF
   1998            if ( zcl_FCDirection( *pData ) )
   \                     ??CrossCallReturnLabel_44:
   \   000055   A2E3         MOV     C,0xE0 /* A   */.3
   \   000057   85..82       MOV     DPL,?V0
   \   00005A   85..83       MOV     DPH,?V1
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   5004         JNC     ??zclParseHdr_2
   1999            {
   2000              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   000060   4408         ORL     A,#0x8
   \   000062   8002         SJMP    ??zclParseHdr_3
   2001            }
   2002            else
   2003            {
   2004              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000064   54F7         ANL     A,#0xf7
   2005            }
   \                     ??zclParseHdr_3:
   \   000066   12....       LCALL   ?Subroutine122 & 0xFFFF
   2006          
   2007            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??CrossCallReturnLabel_327:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006C   5004         JNC     ??zclParseHdr_4
   \   00006E   D2F0         SETB    B.0
   \   000070   8002         SJMP    ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   000072   C2F0         CLR     B.0
   \                     ??zclParseHdr_5:
   \   000074   85..82       MOV     DPL,?V0
   \   000077   85..83       MOV     DPH,?V1
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   54EF         ANL     A,#0xef
   \   00007D   FA           MOV     R2,A
   \   00007E   A2F0         MOV     C,B.0
   \   000080   E4           CLR     A
   \   000081   33           RLC     A
   \   000082   F5..         MOV     ?V2,A
   \   000084   7404         MOV     A,#0x4
   \   000086   78..         MOV     R0,#?V2
   \   000088   12....       LCALL   ?S_SHL
   \   00008B   EA           MOV     A,R2
   \   00008C   45..         ORL     A,?V2
   \   00008E   F8           MOV     R0,A
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   E9           MOV     A,R1
   \   000092   12....       LCALL   ?Subroutine34 & 0xFFFF
   2008            pData++;  // move past the frame control field
   2009          
   2010            // parse the manfacturer code
   2011            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_37:
   \   000095   E8           MOV     A,R0
   \   000096   5404         ANL     A,#0x4
   \   000098   600A         JZ      ??zclParseHdr_6
   2012            {
   2013              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   12....       LCALL   ?Subroutine82 & 0xFFFF
   2014              pData += 2;
   2015            }
   \                     ??CrossCallReturnLabel_129:
   \   00009E   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_425:
   \   0000A1   5001         JNC     ??zclParseHdr_6
   \   0000A3   0F           INC     R7
   2016          
   2017            // parse the Transaction Sequence Number
   2018            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   85..82       MOV     DPL,?V0
   \   0000AC   85..83       MOV     DPH,?V1
   \   0000AF   A3           INC     DPTR
   \   0000B0   A3           INC     DPTR
   \   0000B1   A3           INC     DPTR
   \   0000B2   12....       LCALL   ??Subroutine191_0 & 0xFFFF
   2019          
   2020            // parse the Cluster's command ID
   2021            hdr->commandID = *pData++;
   \                     ??CrossCallReturnLabel_406:
   \   0000B5   85..82       MOV     DPL,?V0
   \   0000B8   85..83       MOV     DPH,?V1
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   12....       LCALL   ?Subroutine36 & 0xFFFF
   2022          
   2023            // Should point to the frame payload
   2024            return ( pData );
   \                     ??CrossCallReturnLabel_325:
   \   0000C0   AA82         MOV     R2,DPL
   \   0000C2   AB83         MOV     R3,DPH
   \   0000C4                REQUIRE ?Subroutine1
   \   0000C4                ; // Fall through to label ?Subroutine1
   2025          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006   F0           MOVX    @DPTR,A
   \   000007   A3           INC     DPTR
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine175_0
   \   000003                ; // Fall through to label ??Subroutine175_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_409:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine117:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   AE82         MOV     R6,DPL
   \   000008   AF83         MOV     R7,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine191_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine192_0
   \   000001                ; // Fall through to label ??Subroutine192_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine192_0:
   \   000000   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_411:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine134:
   \   000000   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine149:
   \   000000   FA           MOV     R2,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   EA           MOV     A,R2
   \   000005   85..82       MOV     DPL,?V0
   \   000008   85..83       MOV     DPH,?V1
   \   00000B   A3           INC     DPTR
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine195_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET
   2026          
   2027          /*********************************************************************
   2028           * @fn      zclBuildHdr
   2029           *
   2030           * @brief   Build header of the ZCL format
   2031           *
   2032           * @param   hdr - outgoing header information
   2033           * @param   pData - outgoing header space
   2034           *
   2035           * @return  pointer past the header
   2036           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2037          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   2038          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   2039            // Build the Frame Control byte
   2040            *pData = hdr->fc.type;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   5403         ANL     A,#0x3
   \   00000C   8C82         MOV     DPL,R4
   \   00000E   8D83         MOV     DPH,R5
   \   000010   12....       LCALL   ??Subroutine176_0 & 0xFFFF
   2041            *pData |= hdr->fc.manuSpecific << 2;
   \                     ??CrossCallReturnLabel_333:
   \   000013   5404         ANL     A,#0x4
   \   000015   12....       LCALL   ?Subroutine42 & 0xFFFF
   2042            *pData |= hdr->fc.direction << 3;
   \                     ??CrossCallReturnLabel_331:
   \   000018   5408         ANL     A,#0x8
   \   00001A   12....       LCALL   ?Subroutine42 & 0xFFFF
   2043            *pData |= hdr->fc.disableDefaultRsp << 4;
   \                     ??CrossCallReturnLabel_332:
   \   00001D   5410         ANL     A,#0x10
   \   00001F   F8           MOV     R0,A
   \   000020   8C82         MOV     DPL,R4
   \   000022   8D83         MOV     DPH,R5
   \   000024   E0           MOVX    A,@DPTR
   \   000025   48           ORL     A,R0
   \   000026   12....       LCALL   ?Subroutine120 & 0xFFFF
   2044            pData++;  // move past the frame control field
   2045          
   2046            // Add the manfacturer code
   2047            if ( hdr->fc.manuSpecific )
   \                     ??CrossCallReturnLabel_198:
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   5404         ANL     A,#0x4
   \   00002C   6007         JZ      ??CrossCallReturnLabel_95
   2048            {
   2049              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002E   12....       LCALL   ?Subroutine40 & 0xFFFF
   2050              *pData++ = HI_UINT16( hdr->manuCode );
   2051            }
   \                     ??CrossCallReturnLabel_46:
   \   000031   A3           INC     DPTR
   \   000032   12....       LCALL   ?Subroutine64 & 0xFFFF
   2052          
   2053            // Add the Transaction Sequence Number
   2054            *pData++ = hdr->transSeqNum;
   \                     ??CrossCallReturnLabel_95:
   \   000035   8A82         MOV     DPL,R2
   \   000037   8B83         MOV     DPH,R3
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   12....       LCALL   ?Subroutine31 & 0xFFFF
   2055          
   2056            // Add the Cluster's command ID
   2057            *pData++ = hdr->commandID;
   \                     ??CrossCallReturnLabel_34:
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   12....       LCALL   ?Subroutine154 & 0xFFFF
   2058          
   2059            // Should point to the frame payload
   2060            return ( pData );
   \                     ??CrossCallReturnLabel_240:
   \   000047   AA82         MOV     R2,DPL
   \   000049   AB83         MOV     R3,DPH
   \   00004B                REQUIRE ?Subroutine7
   \   00004B                ; // Fall through to label ?Subroutine7
   2061          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   F8           MOV     R0,A
   \   000001   8C82         MOV     DPL,R4
   \   000003   8D83         MOV     DPH,R5
   \   000005   E0           MOVX    A,@DPTR
   \   000006   48           ORL     A,R0
   \   000007                REQUIRE ??Subroutine176_0
   \   000007                ; // Fall through to label ??Subroutine176_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine176_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   E0           MOVX    A,@DPTR
   \   000006   22           RET
   2062          
   2063          /*********************************************************************
   2064           * @fn      zclCalcHdrSize
   2065           *
   2066           * @brief   Calculate the number of bytes needed for an outgoing
   2067           *          ZCL header.
   2068           *
   2069           * @param   hdr - outgoing header information
   2070           *
   2071           * @return  returns the number of bytes needed
   2072           */
   2073          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   2074          {
   2075            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   2076          
   2077            // Add the manfacturer code
   2078            if ( hdr->fc.manuSpecific )
   2079            {
   2080              needed += 2;
   2081            }
   2082          
   2083            return ( needed );
   2084          }
   2085          
   2086          /*********************************************************************
   2087           * @fn      zclFindPlugin
   2088           *
   2089           * @brief   Find the right plugin for a cluster ID
   2090           *
   2091           * @param   clusterID - cluster ID to look for
   2092           * @param   profileID - profile ID
   2093           *
   2094           * @return  pointer to plugin, NULL if not found
   2095           */
   2096          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   2097          {
   2098            zclLibPlugin_t *pLoop = plugins;
   2099          
   2100            (void)profileID;  // Intentionally unreferenced parameter
   2101          
   2102            while ( pLoop != NULL )
   2103            {
   2104              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   2105              {
   2106                return ( pLoop );
   2107              }
   2108          
   2109              pLoop = pLoop->next;
   2110            }
   2111          
   2112            return ( (zclLibPlugin_t *)NULL );
   2113          }
   2114          
   2115          #ifdef ZCL_DISCOVER
   2116          /*********************************************************************
   2117           * @fn      zclFindCmdRecsList
   2118           *
   2119           * @brief   Find the right command record list for an endpoint
   2120           *
   2121           * @param   endpoint - endpoint to look for
   2122           *
   2123           * @return  pointer to record list, NULL if not found
   2124           */
   2125          static zclCmdRecsList_t *zclFindCmdRecsList( uint8 endpoint )
   2126          {
   2127            zclCmdRecsList_t *pLoop = gpCmdList;
   2128          
   2129            while ( pLoop != NULL )
   2130            {
   2131              if ( pLoop->endpoint == endpoint )
   2132              {
   2133                return ( pLoop );
   2134              }
   2135          
   2136              pLoop = pLoop->pNext;
   2137            }
   2138          
   2139            return ( NULL );
   2140          }
   2141          
   2142          /*********************************************************************
   2143           * @fn      zclFindCmdRec
   2144           *
   2145           * @brief   Find the command record that matchs the parameters
   2146           *
   2147           * @param   endpoint - Application's endpoint
   2148           * @param   clusterID - cluster ID
   2149           * @param   attrId - attribute looking for
   2150           * @param   pAttr - attribute record to be returned
   2151           *
   2152           * @return  TRUE if record found. FALSE, otherwise.
   2153           */
   2154          uint8 zclFindCmdRec( uint8 endpoint, uint16 clusterID, uint8 cmdID, zclCommandRec_t *pCmd )
   2155          {
   2156            uint8 i;
   2157            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2158          
   2159            if ( pRec != NULL )
   2160            {
   2161              for ( i = 0; i < pRec->numCommands; i++ )
   2162              {
   2163                if ( pRec->pCmdRecs[i].clusterID == clusterID && pRec->pCmdRecs[i].cmdID == cmdID )
   2164                {
   2165                  *pCmd = pRec->pCmdRecs[i];
   2166          
   2167                  return ( TRUE ); // EMBEDDED RETURN
   2168                }
   2169              }
   2170            }
   2171          
   2172            return ( FALSE );
   2173          }
   2174          #endif // ZCL_DISCOVER
   2175          
   2176          
   2177          /*********************************************************************
   2178           * @fn      zclFindAttrRec
   2179           *
   2180           * @brief   Find the attribute record that matchs the parameters
   2181           *
   2182           * @param   endpoint - Application's endpoint
   2183           * @param   clusterID - cluster ID
   2184           * @param   attrId - attribute looking for
   2185           * @param   pAttr - attribute record to be returned
   2186           *
   2187           * @return  TRUE if record found. FALSE, otherwise.
   2188           */
   2189          /*
   2190          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   2191          {
   2192          	zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2193          
   2194          	if ( pRec != NULL ) {
   2195          		zclAttrRec_t const __code  * iter =  pRec->attrs;
   2196          		while(iter->clusterID != ACHDJIAN_LAST_CLUSTER){
   2197          			if ( iter->clusterID == clusterID && iter->attr.attrId == attrId )  {
   2198          				*pAttr = *iter;
   2199          				return ( TRUE ); 
   2200          			}
   2201          			iter++;
   2202          		}
   2203          	}
   2204          	return ( FALSE );
   2205          }
   2206          
   2207          */
   2208          
   2209          /*********************************************************************
   2210           * @fn      zclFindClusterOption
   2211           *
   2212           * @brief   Find the option record that matchs the cluster id
   2213           *
   2214           * @param   endpoint - Application's endpoint
   2215           * @param   clusterID - cluster ID looking for
   2216           *
   2217           * @return  pointer to clutser option, NULL if not found
   2218           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2219          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   2220          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   EA           MOV     A,R2
   \   000008   FC           MOV     R4,A
   \   000009   EB           MOV     A,R3
   \   00000A   FD           MOV     R5,A
   2221            zclClusterOptionList *pLoop;
   2222          
   2223            pLoop = clusterOptionList;
   \   00000B   90....       MOV     DPTR,#clusterOptionList
   \   00000E   8004         SJMP    ??zclFindClusterOption_0
   2224            while ( pLoop != NULL )
   2225            {
   2226              if ( pLoop->endpoint == endpoint )
   2227              {
   2228                uint8 x;
   2229                for ( x = 0; x < pLoop->numOptions; x++ )
   2230                {
   2231                  if ( pLoop->options[x].clusterID == clusterID )
   2232                  {
   2233                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   2234                  }
   2235                }
   2236              }
   2237          
   2238              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_1:
   \   000010   8882         MOV     DPL,R0
   \   000012   8983         MOV     DPH,R1
   \                     ??zclFindClusterOption_0:
   \   000014   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   000017   6047         JZ      ??zclFindClusterOption_2
   \   000019   8882         MOV     DPL,R0
   \   00001B   8983         MOV     DPH,R1
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6E           XRL     A,R6
   \   000021   70ED         JNZ     ??zclFindClusterOption_1
   \   000023   75..00       MOV     ?V0,#0x0
   \   000026   8002         SJMP    ??zclFindClusterOption_3
   \                     ??zclFindClusterOption_4:
   \   000028   05..         INC     ?V0
   \                     ??zclFindClusterOption_3:
   \   00002A   8882         MOV     DPL,R0
   \   00002C   8983         MOV     DPH,R1
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   E5..         MOV     A,?V0
   \   000035   C3           CLR     C
   \   000036   9A           SUBB    A,R2
   \   000037   50D7         JNC     ??zclFindClusterOption_1
   \   000039   E5..         MOV     A,?V0
   \   00003B   75F003       MOV     B,#0x3
   \   00003E   A4           MUL     AB
   \   00003F   FA           MOV     R2,A
   \   000040   ABF0         MOV     R3,B
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   2A           ADD     A,R2
   \   00004C   FA           MOV     R2,A
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   3B           ADDC    A,R3
   \   000050   FB           MOV     R3,A
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E0           MOVX    A,@DPTR
   \   000056   6C           XRL     A,R4
   \   000057   7003         JNZ     ??zclFindClusterOption_5
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6D           XRL     A,R5
   \                     ??zclFindClusterOption_5:
   \   00005C   70CA         JNZ     ??zclFindClusterOption_4
   \   00005E   8004         SJMP    ??zclFindClusterOption_6
   2239            }
   2240          
   2241            return ( NULL );
   \                     ??zclFindClusterOption_2:
   \   000060   7A00         MOV     R2,#0x0
   \   000062   7B00         MOV     R3,#0x0
   \                     ??zclFindClusterOption_6:
   \   000064   02....       LJMP    ?Subroutine7 & 0xFFFF
   2242          }
   2243          
   2244          /*********************************************************************
   2245           * @fn      zclGetClusterOption
   2246           *
   2247           * @brief   Get the option record that matchs the cluster id
   2248           *
   2249           * @param   endpoint - Application's endpoint
   2250           * @param   clusterID - cluster ID looking for
   2251           *
   2252           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   2253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2254          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2255          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2256            uint8 option;
   2257            zclOptionRec_t *pOption;
   2258          
   2259            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000005                ; Setup parameters for call to function zclFindClusterOption
   \   000005   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   2260            if ( pOption != NULL )
   \   00000C   E582         MOV     A,DPL
   \   00000E   4583         ORL     A,DPH
   \   000010   6008         JZ      ??zclGetClusterOption_0
   2261            {
   2262              option = pOption->option;
   2263              if ( !ZG_SECURE_ENABLED )
   2264              {
   2265                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2266              }
   2267          
   2268              return ( option ); // EMBEDDED RETURN
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   54BF         ANL     A,#0xbf
   \   000017   F9           MOV     R1,A
   \   000018   8002         SJMP    ??zclGetClusterOption_1
   2269            }
   2270          
   2271            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   00001A   7900         MOV     R1,#0x0
   \                     ??zclGetClusterOption_1:
   \   00001C                REQUIRE ?Subroutine2
   \   00001C                ; // Fall through to label ?Subroutine2
   2272          }
   2273          
   2274          /*********************************************************************
   2275           * @fn      zclSetSecurityOption
   2276           *
   2277           * @brief   Set the security option for the cluster id
   2278           *
   2279           * @param   endpoint - Application's endpoint
   2280           * @param   clusterID - cluster ID looking for
   2281           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2282           *
   2283           * @return  none
   2284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2285          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2286          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EC           MOV     A,R4
   \   000006   FF           MOV     R7,A
   2287            zclOptionRec_t *pOption;
   2288          
   2289            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000007                ; Setup parameters for call to function zclFindClusterOption
   \   000007   12....       LCALL   ??zclFindClusterOption?relay; Banked call to: zclFindClusterOption
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   A8..         MOV     R0,?V0
   \   000010   A9..         MOV     R1,?V1
   2290            if ( pOption != NULL )
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   6015         JZ      ??zclSetSecurityOption_0
   2291            {
   2292              if ( enable )
   \   000016   E8           MOV     A,R0
   \   000017   2402         ADD     A,#0x2
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   39           ADDC    A,R1
   \   00001D   F583         MOV     DPH,A
   \   00001F   EF           MOV     A,R7
   \   000020   6005         JZ      ??zclSetSecurityOption_1
   2293              {
   2294                pOption->option |= AF_EN_SECURITY;
   \   000022   E0           MOVX    A,@DPTR
   \   000023   D2E6         SETB    0xE0 /* A   */.6
   \   000025   8003         SJMP    ??zclSetSecurityOption_2
   2295              }
   2296              else
   2297              {
   2298                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   C2E6         CLR     0xE0 /* A   */.6
   \                     ??zclSetSecurityOption_2:
   \   00002A   F0           MOVX    @DPTR,A
   2299              }
   2300            }
   2301          }
   \                     ??zclSetSecurityOption_0:
   \   00002B   80..         SJMP    ?Subroutine2
   2302          
   2303          #ifdef ZCL_DISCOVER
   2304          /*********************************************************************
   2305           * @fn      zclFindNextCmdRec
   2306           *
   2307           * @brief   Find the command (or next) record that matchs the parameters
   2308           *
   2309           * @param   endpoint - Application's endpoint
   2310           * @param   clusterID - cluster ID
   2311           * @param   commandID - command ID from requesting command
   2312           * @param   direction- direction of received command
   2313           * @param   pCmdID - command looking for
   2314           * @param   pCmd - command information within command record list
   2315           *
   2316           * @return  pointer to command record, NULL no more records of this cluster
   2317           */
   2318          static uint8 zclFindNextCmdRec( uint8 endpoint, uint16 clusterID, uint8 commandID,
   2319                                          uint8 direction, uint8 *pCmdID, zclCommandRec_t *pCmd )
   2320          {
   2321            zclCmdRecsList_t *pRec = zclFindCmdRecsList( endpoint );
   2322            uint8 i;
   2323          
   2324            if ( pRec != NULL )
   2325            {
   2326              for ( i = 0; i < pRec->numCommands; i++ )
   2327              {
   2328                if ( ( pRec->pCmdRecs[i].clusterID == clusterID ) &&
   2329                    ( pRec->pCmdRecs[i].cmdID >= *pCmdID ) )
   2330                {
   2331                  if ( commandID == ZCL_CMD_DISCOVER_CMDS_RECEIVED )
   2332                  {
   2333                    if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_RECEIVED ) )
   2334                    {
   2335                      *pCmd = pRec->pCmdRecs[i];
   2336          
   2337                      // Update command ID
   2338                      *pCmdID = pCmd->cmdID;
   2339          
   2340                      return ( TRUE ); // EMBEDDED RETURN
   2341                    }
   2342                    else if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_RECEIVED ) )
   2343                    {
   2344                      *pCmd = pRec->pCmdRecs[i];
   2345          
   2346                      // Update command ID
   2347                      *pCmdID = pCmd->cmdID;
   2348          
   2349                      return ( TRUE ); // EMBEDDED RETURN
   2350                    }
   2351                  }
   2352                  else if ( commandID == ZCL_CMD_DISCOVER_CMDS_GEN )
   2353                  {
   2354                    if ( ( direction == ZCL_FRAME_CLIENT_SERVER_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_SERVER_GENERATED ) )
   2355                    {
   2356                      *pCmd = pRec->pCmdRecs[i];
   2357          
   2358                      // Update command ID
   2359                      *pCmdID = pCmd->cmdID;
   2360          
   2361                      return ( TRUE ); // EMBEDDED RETURN
   2362                    }
   2363                    else if ( ( direction == ZCL_FRAME_SERVER_CLIENT_DIR ) && ( pRec->pCmdRecs[i].flag & CMD_DIR_CLIENT_GENERATED ) )
   2364                    {
   2365                      *pCmd = pRec->pCmdRecs[i];
   2366          
   2367                      // Update command ID
   2368                      *pCmdID = pCmd->cmdID;
   2369          
   2370                      return ( TRUE ); // EMBEDDED RETURN
   2371                    }
   2372                  }
   2373                  else
   2374                  {
   2375                    return ( FALSE ); // Incorrect Command ID
   2376                  }
   2377                }
   2378              }
   2379            }
   2380          
   2381            return ( FALSE );
   2382          }
   2383          
   2384          /*********************************************************************
   2385           * @fn      zclFindNextAttrRec
   2386           *
   2387           * @brief   Find the attribute (or next) record that matchs the parameters
   2388           *
   2389           * @param   endpoint - Application's endpoint
   2390           * @param   clusterID - cluster ID
   2391           * @param   attr - attribute looking for
   2392           *
   2393           * @return  pointer to attribute record, NULL if not found
   2394           */
   2395          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint8 direction,
   2396                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2397          {
   2398            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2399            uint8 attrDir;
   2400          
   2401            if ( pRec != NULL )
   2402            {
   2403              uint16 x;
   2404          
   2405              for ( x = 0; x < pRec->numAttributes; x++ )
   2406              {
   2407                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2408                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2409                {
   2410                  // also make sure direction is right
   2411                  attrDir = (pRec->attrs[x].attr.accessControl & ACCESS_CLIENT) ? 1 : 0;
   2412                  if ( attrDir == direction )
   2413                  {
   2414                    // return attribute and found attribute ID
   2415                    *pAttr = pRec->attrs[x];
   2416                    *attrId = pAttr->attr.attrId;
   2417          
   2418                    return ( TRUE ); // EMBEDDED RETURN
   2419                  }
   2420                }
   2421              }
   2422            }
   2423          
   2424            return ( FALSE );
   2425          }
   2426          #endif // ZCL_DISCOVER
   2427          
   2428          /*********************************************************************
   2429           * @fn      zclSerializeData
   2430           *
   2431           * @brief   Builds a buffer from the attribute data to sent out over
   2432           *          the air.
   2433           *          NOTE - Not compatible with application's attributes callbacks.
   2434           *
   2435           * @param   dataType - data types defined in zcl.h
   2436           * @param   attrData - pointer to the attribute data
   2437           * @param   buf - where to put the serialized data
   2438           *
   2439           * @return  pointer to end of destination buffer
   2440           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2441          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2442          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   \   000007   8A..         MOV     ?V4,R2
   \   000009   8B..         MOV     ?V5,R3
   \   00000B   EC           MOV     A,R4
   \   00000C   FA           MOV     R2,A
   \   00000D   ED           MOV     A,R5
   \   00000E   FB           MOV     R3,A
   2443            uint8 *pStr;
   2444            uint16 len;
   2445          
   2446            if ( attrData == NULL )
   \   00000F   E5..         MOV     A,?V4
   \   000011   45..         ORL     A,?V5
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2447            {
   2448              return ( buf );
   2449            }
   2450          
   2451            switch ( dataType )
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   A3           INC     DPTR
   \   00001D   AC82         MOV     R4,DPL
   \   00001F   AD83         MOV     R5,DPH
   \   000021   85....       MOV     ?V0,?V4
   \   000024   85....       MOV     ?V1,?V5
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   EE           MOV     A,R6
   \   00002B   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclSerializeData>_0`:
   \   00002E   04           DB        4
   \   00002F   41           DB        65
   \   000030   42           DB        66
   \   000031   ....         DW        ??zclSerializeData_1
   \   000033   43           DB        67
   \   000034   44           DB        68
   \   000035   ....         DW        ??zclSerializeData_2
   \   000037   E0           DB        224
   \   000038   E2           DB        226
   \   000039   ....         DW        ??zclSerializeData_3
   \   00003B   E8           DB        232
   \   00003C   E9           DB        233
   \   00003D   ....         DW        ??zclSerializeData_4
   \   00003F   1A           DB        26
   \   000040   08           DB        8
   \   000041   ....         DW        ??zclSerializeData_5
   \   000043   09           DB        9
   \   000044   ....         DW        ??zclSerializeData_4
   \   000046   0A           DB        10
   \   000047   ....         DW        ??zclSerializeData_6
   \   000049   0B           DB        11
   \   00004A   ....         DW        ??zclSerializeData_3
   \   00004C   10           DB        16
   \   00004D   ....         DW        ??zclSerializeData_5
   \   00004F   18           DB        24
   \   000050   ....         DW        ??zclSerializeData_5
   \   000052   19           DB        25
   \   000053   ....         DW        ??zclSerializeData_4
   \   000055   1A           DB        26
   \   000056   ....         DW        ??zclSerializeData_6
   \   000058   1B           DB        27
   \   000059   ....         DW        ??zclSerializeData_3
   \   00005B   20           DB        32
   \   00005C   ....         DW        ??zclSerializeData_5
   \   00005E   21           DB        33
   \   00005F   ....         DW        ??zclSerializeData_4
   \   000061   22           DB        34
   \   000062   ....         DW        ??zclSerializeData_6
   \   000064   23           DB        35
   \   000065   ....         DW        ??zclSerializeData_3
   \   000067   24           DB        36
   \   000068   ....         DW        ??zclSerializeData_7
   \   00006A   25           DB        37
   \   00006B   ....         DW        ??zclSerializeData_8
   \   00006D   28           DB        40
   \   00006E   ....         DW        ??zclSerializeData_5
   \   000070   29           DB        41
   \   000071   ....         DW        ??zclSerializeData_4
   \   000073   2A           DB        42
   \   000074   ....         DW        ??zclSerializeData_6
   \   000076   2B           DB        43
   \   000077   ....         DW        ??zclSerializeData_3
   \   000079   30           DB        48
   \   00007A   ....         DW        ??zclSerializeData_5
   \   00007C   31           DB        49
   \   00007D   ....         DW        ??zclSerializeData_4
   \   00007F   38           DB        56
   \   000080   ....         DW        ??zclSerializeData_4
   \   000082   39           DB        57
   \   000083   ....         DW        ??zclSerializeData_3
   \   000085   EA           DB        234
   \   000086   ....         DW        ??zclSerializeData_3
   \   000088   F0           DB        240
   \   000089   ....         DW        ??zclSerializeData_9
   \   00008B   F1           DB        241
   \   00008C   ....         DW        ??zclSerializeData_10
   \   00008E   ....         DW        ??zclSerializeData_0
   2452            {
   2453              case ZCL_DATATYPE_DATA8:
   2454              case ZCL_DATATYPE_BOOLEAN:
   2455              case ZCL_DATATYPE_BITMAP8:
   2456              case ZCL_DATATYPE_INT8:
   2457              case ZCL_DATATYPE_UINT8:
   2458              case ZCL_DATATYPE_ENUM8:
   2459                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_5:
   \   000090   85..82       MOV     DPL,?V4
   \   000093   85..83       MOV     DPH,?V5
   \   000096   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000099   EC           MOV     A,R4
   \   00009A   FA           MOV     R2,A
   \   00009B   ED           MOV     A,R5
   \   00009C   FB           MOV     R3,A
   2460                 break;
   \   00009D   02....       LJMP    ??zclSerializeData_0 & 0xFFFF
   2461          
   2462              case ZCL_DATATYPE_DATA16:
   2463              case ZCL_DATATYPE_BITMAP16:
   2464              case ZCL_DATATYPE_UINT16:
   2465              case ZCL_DATATYPE_INT16:
   2466              case ZCL_DATATYPE_ENUM16:
   2467              case ZCL_DATATYPE_SEMI_PREC:
   2468              case ZCL_DATATYPE_CLUSTER_ID:
   2469              case ZCL_DATATYPE_ATTR_ID:
   2470                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_4:
   \   0000A0   85..82       MOV     DPL,?V4
   \   0000A3   85..83       MOV     DPH,?V5
   \   0000A6   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_441:
   \   0000A9   12....       LCALL   ?Subroutine33 & 0xFFFF
   2471                *buf++ = HI_UINT16( *((uint16*)attrData) );
   \                     ??CrossCallReturnLabel_35:
   \   0000AC   A3           INC     DPTR
   \   0000AD   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_442:
   \   0000B0   8036         SJMP    ??zclSerializeData_11
   2472                break;
   2473          
   2474              case ZCL_DATATYPE_DATA24:
   2475              case ZCL_DATATYPE_BITMAP24:
   2476              case ZCL_DATATYPE_UINT24:
   2477              case ZCL_DATATYPE_INT24:
   2478                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_6:
   \   0000B2   85..82       MOV     DPL,?V4
   \   0000B5   85..83       MOV     DPH,?V5
   \   0000B8   78..         MOV     R0,#?V0
   \   0000BA   12....       LCALL   ?L_MOV_X
   \   0000BD   8A82         MOV     DPL,R2
   \   0000BF   8B83         MOV     DPH,R3
   \   0000C1   E5..         MOV     A,?V0
   \   0000C3   12....       LCALL   ?Subroutine33 & 0xFFFF
   2479                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   \                     ??CrossCallReturnLabel_36:
   \   0000C6   78..         MOV     R0,#?V0
   \   0000C8   12....       LCALL   ?L_MOV_X
   \   0000CB   E5..         MOV     A,?V1
   \   0000CD   12....       LCALL   ??Subroutine163_0 & 0xFFFF
   2480                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_268:
   \   0000D0   85..82       MOV     DPL,?V4
   \   0000D3   85..83       MOV     DPH,?V5
   \   0000D6   78..         MOV     R0,#?V0
   \   0000D8   12....       LCALL   ?L_MOV_X
   \   0000DB   7410         MOV     A,#0x10
   \   0000DD   78..         MOV     R0,#?V0
   \   0000DF   12....       LCALL   ?UL_SHR
   \   0000E2   8A82         MOV     DPL,R2
   \   0000E4   8B83         MOV     DPH,R3
   \   0000E6   E5..         MOV     A,?V0
   \                     ??zclSerializeData_11:
   \   0000E8   12....       LCALL   ??Subroutine164_0 & 0xFFFF
   2481                break;
   \                     ??CrossCallReturnLabel_267:
   \   0000EB   8067         SJMP    ??zclSerializeData_0
   2482          
   2483              case ZCL_DATATYPE_DATA32:
   2484              case ZCL_DATATYPE_BITMAP32:
   2485              case ZCL_DATATYPE_UINT32:
   2486              case ZCL_DATATYPE_INT32:
   2487              case ZCL_DATATYPE_SINGLE_PREC:
   2488              case ZCL_DATATYPE_TOD:
   2489              case ZCL_DATATYPE_DATE:
   2490              case ZCL_DATATYPE_UTC:
   2491              case ZCL_DATATYPE_BAC_OID:
   2492                buf = zcl_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000ED                ; Setup parameters for call to function osal_buffer_uint32
   \   0000ED   85..82       MOV     DPL,?V4
   \   0000F0   85..83       MOV     DPH,?V5
   \   0000F3   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0000F6   12....       LCALL   ??osal_buffer_uint32?relay; Banked call to: osal_buffer_uint32
   \   0000F9   7404         MOV     A,#0x4
   \   0000FB   12....       LCALL   ?DEALLOC_XSTACK8
   2493                break;
   \   0000FE   8054         SJMP    ??zclSerializeData_0
   2494          
   2495              case ZCL_DATATYPE_UINT40:
   2496                pStr = (uint8*)attrData;
   2497                buf = zcl_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_7:
   \   000100                ; Setup parameters for call to function osal_memcpy
   \   000100   78..         MOV     R0,#?V0
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000105   7C05         MOV     R4,#0x5
   \   000107   8041         SJMP    ??zclSerializeData_12
   2498                break;
   2499          
   2500              case ZCL_DATATYPE_UINT48:
   2501                pStr = (uint8*)attrData;
   2502                buf = zcl_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_8:
   \   000109                ; Setup parameters for call to function osal_memcpy
   \   000109   78..         MOV     R0,#?V0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00010E   7C06         MOV     R4,#0x6
   \   000110   8038         SJMP    ??zclSerializeData_12
   2503                break;
   2504          
   2505              case ZCL_DATATYPE_IEEE_ADDR:
   2506                pStr = (uint8*)attrData;
   2507                buf = zcl_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_9:
   \   000112                ; Setup parameters for call to function osal_memcpy
   \   000112   78..         MOV     R0,#?V0
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000117   7C08         MOV     R4,#0x8
   \   000119   802F         SJMP    ??zclSerializeData_12
   2508                break;
   2509          
   2510              case ZCL_DATATYPE_CHAR_STR:
   2511              case ZCL_DATATYPE_OCTET_STR:
   2512                pStr = (uint8*)attrData;
   2513                len = *pStr;
   2514                buf = zcl_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_1:
   \   00011B                ; Setup parameters for call to function osal_memcpy
   \   00011B   78..         MOV     R0,#?V0
   \   00011D   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000120   85..82       MOV     DPL,?V4
   \   000123   85..83       MOV     DPH,?V5
   \   000126   E0           MOVX    A,@DPTR
   \   000127   2401         ADD     A,#0x1
   \   000129   FC           MOV     R4,A
   \   00012A   E4           CLR     A
   \   00012B   3400         ADDC    A,#0x0
   \   00012D   8011         SJMP    ??zclSerializeData_13
   2515                break;
   2516          
   2517              case ZCL_DATATYPE_LONG_CHAR_STR:
   2518              case ZCL_DATATYPE_LONG_OCTET_STR:
   2519                pStr = (uint8*)attrData;
   2520                len = BUILD_UINT16( pStr[0], pStr[1] );
   2521                buf = zcl_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_2:
   \   00012F                ; Setup parameters for call to function osal_memcpy
   \   00012F   78..         MOV     R0,#?V0
   \   000131   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000134   85..82       MOV     DPL,?V4
   \   000137   85..83       MOV     DPH,?V5
   \   00013A   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   00013D   FC           MOV     R4,A
   \   00013E   E4           CLR     A
   \   00013F   39           ADDC    A,R1
   \                     ??zclSerializeData_13:
   \   000140   FD           MOV     R5,A
   \   000141   8009         SJMP    ??zclSerializeData_14
   2522                break;
   2523          
   2524              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2525                pStr = (uint8*)attrData;
   2526                buf = zcl_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_10:
   \   000143                ; Setup parameters for call to function osal_memcpy
   \   000143   78..         MOV     R0,#?V0
   \   000145   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000148   7C10         MOV     R4,#0x10
   \                     ??zclSerializeData_12:
   \   00014A   7D00         MOV     R5,#0x0
   \                     ??zclSerializeData_14:
   \   00014C   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00014F   7403         MOV     A,#0x3
   \   000151   12....       LCALL   ?DEALLOC_XSTACK8
   2527                break;
   2528          
   2529              case ZCL_DATATYPE_NO_DATA:
   2530              case ZCL_DATATYPE_UNKNOWN:
   2531                // Fall through
   2532          
   2533              default:
   2534                break;
   2535            }
   2536          
   2537            return ( buf );
   \                     ??zclSerializeData_0:
   \   000154   02....       LJMP    ??Subroutine156_0 & 0xFFFF
   2538          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EC           MOV     A,R4
   \   000002   FA           MOV     R2,A
   \   000003   ED           MOV     A,R5
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?V4
   \   000008   85..83       MOV     DPH,?V5
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_347:
   \   000003   F9           MOV     R1,A
   \   000004   EC           MOV     A,R4
   \   000005   2402         ADD     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine197_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET
   2539          
   2540          #ifdef ZCL_REPORT
   2541          /*********************************************************************
   2542           * @fn      zclAnalogDataType
   2543           *
   2544           * @brief   Checks to see if Data Type is Analog
   2545           *
   2546           * @param   dataType - data type
   2547           *
   2548           * @return  TRUE if data type is analog
   2549           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2550          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2551          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   2552            uint8 analog;
   2553          
   2554            switch ( dataType )
   \   000005   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for zclAnalogDataType>_0`:
   \   000008   03           DB        3
   \   000009   20           DB        32
   \   00000A   2F           DB        47
   \   00000B   ....         DW        ??zclAnalogDataType_0
   \   00000D   38           DB        56
   \   00000E   3A           DB        58
   \   00000F   ....         DW        ??zclAnalogDataType_0
   \   000011   E0           DB        224
   \   000012   E2           DB        226
   \   000013   ....         DW        ??zclAnalogDataType_0
   \   000015   00           DB        0
   \   000016   ....         DW        ??zclAnalogDataType_1
   2555            {
   2556              case ZCL_DATATYPE_UINT8:
   2557              case ZCL_DATATYPE_UINT16:
   2558              case ZCL_DATATYPE_UINT24:
   2559              case ZCL_DATATYPE_UINT32:
   2560              case ZCL_DATATYPE_UINT40:
   2561              case ZCL_DATATYPE_UINT48:
   2562              case ZCL_DATATYPE_UINT56:
   2563              case ZCL_DATATYPE_UINT64:
   2564              case ZCL_DATATYPE_INT8:
   2565              case ZCL_DATATYPE_INT16:
   2566              case ZCL_DATATYPE_INT24:
   2567              case ZCL_DATATYPE_INT32:
   2568              case ZCL_DATATYPE_INT40:
   2569              case ZCL_DATATYPE_INT48:
   2570              case ZCL_DATATYPE_INT56:
   2571              case ZCL_DATATYPE_INT64:
   2572              case ZCL_DATATYPE_SEMI_PREC:
   2573              case ZCL_DATATYPE_SINGLE_PREC:
   2574              case ZCL_DATATYPE_DOUBLE_PREC:
   2575              case ZCL_DATATYPE_TOD:
   2576              case ZCL_DATATYPE_DATE:
   2577              case ZCL_DATATYPE_UTC:
   2578                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   000018   7901         MOV     R1,#0x1
   2579                break;
   \   00001A   8002         SJMP    ??zclAnalogDataType_2
   2580          
   2581              default:
   2582                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   00001C   7900         MOV     R1,#0x0
   2583                break;
   2584            }
   2585          
   2586            return ( analog );
   \                     ??zclAnalogDataType_2:
   \   00001E   02....       LJMP    ?Subroutine0 & 0xFFFF
   2587          }
   2588          
   2589          /*********************************************************************
   2590           * @fn      zclIsLittleEndianMachine
   2591           *
   2592           * @brief   Verifies endianness in system.
   2593           *
   2594           * @param   none
   2595           *
   2596           * @return  MSB-00 or LSB-01 depending on endianness in the system
   2597           */
   2598          static int zclIsLittleEndianMachine(void)
   2599          {
   2600            uint16 test = 0x0001;
   2601          
   2602            return (*((uint8 *)(&test)));
   2603          }
   2604          
   2605          /*********************************************************************
   2606           * @fn      zcl_BuildAnalogData
   2607           *
   2608           * @brief   Build an analog arribute out of sequential bytes.
   2609           *
   2610           * @param   dataType - type of data
   2611           * @param   pData - pointer to data
   2612           * @param   pBuf - where to put the data
   2613           *
   2614           * @return  none
   2615           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2616          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf )
   \                     zcl_BuildAnalogData:
   2617          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   2618            int current_byte_index;
   2619            int remaining_bytes;
   2620            int step;
   2621          
   2622            remaining_bytes = zclGetAttrDataLength(dataType, pData);
   \   000012                ; Setup parameters for call to function zclGetAttrDataLength
   \   000012   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   2623          
   2624            // decide if move forward or backwards to copy data
   2625            if ( zclIsLittleEndianMachine() )
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7401         MOV     A,#0x1
   \   00001D   F0           MOVX    @DPTR,A
   \   00001E   A3           INC     DPTR
   \   00001F   E4           CLR     A
   \   000020   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000023   600C         JZ      ??zcl_BuildAnalogData_0
   2626            {
   2627              step = 1;
   \   000025   75..01       MOV     ?V4,#0x1
   \   000028   75..00       MOV     ?V5,#0x0
   2628              current_byte_index = 0;
   \   00002B   7800         MOV     R0,#0x0
   \   00002D   7900         MOV     R1,#0x0
   \   00002F   8038         SJMP    ??zcl_BuildAnalogData_1
   2629            }
   2630            else
   2631            {
   2632              step = -1;
   \                     ??zcl_BuildAnalogData_0:
   \   000031   75..FF       MOV     ?V4,#-0x1
   \   000034   75..FF       MOV     ?V5,#-0x1
   2633              current_byte_index = remaining_bytes - 1;
   \   000037   EA           MOV     A,R2
   \   000038   24FF         ADD     A,#-0x1
   \   00003A   F8           MOV     R0,A
   \   00003B   EB           MOV     A,R3
   \   00003C   34FF         ADDC    A,#-0x1
   \   00003E   8028         SJMP    ??zcl_BuildAnalogData_2
   2634            }
   2635          
   2636            while ( remaining_bytes-- )
   2637            {
   2638              pData[current_byte_index] = *(pBuf++);
   \                     ??zcl_BuildAnalogData_3:
   \   000040   85..82       MOV     DPL,?V0
   \   000043   85..83       MOV     DPH,?V1
   \   000046   E0           MOVX    A,@DPTR
   \   000047   C0E0         PUSH    A
   \   000049   EE           MOV     A,R6
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   EF           MOV     A,R7
   \   00004E   39           ADDC    A,R1
   \   00004F   F583         MOV     DPH,A
   \   000051   D0E0         POP     A
   \   000053   F0           MOVX    @DPTR,A
   \   000054   85..82       MOV     DPL,?V0
   \   000057   85..83       MOV     DPH,?V1
   \   00005A   A3           INC     DPTR
   \   00005B   8582..       MOV     ?V0,DPL
   \   00005E   8583..       MOV     ?V1,DPH
   2639              current_byte_index += step;
   \   000061   E8           MOV     A,R0
   \   000062   25..         ADD     A,?V4
   \   000064   F8           MOV     R0,A
   \   000065   E9           MOV     A,R1
   \   000066   35..         ADDC    A,?V5
   \                     ??zcl_BuildAnalogData_2:
   \   000068   F9           MOV     R1,A
   2640            }
   \                     ??zcl_BuildAnalogData_1:
   \   000069   EA           MOV     A,R2
   \   00006A   FC           MOV     R4,A
   \   00006B   EB           MOV     A,R3
   \   00006C   FD           MOV     R5,A
   \   00006D   EC           MOV     A,R4
   \   00006E   24FF         ADD     A,#-0x1
   \   000070   1A           DEC     R2
   \   000071   ED           MOV     A,R5
   \   000072   34FF         ADDC    A,#-0x1
   \   000074   FB           MOV     R3,A
   \   000075   EC           MOV     A,R4
   \   000076   4D           ORL     A,R5
   \   000077   70C7         JNZ     ??zcl_BuildAnalogData_3
   2641          }
   \   000079   7402         MOV     A,#0x2
   \   00007B   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine123:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function osal_mem_alloc
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET
   2642          #endif // ZCL_REPORT
   2643          
   2644          /*********************************************************************
   2645           * @fn      zclGetDataTypeLength
   2646           *
   2647           * @brief   Return the length of the datatype in octet.
   2648           *
   2649           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2650           *                ZCL_DATATYPE_CHAR_STR data types.
   2651           *
   2652           * @param   dataType - data type
   2653           *
   2654           * @return  length of data
   2655           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2656          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2657          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   2658            uint8 len;
   2659          
   2660            switch ( dataType )
   \   000001   24F8         ADD     A,#-0x8
   \   000003   6078         JZ      ??zclGetDataTypeLength_0
   \   000005   14           DEC     A
   \   000006   6079         JZ      ??zclGetDataTypeLength_1
   \   000008   14           DEC     A
   \   000009   607A         JZ      ??zclGetDataTypeLength_2
   \   00000B   14           DEC     A
   \   00000C   607B         JZ      ??zclGetDataTypeLength_3
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   606B         JZ      ??zclGetDataTypeLength_0
   \   000012   24F8         ADD     A,#-0x8
   \   000014   6067         JZ      ??zclGetDataTypeLength_0
   \   000016   14           DEC     A
   \   000017   6068         JZ      ??zclGetDataTypeLength_1
   \   000019   14           DEC     A
   \   00001A   6069         JZ      ??zclGetDataTypeLength_2
   \   00001C   14           DEC     A
   \   00001D   606A         JZ      ??zclGetDataTypeLength_3
   \   00001F   24FB         ADD     A,#-0x5
   \   000021   605A         JZ      ??zclGetDataTypeLength_0
   \   000023   14           DEC     A
   \   000024   605B         JZ      ??zclGetDataTypeLength_1
   \   000026   14           DEC     A
   \   000027   605C         JZ      ??zclGetDataTypeLength_2
   \   000029   14           DEC     A
   \   00002A   605D         JZ      ??zclGetDataTypeLength_3
   \   00002C   14           DEC     A
   \   00002D   605E         JZ      ??zclGetDataTypeLength_4
   \   00002F   14           DEC     A
   \   000030   605F         JZ      ??zclGetDataTypeLength_5
   \   000032   14           DEC     A
   \   000033   6060         JZ      ??zclGetDataTypeLength_6
   \   000035   14           DEC     A
   \   000036   6061         JZ      ??zclGetDataTypeLength_7
   \   000038   14           DEC     A
   \   000039   6042         JZ      ??zclGetDataTypeLength_0
   \   00003B   14           DEC     A
   \   00003C   6043         JZ      ??zclGetDataTypeLength_1
   \   00003E   14           DEC     A
   \   00003F   6044         JZ      ??zclGetDataTypeLength_2
   \   000041   14           DEC     A
   \   000042   6045         JZ      ??zclGetDataTypeLength_3
   \   000044   14           DEC     A
   \   000045   6046         JZ      ??zclGetDataTypeLength_4
   \   000047   14           DEC     A
   \   000048   6047         JZ      ??zclGetDataTypeLength_5
   \   00004A   14           DEC     A
   \   00004B   6048         JZ      ??zclGetDataTypeLength_6
   \   00004D   14           DEC     A
   \   00004E   6049         JZ      ??zclGetDataTypeLength_7
   \   000050   14           DEC     A
   \   000051   602A         JZ      ??zclGetDataTypeLength_0
   \   000053   14           DEC     A
   \   000054   602B         JZ      ??zclGetDataTypeLength_1
   \   000056   24F9         ADD     A,#-0x7
   \   000058   6027         JZ      ??zclGetDataTypeLength_1
   \   00005A   14           DEC     A
   \   00005B   602C         JZ      ??zclGetDataTypeLength_3
   \   00005D   14           DEC     A
   \   00005E   6039         JZ      ??zclGetDataTypeLength_7
   \   000060   245A         ADD     A,#0x5a
   \   000062   6025         JZ      ??zclGetDataTypeLength_3
   \   000064   14           DEC     A
   \   000065   6022         JZ      ??zclGetDataTypeLength_3
   \   000067   14           DEC     A
   \   000068   601F         JZ      ??zclGetDataTypeLength_3
   \   00006A   24FA         ADD     A,#-0x6
   \   00006C   6013         JZ      ??zclGetDataTypeLength_1
   \   00006E   14           DEC     A
   \   00006F   6010         JZ      ??zclGetDataTypeLength_1
   \   000071   14           DEC     A
   \   000072   6015         JZ      ??zclGetDataTypeLength_3
   \   000074   24FA         ADD     A,#-0x6
   \   000076   6021         JZ      ??zclGetDataTypeLength_7
   \   000078   14           DEC     A
   \   000079   6022         JZ      ??zclGetDataTypeLength_8
   \   00007B   8024         SJMP    ??zclGetDataTypeLength_9
   2661            {
   2662              case ZCL_DATATYPE_DATA8:
   2663              case ZCL_DATATYPE_BOOLEAN:
   2664              case ZCL_DATATYPE_BITMAP8:
   2665              case ZCL_DATATYPE_INT8:
   2666              case ZCL_DATATYPE_UINT8:
   2667              case ZCL_DATATYPE_ENUM8:
   2668                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   00007D   7901         MOV     R1,#0x1
   2669                break;
   \   00007F   8022         SJMP    ??zclGetDataTypeLength_10
   2670          
   2671              case ZCL_DATATYPE_DATA16:
   2672              case ZCL_DATATYPE_BITMAP16:
   2673              case ZCL_DATATYPE_UINT16:
   2674              case ZCL_DATATYPE_INT16:
   2675              case ZCL_DATATYPE_ENUM16:
   2676              case ZCL_DATATYPE_SEMI_PREC:
   2677              case ZCL_DATATYPE_CLUSTER_ID:
   2678              case ZCL_DATATYPE_ATTR_ID:
   2679                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   000081   7902         MOV     R1,#0x2
   2680                break;
   \   000083   801E         SJMP    ??zclGetDataTypeLength_10
   2681          
   2682              case ZCL_DATATYPE_DATA24:
   2683              case ZCL_DATATYPE_BITMAP24:
   2684              case ZCL_DATATYPE_UINT24:
   2685              case ZCL_DATATYPE_INT24:
   2686                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   000085   7903         MOV     R1,#0x3
   2687                break;
   \   000087   801A         SJMP    ??zclGetDataTypeLength_10
   2688          
   2689              case ZCL_DATATYPE_DATA32:
   2690              case ZCL_DATATYPE_BITMAP32:
   2691              case ZCL_DATATYPE_UINT32:
   2692              case ZCL_DATATYPE_INT32:
   2693              case ZCL_DATATYPE_SINGLE_PREC:
   2694              case ZCL_DATATYPE_TOD:
   2695              case ZCL_DATATYPE_DATE:
   2696              case ZCL_DATATYPE_UTC:
   2697              case ZCL_DATATYPE_BAC_OID:
   2698                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   000089   7904         MOV     R1,#0x4
   2699                break;
   \   00008B   8016         SJMP    ??zclGetDataTypeLength_10
   2700          
   2701             case ZCL_DATATYPE_UINT40:
   2702             case ZCL_DATATYPE_INT40:
   2703                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   00008D   7905         MOV     R1,#0x5
   2704                 break;
   \   00008F   8012         SJMP    ??zclGetDataTypeLength_10
   2705          
   2706             case ZCL_DATATYPE_UINT48:
   2707             case ZCL_DATATYPE_INT48:
   2708                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   000091   7906         MOV     R1,#0x6
   2709                 break;
   \   000093   800E         SJMP    ??zclGetDataTypeLength_10
   2710          
   2711             case ZCL_DATATYPE_UINT56:
   2712             case ZCL_DATATYPE_INT56:
   2713                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   000095   7907         MOV     R1,#0x7
   2714                 break;
   \   000097   800A         SJMP    ??zclGetDataTypeLength_10
   2715          
   2716             case ZCL_DATATYPE_DOUBLE_PREC:
   2717             case ZCL_DATATYPE_IEEE_ADDR:
   2718             case ZCL_DATATYPE_UINT64:
   2719             case ZCL_DATATYPE_INT64:
   2720               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   000099   7908         MOV     R1,#0x8
   2721               break;
   \   00009B   8006         SJMP    ??zclGetDataTypeLength_10
   2722          
   2723              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2724               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   00009D   7910         MOV     R1,#0x10
   2725               break;
   \   00009F   8002         SJMP    ??zclGetDataTypeLength_10
   2726          
   2727              case ZCL_DATATYPE_NO_DATA:
   2728              case ZCL_DATATYPE_UNKNOWN:
   2729                // Fall through
   2730          
   2731              default:
   2732                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000A1   7900         MOV     R1,#0x0
   2733                break;
   2734            }
   2735          
   2736            return ( len );
   \                     ??zclGetDataTypeLength_10:
   \   0000A3   02....       LJMP    ?BRET
   2737          }
   2738          
   2739          /*********************************************************************
   2740           * @fn      zclGetAttrDataLength
   2741           *
   2742           * @brief   Return the length of the attribute.
   2743           *
   2744           * @param   dataType - data type
   2745           * @param   pData - pointer to data
   2746           *
   2747           * @return  returns atrribute length
   2748           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2749          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2750          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   2751            uint16 dataLen = 0;
   2752          
   2753            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000007   7444         MOV     A,#0x44
   \   000009   6E           XRL     A,R6
   \   00000A   6005         JZ      ??zclGetAttrDataLength_0
   \   00000C   7443         MOV     A,#0x43
   \   00000E   6E           XRL     A,R6
   \   00000F   700C         JNZ     ??zclGetAttrDataLength_1
   2754            {
   2755              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   12....       LCALL   ?Subroutine100 & 0xFFFF
   2756            }
   \                     ??CrossCallReturnLabel_165:
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   39           ADDC    A,R1
   \   00001B   8015         SJMP    ??zclGetAttrDataLength_2
   2757            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001D   7442         MOV     A,#0x42
   \   00001F   6E           XRL     A,R6
   \   000020   6005         JZ      ??zclGetAttrDataLength_3
   \   000022   7441         MOV     A,#0x41
   \   000024   6E           XRL     A,R6
   \   000025   700E         JNZ     ??zclGetAttrDataLength_4
   2758            {
   2759              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_3:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   2401         ADD     A,#0x1
   \   00002E   FA           MOV     R2,A
   \   00002F   E4           CLR     A
   \   000030   3400         ADDC    A,#0x0
   \                     ??zclGetAttrDataLength_2:
   \   000032   FB           MOV     R3,A
   \   000033   8007         SJMP    ??zclGetAttrDataLength_5
   2760            }
   2761            else
   2762            {
   2763              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_4:
   \   000035                ; Setup parameters for call to function zclGetDataTypeLength
   \   000035   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000038   E9           MOV     A,R1
   \   000039   FA           MOV     R2,A
   \   00003A   7B00         MOV     R3,#0x0
   2764            }
   2765          
   2766            return ( dataLen );
   \                     ??zclGetAttrDataLength_5:
   \   00003C   02....       LJMP    ?Subroutine7 & 0xFFFF
   2767          }
   2768          
   2769          #ifdef ZCL_READ
   2770          /*********************************************************************
   2771           * @fn      zclReadAttrData
   2772           *
   2773           * @brief   Read the attribute's current value into pAttrData.
   2774           *          NOTE - Not compatible with application's attributes callbacks.
   2775           *
   2776           * @param   pAttrData - where to put attribute data
   2777           * @param   pAttr - pointer to attribute
   2778           * @param   pDataLen - where to put attribute data length
   2779           *
   2780           * @return Success
   2781           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2782          ZStatus_t zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2783          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2784            uint16 dataLen;
   2785          
   2786            if ( pAttr->attr.dataPtr == NULL )
   \   000009   EC           MOV     A,R4
   \   00000A   2406         ADD     A,#0x6
   \   00000C   F8           MOV     R0,A
   \   00000D   E4           CLR     A
   \   00000E   3D           ADDC    A,R5
   \   00000F   F9           MOV     R1,A
   \   000010   88..         MOV     ?V0,R0
   \   000012   89..         MOV     ?V1,R1
   \   000014   8882         MOV     DPL,R0
   \   000016   F583         MOV     DPH,A
   \   000018   12....       LCALL   ??Subroutine155_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   00001B   7004         JNZ     ??zclReadAttrData_0
   2787            {
   2788              return ( ZCL_STATUS_FAILURE );
   \   00001D   7901         MOV     R1,#0x1
   \   00001F   804C         SJMP    ??zclReadAttrData_1
   2789            }
   2790          
   2791            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \                     ??zclReadAttrData_0:
   \   000021                ; Setup parameters for call to function zclGetAttrDataLength
   \   000021   8C82         MOV     DPL,R4
   \   000023   8D83         MOV     DPH,R5
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   F9           MOV     R1,A
   \   00002B   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00002E   8A..         MOV     ?V2,R2
   \   000030   8B..         MOV     ?V3,R3
   2792            zcl_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000032                ; Setup parameters for call to function osal_memcpy
   \   000032   85..82       MOV     DPL,?V0
   \   000035   85..83       MOV     DPH,?V1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F5..         MOV     ?V0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   85....       MOV     ?V4,?V0
   \   000040   F5..         MOV     ?V5,A
   \   000042   75..00       MOV     ?V6,#0x0
   \   000045   78..         MOV     R0,#?V4
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004A   AC..         MOV     R4,?V2
   \   00004C   AD..         MOV     R5,?V3
   \   00004E   EE           MOV     A,R6
   \   00004F   FA           MOV     R2,A
   \   000050   EF           MOV     A,R7
   \   000051   FB           MOV     R3,A
   \   000052   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000055   7403         MOV     A,#0x3
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   740F         MOV     A,#0xf
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   12....       LCALL   ??Subroutine170_0 & 0xFFFF
   2793          
   2794            if ( pDataLen != NULL )
   \                     ??CrossCallReturnLabel_288:
   \   000062   6007         JZ      ??zclReadAttrData_2
   2795            {
   2796              *pDataLen = dataLen;
   \   000064   E5..         MOV     A,?V2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E5..         MOV     A,?V3
   \   00006A   F0           MOVX    @DPTR,A
   2797            }
   2798          
   2799            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_2:
   \   00006B   7900         MOV     R1,#0x0
   \                     ??zclReadAttrData_1:
   \   00006D   7F07         MOV     R7,#0x7
   \   00006F   02....       LJMP    ?BANKED_LEAVE_XDATA
   2800          }
   2801          
   2802          
   2803          #endif // ZCL_READ
   2804          
   2805          #ifdef ZCL_READ
   2806          /*********************************************************************
   2807           * @fn      zclParseInReadCmd
   2808           *
   2809           * @brief   Parse the "Profile" Read Commands
   2810           *
   2811           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2812           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2813           *
   2814           * @param   pCmd - pointer to incoming data to parse
   2815           *
   2816           * @return  pointer to the parsed command structure
   2817           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2818          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2819          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   2820            zclReadCmd_t *readCmd;
   2821            uint8 *pBuf = pCmd->pData;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_364:
   \   00000C   E8           MOV     A,R0
   \   00000D   FE           MOV     R6,A
   \   00000E   E9           MOV     A,R1
   \   00000F   FF           MOV     R7,A
   2822          
   2823            readCmd = (zclReadCmd_t *)zcl_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000010   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   000013   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   2824            if ( readCmd != NULL )
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   6049         JZ      ??zclParseInReadCmd_0
   2825            {
   2826              uint8 i;
   2827              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00001A   85..82       MOV     DPL,?V0
   \   00001D   85..83       MOV     DPH,?V1
   \   000020   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_391:
   \   000023   C3           CLR     C
   \   000024   13           RRC     A
   \   000025   E8           MOV     A,R0
   \   000026   13           RRC     A
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   F0           MOVX    @DPTR,A
   2828              for ( i = 0; i < readCmd->numAttr; i++ )
   \   00002C   75..00       MOV     ?V0,#0x0
   \   00002F   8029         SJMP    ??zclParseInReadCmd_1
   2829              {
   2830                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_2:
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   12....       LCALL   ??Subroutine179_0 & 0xFFFF
   2831                pBuf += 2;
   2832              }
   \                     ??CrossCallReturnLabel_346:
   \   000038   F8           MOV     R0,A
   \   000039   E4           CLR     A
   \   00003A   C8           XCH     A,R0
   \   00003B   F9           MOV     R1,A
   \   00003C   EC           MOV     A,R4
   \   00003D   28           ADD     A,R0
   \   00003E   E4           CLR     A
   \   00003F   39           ADDC    A,R1
   \   000040   FD           MOV     R5,A
   \   000041   A8..         MOV     R0,?V0
   \   000043   E8           MOV     A,R0
   \   000044   28           ADD     A,R0
   \   000045   F8           MOV     R0,A
   \   000046   E4           CLR     A
   \   000047   33           RLC     A
   \   000048   F9           MOV     R1,A
   \   000049   EA           MOV     A,R2
   \   00004A   28           ADD     A,R0
   \   00004B   F582         MOV     DPL,A
   \   00004D   EB           MOV     A,R3
   \   00004E   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_435:
   \   000051   EC           MOV     A,R4
   \   000052   12....       LCALL   ??Subroutine189_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_398:
   \   000055   5001         JNC     ??zclParseInReadCmd_3
   \   000057   0F           INC     R7
   \                     ??zclParseInReadCmd_3:
   \   000058   05..         INC     ?V0
   \                     ??zclParseInReadCmd_1:
   \   00005A   8A82         MOV     DPL,R2
   \   00005C   8B83         MOV     DPH,R3
   \   00005E   12....       LCALL   ??Subroutine161_0 & 0xFFFF
   2833            }
   \                     ??CrossCallReturnLabel_262:
   \   000061   40CE         JC      ??zclParseInReadCmd_2
   2834          
   2835            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_0:
   \   000063   02....       LJMP    ?Subroutine1 & 0xFFFF
   2836          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine182_0
   \   000002                ; // Fall through to label ??Subroutine182_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine182_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine183_0
   \   000001                ; // Fall through to label ??Subroutine183_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   8582..       MOV     ?V0,DPL
   \   000008   8583..       MOV     ?V1,DPH
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   2401         ADD     A,#0x1
   \   00000E   FA           MOV     R2,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   3400         ADDC    A,#0x0
   \   000013   FB           MOV     R3,A
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine189_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   ED           MOV     A,R5
   \   000003   F0           MOVX    @DPTR,A
   \   000004   EE           MOV     A,R6
   \   000005   2402         ADD     A,#0x2
   \   000007   FE           MOV     R6,A
   \   000008   22           RET
   2837          
   2838          /*********************************************************************
   2839           * @fn      zclParseInReadRspCmd
   2840           *
   2841           * @brief   Parse the "Profile" Read Response Commands
   2842           *
   2843           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2844           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2845           *
   2846           * @param   pCmd - pointer to incoming data to parse
   2847           *
   2848           * @return  pointer to the parsed command structure
   2849           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2850          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2851          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V8,R2
   \   000007   8B..         MOV     ?V9,R3
   2852            zclReadRspCmd_t *readRspCmd;
   2853            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V4,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V9
   \   000011   F5..         MOV     ?V5,A
   \   000013   85..82       MOV     DPL,?V4
   \   000016   12....       LCALL   ?Subroutine72 & 0xFFFF
   2854            uint8 *dataPtr;
   2855            uint8 numAttr = 0;
   2856            uint8 hdrLen;
   2857            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_113:
   \   000019   803A         SJMP    ??zclParseInReadRspCmd_0
   2858            uint16 attrDataLen;
   2859          
   2860            // find out the number of attributes and the length of attribute data
   2861            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2862            {
   2863              uint8 status;
   2864          
   2865              numAttr++;
   \                     ??zclParseInReadRspCmd_1:
   \   00001B   05..         INC     ?V2
   2866              pBuf += 2; // move pass attribute id
   \   00001D   EE           MOV     A,R6
   \   00001E   2402         ADD     A,#0x2
   \   000020   FE           MOV     R6,A
   \   000021   5001         JNC     ??zclParseInReadRspCmd_2
   \   000023   0F           INC     R7
   2867          
   2868              status = *pBuf++;
   \                     ??zclParseInReadRspCmd_2:
   \   000024   8E82         MOV     DPL,R6
   \   000026   8F83         MOV     DPH,R7
   \   000028   E0           MOVX    A,@DPTR
   \   000029   A3           INC     DPTR
   \   00002A   AE82         MOV     R6,DPL
   \   00002C   AF83         MOV     R7,DPH
   2869              if ( status == ZCL_STATUS_SUCCESS )
   \   00002E   7025         JNZ     ??zclParseInReadRspCmd_0
   2870              {
   2871                uint8 dataType = *pBuf++;
   \   000030   E0           MOVX    A,@DPTR
   \   000031   F9           MOV     R1,A
   \   000032   A3           INC     DPTR
   \   000033   0E           INC     R6
   \   000034   AF83         MOV     R7,DPH
   2872          
   2873                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \   000036                ; Setup parameters for call to function zclGetAttrDataLength
   \   000036   EE           MOV     A,R6
   \   000037   FA           MOV     R2,A
   \   000038   EF           MOV     A,R7
   \   000039   FB           MOV     R3,A
   \   00003A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00003D   12....       LCALL   ?Subroutine107 & 0xFFFF
   2874                pBuf += attrDataLen; // move pass attribute data
   2875          
   2876                // add padding if needed
   2877                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_180:
   \   000040   5007         JNC     ??zclParseInReadRspCmd_3
   2878                {
   2879                  attrDataLen++;
   \   000042   05..         INC     ?V0
   \   000044   04           INC     A
   \   000045   7002         JNZ     ??zclParseInReadRspCmd_3
   \   000047   05..         INC     ?V1
   2880                }
   2881          
   2882                dataLen += attrDataLen;
   \                     ??zclParseInReadRspCmd_3:
   \   000049   E5..         MOV     A,?V6
   \   00004B   25..         ADD     A,?V0
   \   00004D   F5..         MOV     ?V6,A
   \   00004F   E5..         MOV     A,?V7
   \   000051   35..         ADDC    A,?V1
   \   000053   F5..         MOV     ?V7,A
   2883              }
   2884            }
   \                     ??zclParseInReadRspCmd_0:
   \   000055   85..82       MOV     DPL,?V8
   \   000058   85..83       MOV     DPH,?V9
   \   00005B   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_361:
   \   00005E   85..82       MOV     DPL,?V4
   \   000061   85..83       MOV     DPH,?V5
   \   000064   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_371:
   \   000067   40B2         JC      ??zclParseInReadRspCmd_1
   2885          
   2886            // calculate the length of the response header
   2887            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000069   75F006       MOV     B,#0x6
   \   00006C   12....       LCALL   ?Subroutine115 & 0xFFFF
   2888          
   2889            readRspCmd = (zclReadRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_351:
   \   00006F   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000072   8A..         MOV     ?V10,R2
   \   000074   8B..         MOV     ?V11,R3
   2890            if ( readRspCmd != NULL )
   \   000076   EA           MOV     A,R2
   \   000077   45..         ORL     A,?V11
   \   000079   7003         JNZ     $+5
   \   00007B   02....       LJMP    ??zclParseInReadRspCmd_4 & 0xFFFF
   2891            {
   2892              uint8 i;
   2893              pBuf = pCmd->pData;
   \   00007E   85..82       MOV     DPL,?V4
   \   000081   85..83       MOV     DPH,?V5
   \   000084   12....       LCALL   ??Subroutine187_0 & 0xFFFF
   2894              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_379:
   \   000087   F5..         MOV     ?V8,A
   \   000089   E4           CLR     A
   \   00008A   3B           ADDC    A,R3
   \   00008B   F5..         MOV     ?V9,A
   2895          
   2896              readRspCmd->numAttr = numAttr;
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   8B83         MOV     DPH,R3
   \   000091   E5..         MOV     A,?V2
   \   000093   F0           MOVX    @DPTR,A
   2897              for ( i = 0; i < numAttr; i++ )
   \   000094   75..00       MOV     ?V3,#0x0
   \   000097   8074         SJMP    ??zclParseInReadRspCmd_5
   2898              {
   2899                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_6:
   \   000099   E5..         MOV     A,?V3
   \   00009B   12....       LCALL   ?Subroutine12 & 0xFFFF
   2900          
   2901                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2902                pBuf += 2;
   \                     ??CrossCallReturnLabel_422:
   \   00009E   5001         JNC     ??zclParseInReadRspCmd_7
   \   0000A0   0F           INC     R7
   2903          
   2904                statusRec->status = *pBuf++;
   \                     ??zclParseInReadRspCmd_7:
   \   0000A1   8E82         MOV     DPL,R6
   \   0000A3   8F83         MOV     DPH,R7
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   85..82       MOV     DPL,?V12
   \   0000A9   85..83       MOV     DPH,?V13
   \   0000AC   A3           INC     DPTR
   \   0000AD   A3           INC     DPTR
   \   0000AE   12....       LCALL   ?Subroutine34 & 0xFFFF
   2905                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_38:
   \   0000B1   7058         JNZ     ??zclParseInReadRspCmd_8
   2906                {
   2907                  statusRec->dataType = *pBuf++;
   \   0000B3   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   0000B6   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   0000B9   0E           INC     R6
   \   0000BA   AF83         MOV     R7,DPH
   2908          
   2909                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   0000BC                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000BC   EE           MOV     A,R6
   \   0000BD   FA           MOV     R2,A
   \   0000BE   EF           MOV     A,R7
   \   0000BF   FB           MOV     R3,A
   \   0000C0   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000C3   8A..         MOV     ?V0,R2
   \   0000C5   8B..         MOV     ?V1,R3
   2910                  zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   0000C7                ; Setup parameters for call to function osal_memcpy
   \   0000C7   8E..         MOV     ?V4,R6
   \   0000C9   8F..         MOV     ?V5,R7
   \   0000CB   75..00       MOV     ?V6,#0x0
   \   0000CE   78..         MOV     R0,#?V4
   \   0000D0   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D3   AC..         MOV     R4,?V0
   \   0000D5   AD..         MOV     R5,?V1
   \   0000D7   AA..         MOV     R2,?V8
   \   0000D9   AB..         MOV     R3,?V9
   \   0000DB   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   0000DE   7403         MOV     A,#0x3
   \   0000E0   12....       LCALL   ?DEALLOC_XSTACK8
   2911                  statusRec->data = dataPtr;
   \   0000E3   85..82       MOV     DPL,?V12
   \   0000E6   85..83       MOV     DPH,?V13
   \   0000E9   A3           INC     DPTR
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   E5..         MOV     A,?V8
   \   0000EF   F0           MOVX    @DPTR,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   E5..         MOV     A,?V9
   \   0000F3   12....       LCALL   ??Subroutine184_0 & 0xFFFF
   2912          
   2913                  pBuf += attrDataLen; // move pass attribute data
   2914          
   2915                  // advance attribute data pointer
   2916                  if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_368:
   \   0000F6   5007         JNC     ??zclParseInReadRspCmd_9
   2917                  {
   2918                    attrDataLen++;
   \   0000F8   05..         INC     ?V0
   \   0000FA   04           INC     A
   \   0000FB   7002         JNZ     ??zclParseInReadRspCmd_9
   \   0000FD   05..         INC     ?V1
   2919                  }
   2920          
   2921                  dataPtr += attrDataLen;
   \                     ??zclParseInReadRspCmd_9:
   \   0000FF   E5..         MOV     A,?V8
   \   000101   25..         ADD     A,?V0
   \   000103   F5..         MOV     ?V8,A
   \   000105   E5..         MOV     A,?V9
   \   000107   35..         ADDC    A,?V1
   \   000109   F5..         MOV     ?V9,A
   2922                }
   2923              }
   \                     ??zclParseInReadRspCmd_8:
   \   00010B   05..         INC     ?V3
   \                     ??zclParseInReadRspCmd_5:
   \   00010D   E5..         MOV     A,?V3
   \   00010F   C3           CLR     C
   \   000110   95..         SUBB    A,?V2
   \   000112   4085         JC      ??zclParseInReadRspCmd_6
   2924            }
   2925          
   2926            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_4:
   \   000114                REQUIRE ?Subroutine8
   \   000114                ; // Fall through to label ?Subroutine8
   2927          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   AA..         MOV     R2,?V10
   \   000002   AB..         MOV     R3,?V11
   \   000004   7F0E         MOV     R7,#0xe
   \   000006   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine115:
   \   000000   E5..         MOV     A,?V2
   \   000002                REQUIRE ??Subroutine180_0
   \   000002                ; // Fall through to label ??Subroutine180_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine180_0:
   \   000000   A4           MUL     AB
   \   000001   04           INC     A
   \   000002   F5..         MOV     ?V8,A
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004                REQUIRE ??Subroutine181_0
   \   000004                ; // Fall through to label ??Subroutine181_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine181_0:
   \   000000   25..         ADD     A,?V6
   \   000002   FA           MOV     R2,A
   \   000003   E4           CLR     A
   \   000004   35..         ADDC    A,?V7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine107:
   \   000000   8A..         MOV     ?V0,R2
   \   000002   8B..         MOV     ?V1,R3
   \   000004   EE           MOV     A,R6
   \   000005   2A           ADD     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EF           MOV     A,R7
   \   000008   35..         ADDC    A,?V1
   \   00000A   FF           MOV     R7,A
   \   00000B   EA           MOV     A,R2
   \   00000C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine184_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EE           MOV     A,R6
   \   000002   25..         ADD     A,?V0
   \   000004   FE           MOV     R6,A
   \   000005   EF           MOV     A,R7
   \   000006   35..         ADDC    A,?V1
   \   000008   FF           MOV     R7,A
   \   000009   E5..         MOV     A,?V0
   \   00000B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine186_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   28           ADD     A,R0
   \   000002   F8           MOV     R0,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   39           ADDC    A,R1
   \   000006   F9           MOV     R1,A
   \   000007   C3           CLR     C
   \   000008   EE           MOV     A,R6
   \   000009   98           SUBB    A,R0
   \   00000A   EF           MOV     A,R7
   \   00000B   99           SUBB    A,R1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine187_0:
   \   000000   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_421:
   \   000003   EA           MOV     A,R2
   \   000004   25..         ADD     A,?V8
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   F583         MOV     DPH,A
   \   000002   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_415:
   \   000005   75..00       MOV     ?V2,#0x0
   \   000008   75..00       MOV     ?V6,#0x0
   \   00000B   75..00       MOV     ?V7,#0x0
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine193_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine141:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   85..82       MOV     DPL,?V12
   \   000005   85..83       MOV     DPH,?V13
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   75F006       MOV     B,#0x6
   \   000003                REQUIRE ??Subroutine194_0
   \   000003                ; // Fall through to label ??Subroutine194_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine194_0:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V10
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V11
   \   00000B   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_440:
   \   00000E   8582..       MOV     ?V12,DPL
   \   000011   8583..       MOV     ?V13,DPH
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   FA           MOV     R2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F9           MOV     R1,A
   \   00001D   EA           MOV     A,R2
   \   00001E   85..82       MOV     DPL,?V12
   \   000021   85..83       MOV     DPH,?V13
   \   000024                REQUIRE ??Subroutine195_0
   \   000024                ; // Fall through to label ??Subroutine195_0
   2928          #endif // ZCL_READ
   2929          
   2930          #ifdef ZCL_WRITE
   2931          /*********************************************************************
   2932           * @fn      zclParseInWriteCmd
   2933           *
   2934           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2935           *          Response Commands
   2936           *
   2937           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2938           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2939           *
   2940           * @param   pCmd - pointer to incoming data to parse
   2941           *
   2942           * @return  pointer to the parsed command structure
   2943           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2944          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2945          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   2946            zclWriteCmd_t *writeCmd;
   2947            uint8 *pBuf = pCmd->pData;
   2948            uint16 attrDataLen;
   2949            uint8 *dataPtr;
   2950            uint8 numAttr = 0;
   2951            uint8 hdrLen;
   2952            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_115:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_193
   2953          
   2954            // find out the number of attributes and the length of attribute data
   2955            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2956            {
   2957              uint8 dataType;
   2958          
   2959              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000A   05..         INC     ?V7
   2960              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInWriteCmd_1
   \   000012   0F           INC     R7
   2961          
   2962              dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_1:
   \   000013   12....       LCALL   ?Subroutine83 & 0xFFFF
   2963          
   2964              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_131:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine107 & 0xFFFF
   2965              pBuf += attrDataLen; // move pass attribute data
   2966          
   2967              // add padding if needed
   2968              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_181:
   \   00001C   5007         JNC     ??zclParseInWriteCmd_2
   2969              {
   2970                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInWriteCmd_2
   \   000023   05..         INC     ?V1
   2971              }
   2972          
   2973              dataLen += attrDataLen;
   \                     ??zclParseInWriteCmd_2:
   \   000025   12....       LCALL   ?Subroutine114 & 0xFFFF
   2974            }
   \                     ??CrossCallReturnLabel_193:
   \   000028   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_375:
   \   00002B   40DD         JC      ??zclParseInWriteCmd_0
   2975          
   2976            // calculate the length of the response header
   2977            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   00002D   75F006       MOV     B,#0x6
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   2978          
   2979            writeCmd = (zclWriteCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   2980            if ( writeCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   6049         JZ      ??zclParseInWriteCmd_3
   2981            {
   2982              uint8 i;
   2983              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine49 & 0xFFFF
   2984              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   2985          
   2986              writeCmd->numAttr = numAttr;
   2987              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_56:
   \   00004C   803D         SJMP    ??CrossCallReturnLabel_191
   2988              {
   2989                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_4:
   \   00004E   E5..         MOV     A,?V8
   \   000050   12....       LCALL   ?Subroutine12 & 0xFFFF
   2990          
   2991                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2992                pBuf += 2;
   \                     ??CrossCallReturnLabel_423:
   \   000053   5001         JNC     ??zclParseInWriteCmd_5
   \   000055   0F           INC     R7
   2993                statusRec->dataType = *pBuf++;
   \                     ??zclParseInWriteCmd_5:
   \   000056   12....       LCALL   ?Subroutine24 & 0xFFFF
   2994          
   2995                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_20:
   \   000059   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005C   8A..         MOV     ?V0,R2
   \   00005E   8B..         MOV     ?V1,R3
   2996                zcl_memcpy( dataPtr, pBuf, attrDataLen);
   \   000060                ; Setup parameters for call to function osal_memcpy
   \   000060   8E..         MOV     ?V4,R6
   \   000062   8F..         MOV     ?V5,R7
   \   000064   75..00       MOV     ?V6,#0x0
   \   000067   78..         MOV     R0,#?V4
   \   000069   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006C   AC..         MOV     R4,?V0
   \   00006E   AD..         MOV     R5,?V1
   \   000070   AA..         MOV     R2,?V2
   \   000072   AB..         MOV     R3,?V3
   \   000074   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   000077   7403         MOV     A,#0x3
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   2997                statusRec->attrData = dataPtr;
   \   00007C   12....       LCALL   ?Subroutine18 & 0xFFFF
   2998          
   2999                pBuf += attrDataLen; // move pass attribute data
   3000          
   3001                // advance attribute data pointer
   3002                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_366:
   \   00007F   5007         JNC     ??zclParseInWriteCmd_6
   3003                {
   3004                  attrDataLen++;
   \   000081   05..         INC     ?V0
   \   000083   04           INC     A
   \   000084   7002         JNZ     ??zclParseInWriteCmd_6
   \   000086   05..         INC     ?V1
   3005                }
   3006          
   3007                dataPtr += attrDataLen;
   \                     ??zclParseInWriteCmd_6:
   \   000088   12....       LCALL   ?Subroutine113 & 0xFFFF
   3008              }
   \                     ??CrossCallReturnLabel_191:
   \   00008B   E5..         MOV     A,?V8
   \   00008D   C3           CLR     C
   \   00008E   95..         SUBB    A,?V7
   \   000090   40BC         JC      ??zclParseInWriteCmd_4
   3009            }
   3010          
   3011            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_3:
   \   000092   02....       LJMP    ?Subroutine8 & 0xFFFF
   3012          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV     DPL,?V12
   \   000003   85..83       MOV     DPH,?V13
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   E5..         MOV     A,?V2
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   E5..         MOV     A,?V3
   \   00000F                REQUIRE ??Subroutine184_0
   \   00000F                ; // Fall through to label ??Subroutine184_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV     DPL,?V8
   \   000003   85..83       MOV     DPH,?V9
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine185_0
   \   000007                ; // Fall through to label ??Subroutine185_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine185_0:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_370:
   \   000003                REQUIRE ??Subroutine186_0
   \   000003                ; // Fall through to label ??Subroutine186_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine114:
   \   000000   E5..         MOV     A,?V4
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V4,A
   \   000006   E5..         MOV     A,?V5
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V5,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine113:
   \   000000   E5..         MOV     A,?V2
   \   000002   25..         ADD     A,?V0
   \   000004   F5..         MOV     ?V2,A
   \   000006   E5..         MOV     A,?V3
   \   000008   35..         ADDC    A,?V1
   \   00000A   F5..         MOV     ?V3,A
   \   00000C   05..         INC     ?V8
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   A3           INC     DPTR
   \   000007   AE82         MOV     R6,DPL
   \   000009   AF83         MOV     R7,DPH
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000B   EE           MOV     A,R6
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   8A..         MOV     ?V8,R2
   \   000002   8B..         MOV     ?V9,R3
   \   000004   EA           MOV     A,R2
   \   000005   2403         ADD     A,#0x3
   \   000007   F5..         MOV     ?V2,A
   \   000009   E4           CLR     A
   \   00000A   35..         ADDC    A,?V9
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   F583         MOV     DPH,A
   \   000013   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_416:
   \   000016   75..00       MOV     ?V7,#0x0
   \   000019   75..00       MOV     ?V4,#0x0
   \   00001C   75..00       MOV     ?V5,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   85..82       MOV     DPL,?V2
   \   000003   85..83       MOV     DPH,?V3
   \   000006   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_414:
   \   000009   85....       MOV     ?V0,?V6
   \   00000C   EA           MOV     A,R2
   \   00000D   25..         ADD     A,?V0
   \   00000F   F5..         MOV     ?V2,A
   \   000011   E4           CLR     A
   \   000012   3B           ADDC    A,R3
   \   000013   F5..         MOV     ?V3,A
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E5..         MOV     A,?V7
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   75..00       MOV     ?V8,#0x0
   \   00001F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine141 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   12....       LCALL   ?Subroutine117 & 0xFFFF
   \                     ??CrossCallReturnLabel_410:
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C                ; Setup parameters for call to function zclGetAttrDataLength
   \   00000C   EE           MOV     A,R6
   \   00000D   FA           MOV     R2,A
   \   00000E   EF           MOV     A,R7
   \   00000F   FB           MOV     R3,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine131:
   \   000000   12....       LCALL   ?Subroutine152 & 0xFFFF
   \                     ??CrossCallReturnLabel_395:
   \   000003   F9           MOV     R1,A
   \   000004   85..82       MOV     DPL,?V2
   \   000007   85..83       MOV     DPH,?V3
   \   00000A   22           RET
   3013          
   3014          /*********************************************************************
   3015           * @fn      zclParseInWriteRspCmd
   3016           *
   3017           * @brief   Parse the "Profile" Write Response Commands
   3018           *
   3019           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3020           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3021           *
   3022           * @param   pCmd - pointer to incoming data to parse
   3023           *
   3024           * @return  pointer to the parsed command structure
   3025           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3026          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   3027          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   3028            zclWriteRspCmd_t *writeRspCmd;
   3029            uint8 *pBuf = pCmd->pData;
   \   000005   EA           MOV     A,R2
   \   000006   2403         ADD     A,#0x3
   \   000008   F5..         MOV     ?V2,A
   \   00000A   E4           CLR     A
   \   00000B   3B           ADDC    A,R3
   \   00000C   F5..         MOV     ?V3,A
   \   00000E   85..82       MOV     DPL,?V2
   \   000011   12....       LCALL   ?Subroutine102 & 0xFFFF
   3030            uint8 i = 0;
   3031          
   3032            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \                     ??CrossCallReturnLabel_168:
   \   000014   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   000017   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3033            if ( writeRspCmd != NULL )
   \   00001A   EA           MOV     A,R2
   \   00001B   4B           ORL     A,R3
   \   00001C   604A         JZ      ??zclParseInWriteRspCmd_0
   3034            {
   3035              if ( pCmd->dataLen == 1 )
   \   00001E   85..82       MOV     DPL,?V0
   \   000021   85..83       MOV     DPH,?V1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6401         XRL     A,#0x1
   \   000027   7002         JNZ     ??zclParseInWriteRspCmd_1
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \                     ??zclParseInWriteRspCmd_1:
   \   00002B   7029         JNZ     ??zclParseInWriteRspCmd_2
   3036              {
   3037                // special case when all writes were successfull
   3038                writeRspCmd->attrList[i++].status = *pBuf;
   \   00002D   12....       LCALL   ?Subroutine97 & 0xFFFF
   3039              }
   \                     ??CrossCallReturnLabel_444:
   \   000030   A3           INC     DPTR
   \   000031   F0           MOVX    @DPTR,A
   \   000032   75..01       MOV     ?V4,#0x1
   \   000035   802A         SJMP    ??zclParseInWriteRspCmd_3
   3040              else
   3041              {
   3042                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3043                {
   3044                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_4:
   \   000037   E5..         MOV     A,?V4
   \   000039   12....       LCALL   ?Subroutine13 & 0xFFFF
   3045                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_403:
   \   00003C   F5..         MOV     ?V6,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FD           MOV     R5,A
   \   000041   E5..         MOV     A,?V6
   \   000043   8882         MOV     DPL,R0
   \   000045   8983         MOV     DPH,R1
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   ED           MOV     A,R5
   \   00004C   F0           MOVX    @DPTR,A
   \   00004D   05..         INC     ?V4
   3046                  pBuf += 2;
   \   00004F   EE           MOV     A,R6
   \   000050   2402         ADD     A,#0x2
   \   000052   FE           MOV     R6,A
   \   000053   5001         JNC     ??zclParseInWriteRspCmd_2
   \   000055   0F           INC     R7
   3047                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000056   85..82       MOV     DPL,?V0
   \   000059   85..83       MOV     DPH,?V1
   \   00005C   12....       LCALL   ??Subroutine185_0 & 0xFFFF
   3048              }
   \                     ??CrossCallReturnLabel_374:
   \   00005F   40D6         JC      ??zclParseInWriteRspCmd_4
   3049          
   3050              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   000061   8A82         MOV     DPL,R2
   \   000063   8B83         MOV     DPH,R3
   \   000065   E5..         MOV     A,?V4
   \   000067   F0           MOVX    @DPTR,A
   3051            }
   3052          
   3053            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_0:
   \   000068   02....       LJMP    ?Subroutine6 & 0xFFFF
   3054          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   75F003       MOV     B,#0x3
   \   000003   A4           MUL     AB
   \   000004   F8           MOV     R0,A
   \   000005   A9F0         MOV     R1,B
   \   000007   EA           MOV     A,R2
   \   000008   28           ADD     A,R0
   \   000009   F8           MOV     R0,A
   \   00000A   EB           MOV     A,R3
   \   00000B   39           ADDC    A,R1
   \   00000C                REQUIRE ??Subroutine190_0
   \   00000C                ; // Fall through to label ??Subroutine190_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine190_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine151 & 0xFFFF
   \                     ??CrossCallReturnLabel_402:
   \   000008                REQUIRE ??Subroutine191_0
   \   000008                ; // Fall through to label ??Subroutine191_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F583         MOV     DPH,A
   \   000002   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_418:
   \   000005   75..00       MOV     ?V4,#0x0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine197_0
   \   000004                ; // Fall through to label ??Subroutine197_0
   3055          #endif // ZCL_WRITE
   3056          
   3057          #ifdef ZCL_REPORT
   3058          /*********************************************************************
   3059           * @fn      zclParseInConfigReportCmd
   3060           *
   3061           * @brief   Parse the "Profile" Configure Reporting Command
   3062           *
   3063           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3064           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3065           *
   3066           * @param   pCmd - pointer to incoming data to parse
   3067           *
   3068           * @return  pointer to the parsed command structure
   3069           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   AA..         MOV     R2,?V6
   \   000002   AB..         MOV     R3,?V7
   \   000004                REQUIRE ??Subroutine160_0
   \   000004                ; // Fall through to label ??Subroutine160_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3070          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   3071          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V4,R2
   \   000007   8B..         MOV     ?V5,R3
   3072            zclCfgReportCmd_t *cfgReportCmd;
   3073            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V5
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine72 & 0xFFFF
   3074            uint8 *dataPtr;
   3075            uint8 numAttr = 0;
   3076            uint8 dataType;
   3077            uint8 hdrLen;
   3078            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_114:
   \   000019   8007         SJMP    ??zclParseInConfigReportCmd_0
   3079            uint8 reportChangeLen; // length of Reportable Change field
   3080          
   3081            // Calculate the length of the Request command
   3082            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3083            {
   3084              uint8 direction;
   3085          
   3086              numAttr++;
   3087              direction = *pBuf++;
   3088              pBuf += 2; // move pass the attribute ID
   3089          
   3090              // Is there a Reportable Change field?
   3091              if ( direction == ZCL_SEND_ATTR_REPORTS )
   3092              {
   3093                dataType = *pBuf++;
   3094                pBuf += 4; // move pass the Min and Max Reporting Intervals
   3095          
   3096                // For attributes of 'discrete' data types this field is omitted
   3097                if ( zclAnalogDataType( dataType ) )
   3098                {
   3099                  reportChangeLen = zclGetDataTypeLength( dataType );
   3100                  pBuf += reportChangeLen;
   3101          
   3102                  // add padding if needed
   3103                  if ( PADDING_NEEDED( reportChangeLen ) )
   3104                  {
   3105                    reportChangeLen++;
   3106                  }
   3107          
   3108                  dataLen += reportChangeLen;
   3109                }
   3110                else
   3111                {
   3112                  pBuf++; // move past reportable change field
   3113                }
   3114              }
   3115              else
   3116              {
   3117                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_1:
   \   00001B   EE           MOV     A,R6
   \   00001C   2402         ADD     A,#0x2
   \   00001E   FE           MOV     R6,A
   \   00001F   5001         JNC     ??zclParseInConfigReportCmd_0
   \   000021   0F           INC     R7
   3118              }
   \                     ??zclParseInConfigReportCmd_0:
   \   000022   85..82       MOV     DPL,?V4
   \   000025   85..83       MOV     DPH,?V5
   \   000028   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_381:
   \   00002B   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_372:
   \   00002E   504B         JNC     ??zclParseInConfigReportCmd_2
   \   000030   05..         INC     ?V2
   \   000032   8E82         MOV     DPL,R6
   \   000034   8F83         MOV     DPH,R7
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F8           MOV     R0,A
   \   000038   A3           INC     DPTR
   \   000039   AF83         MOV     R7,DPH
   \   00003B   E582         MOV     A,DPL
   \   00003D   2402         ADD     A,#0x2
   \   00003F   FE           MOV     R6,A
   \   000040   5001         JNC     ??zclParseInConfigReportCmd_3
   \   000042   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_3:
   \   000043   E8           MOV     A,R0
   \   000044   70D5         JNZ     ??zclParseInConfigReportCmd_1
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5..         MOV     ?V3,A
   \   00004D   A3           INC     DPTR
   \   00004E   AF83         MOV     R7,DPH
   \   000050   E582         MOV     A,DPL
   \   000052   2404         ADD     A,#0x4
   \   000054   FE           MOV     R6,A
   \   000055   5001         JNC     ??zclParseInConfigReportCmd_4
   \   000057   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_4:
   \   000058                ; Setup parameters for call to function zclAnalogDataType
   \   000058   A9..         MOV     R1,?V3
   \   00005A   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00005D   E9           MOV     A,R1
   \   00005E   6011         JZ      ??zclParseInConfigReportCmd_5
   \   000060                ; Setup parameters for call to function zclGetDataTypeLength
   \   000060   A9..         MOV     R1,?V3
   \   000062   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   000065   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   000068   5002         JNC     ??zclParseInConfigReportCmd_6
   \   00006A   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_6:
   \   00006C   12....       LCALL   ?Subroutine112 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   00006F   80B1         SJMP    ??zclParseInConfigReportCmd_0
   \                     ??zclParseInConfigReportCmd_5:
   \   000071   8E82         MOV     DPL,R6
   \   000073   8F83         MOV     DPH,R7
   \   000075   A3           INC     DPTR
   \   000076   0E           INC     R6
   \   000077   AF83         MOV     R7,DPH
   \   000079   80A7         SJMP    ??zclParseInConfigReportCmd_0
   3119            } // while loop
   3120          
   3121            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_2:
   \   00007B   75F00C       MOV     B,#0xc
   \   00007E   12....       LCALL   ?Subroutine115 & 0xFFFF
   3122          
   3123            cfgReportCmd = (zclCfgReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_352:
   \   000081   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000084   8A..         MOV     ?V6,R2
   \   000086   8B..         MOV     ?V7,R3
   3124            if ( cfgReportCmd != NULL )
   \   000088   EA           MOV     A,R2
   \   000089   45..         ORL     A,?V7
   \   00008B   7003         JNZ     $+5
   \   00008D   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   3125            {
   3126              uint8 i;
   3127              pBuf = pCmd->pData;
   \   000090   12....       LCALL   ?Subroutine78 & 0xFFFF
   3128              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   \                     ??CrossCallReturnLabel_377:
   \   000093   F5..         MOV     ?V4,A
   \   000095   E4           CLR     A
   \   000096   3B           ADDC    A,R3
   \   000097   F5..         MOV     ?V5,A
   3129          
   3130              cfgReportCmd->numAttr = numAttr;
   \   000099   8A82         MOV     DPL,R2
   \   00009B   8B83         MOV     DPH,R3
   \   00009D   E5..         MOV     A,?V2
   \   00009F   F0           MOVX    @DPTR,A
   3131              for ( i = 0; i < numAttr; i++ )
   \   0000A0   75..00       MOV     ?V3,#0x0
   \   0000A3   800B         SJMP    ??zclParseInConfigReportCmd_8
   3132              {
   3133                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   3134          
   3135                zcl_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   3136          
   3137                reportRec->direction = *pBuf++;
   3138                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3139                pBuf += 2;
   3140                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   3141                {
   3142                  // Attribute to be reported
   3143                  reportRec->dataType = *pBuf++;
   3144                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3145                  pBuf += 2;
   3146                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3147                  pBuf += 2;
   3148          
   3149                  // For attributes of 'discrete' data types this field is omitted
   3150                  if ( zclAnalogDataType( reportRec->dataType ) )
   3151                  {
   3152                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   3153                    reportRec->reportableChange = dataPtr;
   3154          
   3155                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   3156                    pBuf += reportChangeLen;
   3157          
   3158                    // advance attribute data pointer
   3159                    if ( PADDING_NEEDED( reportChangeLen ) )
   3160                    {
   3161                      reportChangeLen++;
   3162                    }
   3163          
   3164                    dataPtr += reportChangeLen;
   3165                  }
   3166                }
   3167                else
   3168                {
   3169                  // Attribute reports to be received
   3170                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_9:
   \   0000A5   12....       LCALL   ?Subroutine62 & 0xFFFF
   3171                  pBuf += 2;
   3172                }
   \                     ??CrossCallReturnLabel_89:
   \   0000A8   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_426:
   \   0000AB   5001         JNC     ??zclParseInConfigReportCmd_10
   \   0000AD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_10:
   \   0000AE   05..         INC     ?V3
   \                     ??zclParseInConfigReportCmd_8:
   \   0000B0   E5..         MOV     A,?V3
   \   0000B2   C3           CLR     C
   \   0000B3   95..         SUBB    A,?V2
   \   0000B5   4003         JC      $+5
   \   0000B7   02....       LJMP    ??zclParseInConfigReportCmd_7 & 0xFFFF
   \   0000BA   E5..         MOV     A,?V3
   \   0000BC   75F00C       MOV     B,#0xc
   \   0000BF   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   0000C2                ; Setup parameters for call to function osal_memset
   \   0000C2   7C0C         MOV     R4,#0xc
   \   0000C4   7D00         MOV     R5,#0x0
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   AA..         MOV     R2,?V0
   \   0000CA   AB..         MOV     R3,?V1
   \   0000CC   12....       LCALL   ??osal_memset?relay  ; Banked call to: osal_memset
   \   0000CF   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   0000D2   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_407:
   \   0000D5   12....       LCALL   ?Subroutine134 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   0000D8   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_427:
   \   0000DB   5001         JNC     ??zclParseInConfigReportCmd_11
   \   0000DD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_11:
   \   0000DE   8E82         MOV     DPL,R6
   \   0000E0   8F83         MOV     DPH,R7
   \   0000E2   A3           INC     DPTR
   \   0000E3   A882         MOV     R0,DPL
   \   0000E5   A983         MOV     R1,DPH
   \   0000E7   8E82         MOV     DPL,R6
   \   0000E9   8F83         MOV     DPH,R7
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   F5..         MOV     ?V10,A
   \   0000EE   EC           MOV     A,R4
   \   0000EF   70B4         JNZ     ??zclParseInConfigReportCmd_9
   \   0000F1   E5..         MOV     A,?V0
   \   0000F3   2403         ADD     A,#0x3
   \   0000F5   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000F8   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_428:
   \   0000FB   5001         JNC     ??zclParseInConfigReportCmd_12
   \   0000FD   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_12:
   \   0000FE   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000101   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_429:
   \   000104   5001         JNC     ??zclParseInConfigReportCmd_13
   \   000106   0F           INC     R7
   \                     ??zclParseInConfigReportCmd_13:
   \   000107                ; Setup parameters for call to function zclAnalogDataType
   \   000107   A9..         MOV     R1,?V10
   \   000109   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   00010C   E9           MOV     A,R1
   \   00010D   609F         JZ      ??zclParseInConfigReportCmd_10
   \   00010F                ; Setup parameters for call to function zcl_BuildAnalogData
   \   00010F   EE           MOV     A,R6
   \   000110   FC           MOV     R4,A
   \   000111   EF           MOV     A,R7
   \   000112   FD           MOV     R5,A
   \   000113   AA..         MOV     R2,?V4
   \   000115   AB..         MOV     R3,?V5
   \   000117   85..82       MOV     DPL,?V8
   \   00011A   85..83       MOV     DPH,?V9
   \   00011D   E0           MOVX    A,@DPTR
   \   00011E   F9           MOV     R1,A
   \   00011F   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000122   85..82       MOV     DPL,?V0
   \   000125   85..83       MOV     DPH,?V1
   \   000128   A3           INC     DPTR
   \   000129   A3           INC     DPTR
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   A3           INC     DPTR
   \   00012D   A3           INC     DPTR
   \   00012E   A3           INC     DPTR
   \   00012F   A3           INC     DPTR
   \   000130   A3           INC     DPTR
   \   000131   A3           INC     DPTR
   \   000132   E5..         MOV     A,?V4
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V5
   \   000138   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000141   5002         JNC     ??zclParseInConfigReportCmd_14
   \   000143   05..         INC     ?V10
   \                     ??zclParseInConfigReportCmd_14:
   \   000145   E5..         MOV     A,?V4
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V4,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V5
   \   00014E   F5..         MOV     ?V5,A
   \   000150   02....       LJMP    ??zclParseInConfigReportCmd_10 & 0xFFFF
   3173              } // while loop
   3174            }
   3175          
   3176            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_7:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3177          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   85..82       MOV     DPL,?V0
   \   000003   85..83       MOV     DPH,?V1
   \   000006                REQUIRE ??Subroutine187_0
   \   000006                ; // Fall through to label ??Subroutine187_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine188_0
   \   000001                ; // Fall through to label ??Subroutine188_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine188_0:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_389:
   \   000003   85..82       MOV     DPL,?V0
   \   000006   85..83       MOV     DPH,?V1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine112:
   \   000000   E5..         MOV     A,?V6
   \   000002   25..         ADD     A,?V10
   \   000004   F5..         MOV     ?V6,A
   \   000006   E4           CLR     A
   \   000007   35..         ADDC    A,?V7
   \   000009   F5..         MOV     ?V7,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine108:
   \   000000   A4           MUL     AB
   \   000001   F8           MOV     R0,A
   \   000002   A9F0         MOV     R1,B
   \   000004   E5..         MOV     A,?V6
   \   000006   28           ADD     A,R0
   \   000007   F582         MOV     DPL,A
   \   000009   E5..         MOV     A,?V7
   \   00000B   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_437:
   \   00000E   8582..       MOV     ?V0,DPL
   \   000011   8583..       MOV     ?V1,DPH
   \   000014   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   E9           MOV     A,R1
   \   000001   F5..         MOV     ?V10,A
   \   000003   EE           MOV     A,R6
   \   000004   29           ADD     A,R1
   \   000005   FE           MOV     R6,A
   \   000006   E4           CLR     A
   \   000007   3F           ADDC    A,R7
   \   000008   FF           MOV     R7,A
   \   000009   E9           MOV     A,R1
   \   00000A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   FC           MOV     R4,A
   \   000006   85..82       MOV     DPL,?V0
   \   000009   85..83       MOV     DPH,?V1
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F9           MOV     R1,A
   \   000006   E5..         MOV     A,?V10
   \   000008   85..82       MOV     DPL,?V0
   \   00000B   85..83       MOV     DPH,?V1
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   A3           INC     DPTR
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001                ; Setup parameters for call to function zclGetDataTypeLength
   \   000001   85..82       MOV     DPL,?V8
   \   000004   85..83       MOV     DPH,?V9
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F9           MOV     R1,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F5..         MOV     ?V8,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V1
   \   000005   F5..         MOV     ?V9,A
   \   000007   85..82       MOV     DPL,?V8
   \   00000A   F583         MOV     DPH,A
   \   00000C   E5..         MOV     A,?V10
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   0E           INC     R6
   \   000010   E9           MOV     A,R1
   \   000011   FF           MOV     R7,A
   \   000012   12....       LCALL   ?Subroutine126 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000015   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine126:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   E0           MOVX    A,@DPTR
   \   000005   12....       LCALL   ?Subroutine149 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET
   3178          
   3179          /*********************************************************************
   3180           * @fn      zclParseInConfigReportRspCmd
   3181           *
   3182           * @brief   Parse the "Profile" Configure Reporting Response Command
   3183           *
   3184           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3185           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3186           *
   3187           * @param   pCmd - pointer to incoming data to parse
   3188           *
   3189           * @return  pointer to the parsed command structure
   3190           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3191          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3192          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   3193            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3194            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine87 & 0xFFFF
   3195            uint8 numAttr;
   3196          
   3197            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \                     ??CrossCallReturnLabel_140:
   \   000008   F5..         MOV     ?V0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F5..         MOV     ?V1,A
   \   00000E   7402         MOV     A,#0x2
   \   000010   78..         MOV     R0,#?V0
   \   000012   12....       LCALL   ?US_SHR
   \   000015   E5..         MOV     A,?V0
   \   000017   F5..         MOV     ?V2,A
   3198          
   3199            cfgReportRspCmd = (zclCfgReportRspCmd_t *)zcl_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3200                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   000019                ; Setup parameters for call to function osal_mem_alloc
   \   000019   75..00       MOV     ?V1,#0x0
   \   00001C   7402         MOV     A,#0x2
   \   00001E   78..         MOV     R0,#?V0
   \   000020   12....       LCALL   ?S_SHL
   \   000023   E5..         MOV     A,?V0
   \   000025   2401         ADD     A,#0x1
   \   000027   FA           MOV     R2,A
   \   000028   E4           CLR     A
   \   000029   35..         ADDC    A,?V1
   \   00002B   FB           MOV     R3,A
   \   00002C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3201            if ( cfgReportRspCmd != NULL )
   \   00002F   EA           MOV     A,R2
   \   000030   4B           ORL     A,R3
   \   000031   6040         JZ      ??zclParseInConfigReportRspCmd_0
   3202            {
   3203              uint8 i;
   3204              cfgReportRspCmd->numAttr = numAttr;
   \   000033   8A82         MOV     DPL,R2
   \   000035   8B83         MOV     DPH,R3
   \   000037   E5..         MOV     A,?V2
   \   000039   F0           MOVX    @DPTR,A
   3205              for ( i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   00003A   75..00       MOV     ?V2,#0x0
   \   00003D   802B         SJMP    ??zclParseInConfigReportRspCmd_1
   3206              {
   3207                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_2:
   \   00003F   85....       MOV     ?V0,?V2
   \   000042   75..00       MOV     ?V1,#0x0
   \   000045   7402         MOV     A,#0x2
   \   000047   78..         MOV     R0,#?V0
   \   000049   12....       LCALL   ?S_SHL
   \   00004C   EA           MOV     A,R2
   \   00004D   25..         ADD     A,?V0
   \   00004F   F8           MOV     R0,A
   \   000050   EB           MOV     A,R3
   \   000051   35..         ADDC    A,?V1
   \   000053   12....       LCALL   ??Subroutine190_0 & 0xFFFF
   3208                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3209                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3210                pBuf += 2;
   3211              }
   \                     ??CrossCallReturnLabel_405:
   \   000056   8882         MOV     DPL,R0
   \   000058   8983         MOV     DPH,R1
   \   00005A   A3           INC     DPTR
   \   00005B   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   00005E   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   000061   A3           INC     DPTR
   \   000062   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_396:
   \   000065   5001         JNC     ??zclParseInConfigReportRspCmd_3
   \   000067   0F           INC     R7
   \                     ??zclParseInConfigReportRspCmd_3:
   \   000068   05..         INC     ?V2
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00006A   8A82         MOV     DPL,R2
   \   00006C   8B83         MOV     DPH,R3
   \   00006E   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   3212            }
   \                     ??CrossCallReturnLabel_254:
   \   000071   40CC         JC      ??zclParseInConfigReportRspCmd_2
   3213          
   3214            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_0:
   \   000073   7F03         MOV     R7,#0x3
   \   000075   02....       LJMP    ?BANKED_LEAVE_XDATA
   3215          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine189_0
   \   000002                ; // Fall through to label ??Subroutine189_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   F5..         MOV     ?V0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   E5..         MOV     A,?V0
   \   000007   8882         MOV     DPL,R0
   \   000009   8983         MOV     DPH,R1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   12....       LCALL   ?Subroutine124 & 0xFFFF
   \                     ??CrossCallReturnLabel_420:
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   A3           INC     DPTR
   \   000001   12....       LCALL   ?Subroutine122 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   000004   A3           INC     DPTR
   \   000005   0E           INC     R6
   \   000006   AF83         MOV     R7,DPH
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine124:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007                REQUIRE ??Subroutine193_0
   \   000007                ; // Fall through to label ??Subroutine193_0
   3216          
   3217          /*********************************************************************
   3218           * @fn      zclParseInReadReportCfgCmd
   3219           *
   3220           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3221           *
   3222           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3223           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3224           *
   3225           * @param   pCmd - pointer to incoming data to parse
   3226           *
   3227           * @return  pointer to the parsed command structure
   3228           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3229          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3230          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3231            zclReadReportCfgCmd_t *readReportCfgCmd;
   3232            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine87 & 0xFFFF
   3233            uint8 numAttr;
   3234          
   3235            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \                     ??CrossCallReturnLabel_141:
   \   000008   F8           MOV     R0,A
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   7A03         MOV     R2,#0x3
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   12....       LCALL   ?US_DIV_MOD
   \   000013   E8           MOV     A,R0
   \   000014   F5..         MOV     ?V0,A
   3236          
   3237            readReportCfgCmd = (zclReadReportCfgCmd_t *)zcl_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3238                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_465:
   \   000019   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3239            if ( readReportCfgCmd != NULL )
   \   00001C   EA           MOV     A,R2
   \   00001D   4B           ORL     A,R3
   \   00001E   6025         JZ      ??zclParseInReadReportCfgCmd_0
   3240            {
   3241              uint8 i;
   3242              readReportCfgCmd->numAttr = numAttr;
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E5..         MOV     A,?V0
   \   000026   F0           MOVX    @DPTR,A
   3243              for ( i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000027   75..00       MOV     ?V2,#0x0
   \   00002A   8010         SJMP    ??zclParseInReadReportCfgCmd_1
   3244              {
   3245                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002C   E5..         MOV     A,?V2
   \   00002E   12....       LCALL   ?Subroutine13 & 0xFFFF
   3246                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3247                pBuf += 2;
   3248              }
   \                     ??CrossCallReturnLabel_404:
   \   000031   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000034   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_397:
   \   000037   5001         JNC     ??zclParseInReadReportCfgCmd_3
   \   000039   0F           INC     R7
   \                     ??zclParseInReadReportCfgCmd_3:
   \   00003A   05..         INC     ?V2
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00003C   8A82         MOV     DPL,R2
   \   00003E   8B83         MOV     DPH,R3
   \   000040   12....       LCALL   ??Subroutine159_0 & 0xFFFF
   3249            }
   \                     ??CrossCallReturnLabel_255:
   \   000043   40E7         JC      ??zclParseInReadReportCfgCmd_2
   3250          
   3251            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000045   02....       LJMP    ?Subroutine1 & 0xFFFF
   3252          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine111:
   \   000000   75F003       MOV     B,#0x3
   \   000003                REQUIRE ??Subroutine199_0
   \   000003                ; // Fall through to label ??Subroutine199_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine199_0:
   \   000000   A4           MUL     AB
   \   000001   A9F0         MOV     R1,B
   \   000003   2401         ADD     A,#0x1
   \   000005   FA           MOV     R2,A
   \   000006   E4           CLR     A
   \   000007   39           ADDC    A,R1
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3253          
   3254          /*********************************************************************
   3255           * @fn      zclParseInReadReportCfgRspCmd
   3256           *
   3257           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3258           *
   3259           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3260           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3261           *
   3262           * @param   pCmd - pointer to incoming data to parse
   3263           *
   3264           * @return  pointer to the parsed command structure
   3265           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3266          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3267          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   3268            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3269            uint8 reportChangeLen;
   3270            uint8 *pBuf = pCmd->pData;
   \   000009   EA           MOV     A,R2
   \   00000A   2403         ADD     A,#0x3
   \   00000C   F5..         MOV     ?V0,A
   \   00000E   E4           CLR     A
   \   00000F   35..         ADDC    A,?V3
   \   000011   F5..         MOV     ?V1,A
   \   000013   85..82       MOV     DPL,?V0
   \   000016   12....       LCALL   ?Subroutine102 & 0xFFFF
   3271            uint8 *dataPtr;
   3272            uint8 numAttr = 0;
   3273            uint8 hdrLen;
   3274            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_169:
   \   000019   75..00       MOV     ?V6,#0x0
   \   00001C   75..00       MOV     ?V7,#0x0
   \   00001F   8007         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3275          
   3276            // Calculate the length of the response command
   3277            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3278            {
   3279              uint8 status;
   3280              uint8 direction;
   3281          
   3282              numAttr++;
   3283              status = *pBuf++;
   3284              direction = *pBuf++;
   3285              pBuf += 2; // move pass the attribute ID
   3286          
   3287              if ( status == ZCL_STATUS_SUCCESS )
   3288              {
   3289                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3290                {
   3291                  uint8 dataType = *pBuf++;
   3292                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3293          
   3294                  // For attributes of 'discrete' data types this field is omitted
   3295                  if ( zclAnalogDataType( dataType ) )
   3296                  {
   3297                    reportChangeLen = zclGetDataTypeLength( dataType );
   3298                    pBuf += reportChangeLen;
   3299          
   3300                    // add padding if needed
   3301                    if ( PADDING_NEEDED( reportChangeLen ) )
   3302                    {
   3303                      reportChangeLen++;
   3304                    }
   3305          
   3306                    dataLen += reportChangeLen;
   3307                  }
   3308                }
   3309                else
   3310                {
   3311                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   000021   EE           MOV     A,R6
   \   000022   2402         ADD     A,#0x2
   \   000024   FE           MOV     R6,A
   \   000025   5001         JNC     ??zclParseInReadReportCfgRspCmd_0
   \   000027   0F           INC     R7
   3312                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   000028   85..82       MOV     DPL,?V2
   \   00002B   85..83       MOV     DPH,?V3
   \   00002E   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_382:
   \   000031   12....       LCALL   ??Subroutine186_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_373:
   \   000034   5045         JNC     ??zclParseInReadReportCfgRspCmd_2
   \   000036   05..         INC     ?V4
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_355:
   \   00003F   A3           INC     DPTR
   \   000040   AF83         MOV     R7,DPH
   \   000042   E582         MOV     A,DPL
   \   000044   2402         ADD     A,#0x2
   \   000046   FE           MOV     R6,A
   \   000047   5001         JNC     ??zclParseInReadReportCfgRspCmd_3
   \   000049   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   00004A   E8           MOV     A,R0
   \   00004B   70DB         JNZ     ??zclParseInReadReportCfgRspCmd_0
   \   00004D   E9           MOV     A,R1
   \   00004E   70D1         JNZ     ??zclParseInReadReportCfgRspCmd_1
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F5..         MOV     ?V5,A
   \   000057   A3           INC     DPTR
   \   000058   AF83         MOV     R7,DPH
   \   00005A   E582         MOV     A,DPL
   \   00005C   2404         ADD     A,#0x4
   \   00005E   FE           MOV     R6,A
   \   00005F   5001         JNC     ??zclParseInReadReportCfgRspCmd_4
   \   000061   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_4:
   \   000062                ; Setup parameters for call to function zclAnalogDataType
   \   000062   A9..         MOV     R1,?V5
   \   000064   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000067   E9           MOV     A,R1
   \   000068   60BE         JZ      ??zclParseInReadReportCfgRspCmd_0
   \   00006A                ; Setup parameters for call to function zclGetDataTypeLength
   \   00006A   A9..         MOV     R1,?V5
   \   00006C   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00006F   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000072   5002         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   000074   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   000076   12....       LCALL   ?Subroutine112 & 0xFFFF
   3313              }
   3314            } // while loop
   \                     ??CrossCallReturnLabel_190:
   \   000079   80AD         SJMP    ??zclParseInReadReportCfgRspCmd_0
   3315          
   3316            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   00007B   75F00D       MOV     B,#0xd
   \   00007E   E5..         MOV     A,?V4
   \   000080   12....       LCALL   ??Subroutine180_0 & 0xFFFF
   3317          
   3318            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \                     ??CrossCallReturnLabel_353:
   \   000083   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000086   8A..         MOV     ?V6,R2
   \   000088   8B..         MOV     ?V7,R3
   3319            if ( readReportCfgRspCmd != NULL )
   \   00008A   EA           MOV     A,R2
   \   00008B   45..         ORL     A,?V7
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   3320            {
   3321              uint8 i;
   3322              pBuf = pCmd->pData;
   \   000092   12....       LCALL   ?Subroutine78 & 0xFFFF
   3323              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   \                     ??CrossCallReturnLabel_378:
   \   000095   F5..         MOV     ?V2,A
   \   000097   E4           CLR     A
   \   000098   3B           ADDC    A,R3
   \   000099   F5..         MOV     ?V3,A
   3324          
   3325              readReportCfgRspCmd->numAttr = numAttr;
   \   00009B   8A82         MOV     DPL,R2
   \   00009D   8B83         MOV     DPH,R3
   \   00009F   E5..         MOV     A,?V4
   \   0000A1   F0           MOVX    @DPTR,A
   3326              for ( i = 0; i < numAttr; i++ )
   \   0000A2   75..00       MOV     ?V5,#0x0
   \   0000A5   800C         SJMP    ??zclParseInReadReportCfgRspCmd_7
   3327              {
   3328                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3329          
   3330                reportRspRec->status = *pBuf++;
   3331                reportRspRec->direction = *pBuf++;
   3332                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3333                pBuf += 2;
   3334          
   3335                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3336                {
   3337                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3338                  {
   3339                    reportRspRec->dataType = *pBuf++;
   3340                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3341                    pBuf += 2;
   3342                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3343                    pBuf += 2;
   3344          
   3345                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3346                    {
   3347                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3348                      reportRspRec->reportableChange = dataPtr;
   3349          
   3350                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3351                      pBuf += reportChangeLen;
   3352          
   3353                      // advance attribute data pointer
   3354                      if ( PADDING_NEEDED( reportChangeLen ) )
   3355                      {
   3356                        reportChangeLen++;
   3357                      }
   3358          
   3359                      dataPtr += reportChangeLen;
   3360                    }
   3361                  }
   3362                  else
   3363                  {
   3364                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   0000A7   12....       LCALL   ?Subroutine62 & 0xFFFF
   3365                    pBuf += 2;
   3366                  }
   \                     ??CrossCallReturnLabel_90:
   \   0000AA   A3           INC     DPTR
   \   0000AB   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_430:
   \   0000AE   5001         JNC     ??zclParseInReadReportCfgRspCmd_9
   \   0000B0   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_9:
   \   0000B1   05..         INC     ?V5
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   0000B3   E5..         MOV     A,?V5
   \   0000B5   C3           CLR     C
   \   0000B6   95..         SUBB    A,?V4
   \   0000B8   4003         JC      $+5
   \   0000BA   02....       LJMP    ??zclParseInReadReportCfgRspCmd_6 & 0xFFFF
   \   0000BD   E5..         MOV     A,?V5
   \   0000BF   75F00D       MOV     B,#0xd
   \   0000C2   12....       LCALL   ?Subroutine108 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   0000C5   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   0000C8   12....       LCALL   ??Subroutine192_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_408:
   \   0000CB   FD           MOV     R5,A
   \   0000CC   85..82       MOV     DPL,?V0
   \   0000CF   85..83       MOV     DPH,?V1
   \   0000D2   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   0000D5   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   0000D8   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_431:
   \   0000DB   5001         JNC     ??zclParseInReadReportCfgRspCmd_10
   \   0000DD   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_10:
   \   0000DE   EC           MOV     A,R4
   \   0000DF   70D0         JNZ     ??zclParseInReadReportCfgRspCmd_9
   \   0000E1   8E82         MOV     DPL,R6
   \   0000E3   8F83         MOV     DPH,R7
   \   0000E5   A3           INC     DPTR
   \   0000E6   A882         MOV     R0,DPL
   \   0000E8   A983         MOV     R1,DPH
   \   0000EA   8E82         MOV     DPL,R6
   \   0000EC   8F83         MOV     DPH,R7
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F5..         MOV     ?V10,A
   \   0000F1   ED           MOV     A,R5
   \   0000F2   70B3         JNZ     ??zclParseInReadReportCfgRspCmd_8
   \   0000F4   E5..         MOV     A,?V0
   \   0000F6   2404         ADD     A,#0x4
   \   0000F8   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   0000FB   A3           INC     DPTR
   \   0000FC   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_432:
   \   0000FF   5001         JNC     ??zclParseInReadReportCfgRspCmd_11
   \   000101   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_11:
   \   000102   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   000105   A3           INC     DPTR
   \   000106   12....       LCALL   ??Subroutine195_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_433:
   \   000109   5001         JNC     ??zclParseInReadReportCfgRspCmd_12
   \   00010B   0F           INC     R7
   \                     ??zclParseInReadReportCfgRspCmd_12:
   \   00010C                ; Setup parameters for call to function zclAnalogDataType
   \   00010C   A9..         MOV     R1,?V10
   \   00010E   12....       LCALL   ??zclAnalogDataType?relay; Banked call to: zclAnalogDataType
   \   000111   E9           MOV     A,R1
   \   000112   609D         JZ      ??zclParseInReadReportCfgRspCmd_9
   \   000114                ; Setup parameters for call to function zcl_BuildAnalogData
   \   000114   EE           MOV     A,R6
   \   000115   FC           MOV     R4,A
   \   000116   EF           MOV     A,R7
   \   000117   FD           MOV     R5,A
   \   000118   AA..         MOV     R2,?V2
   \   00011A   AB..         MOV     R3,?V3
   \   00011C   85..82       MOV     DPL,?V8
   \   00011F   85..83       MOV     DPH,?V9
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F9           MOV     R1,A
   \   000124   12....       LCALL   ??zcl_BuildAnalogData?relay; Banked call to: zcl_BuildAnalogData
   \   000127   E5..         MOV     A,?V0
   \   000129   240B         ADD     A,#0xb
   \   00012B   F582         MOV     DPL,A
   \   00012D   E4           CLR     A
   \   00012E   35..         ADDC    A,?V1
   \   000130   F583         MOV     DPH,A
   \   000132   E5..         MOV     A,?V2
   \   000134   F0           MOVX    @DPTR,A
   \   000135   A3           INC     DPTR
   \   000136   E5..         MOV     A,?V3
   \   000138   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_50:
   \   00013B   12....       LCALL   ??zclGetDataTypeLength?relay; Banked call to: zclGetDataTypeLength
   \   00013E   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000141   5002         JNC     ??zclParseInReadReportCfgRspCmd_13
   \   000143   05..         INC     ?V10
   \                     ??zclParseInReadReportCfgRspCmd_13:
   \   000145   E5..         MOV     A,?V2
   \   000147   25..         ADD     A,?V10
   \   000149   F5..         MOV     ?V2,A
   \   00014B   E4           CLR     A
   \   00014C   35..         ADDC    A,?V3
   \   00014E   F5..         MOV     ?V3,A
   \   000150   02....       LJMP    ??zclParseInReadReportCfgRspCmd_9 & 0xFFFF
   3367                }
   3368              }
   3369            }
   3370          
   3371            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   000153   02....       LJMP    ?Subroutine5 & 0xFFFF
   3372          }
   3373          
   3374          /*********************************************************************
   3375           * @fn      zclParseInReportCmd
   3376           *
   3377           * @brief   Parse the "Profile" Report Command
   3378           *
   3379           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3380           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3381           *
   3382           * @param   pCmd - pointer to incoming data to parse
   3383           *
   3384           * @return  pointer to the parsed command structure
   3385           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3386          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   3387          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine73 & 0xFFFF
   3388            zclReportCmd_t *reportCmd;
   3389            uint8 *pBuf = pCmd->pData;
   3390            uint16 attrDataLen;
   3391            uint8 *dataPtr;
   3392            uint8 numAttr = 0;
   3393            uint8 hdrLen;
   3394            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_116:
   \   000008   801E         SJMP    ??CrossCallReturnLabel_194
   3395          
   3396            // find out the number of attributes and the length of attribute data
   3397            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3398            {
   3399              uint8 dataType;
   3400          
   3401              numAttr++;
   \                     ??zclParseInReportCmd_0:
   \   00000A   05..         INC     ?V7
   3402              pBuf += 2; // move pass attribute id
   \   00000C   EE           MOV     A,R6
   \   00000D   2402         ADD     A,#0x2
   \   00000F   FE           MOV     R6,A
   \   000010   5001         JNC     ??zclParseInReportCmd_1
   \   000012   0F           INC     R7
   3403          
   3404              dataType = *pBuf++;
   \                     ??zclParseInReportCmd_1:
   \   000013   12....       LCALL   ?Subroutine83 & 0xFFFF
   3405          
   3406              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   \                     ??CrossCallReturnLabel_132:
   \   000016   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000019   12....       LCALL   ?Subroutine107 & 0xFFFF
   3407              pBuf += attrDataLen; // move pass attribute data
   3408          
   3409              // add padding if needed
   3410              if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_182:
   \   00001C   5007         JNC     ??zclParseInReportCmd_2
   3411              {
   3412                attrDataLen++;
   \   00001E   05..         INC     ?V0
   \   000020   04           INC     A
   \   000021   7002         JNZ     ??zclParseInReportCmd_2
   \   000023   05..         INC     ?V1
   3413              }
   3414          
   3415              dataLen += attrDataLen;
   \                     ??zclParseInReportCmd_2:
   \   000025   12....       LCALL   ?Subroutine114 & 0xFFFF
   3416            }
   \                     ??CrossCallReturnLabel_194:
   \   000028   12....       LCALL   ?Subroutine46 & 0xFFFF
   \                     ??CrossCallReturnLabel_376:
   \   00002B   40DD         JC      ??zclParseInReportCmd_0
   3417          
   3418            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   \   00002D   75F005       MOV     B,#0x5
   \   000030   E5..         MOV     A,?V7
   \   000032   A4           MUL     AB
   \   000033   04           INC     A
   \   000034   F5..         MOV     ?V6,A
   3419          
   3420            reportCmd = (zclReportCmd_t *)zcl_mem_alloc( hdrLen + dataLen );
   \   000036                ; Setup parameters for call to function osal_mem_alloc
   \   000036   25..         ADD     A,?V4
   \   000038   FA           MOV     R2,A
   \   000039   E4           CLR     A
   \   00003A   35..         ADDC    A,?V5
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000040   8A..         MOV     ?V10,R2
   \   000042   8B..         MOV     ?V11,R3
   3421            if (reportCmd != NULL )
   \   000044   EA           MOV     A,R2
   \   000045   45..         ORL     A,?V11
   \   000047   604C         JZ      ??zclParseInReportCmd_3
   3422            {
   3423              uint8 i;
   3424              pBuf = pCmd->pData;
   \   000049   12....       LCALL   ?Subroutine49 & 0xFFFF
   3425              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3426          
   3427              reportCmd->numAttr = numAttr;
   3428              for ( i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_57:
   \   00004C   8040         SJMP    ??CrossCallReturnLabel_192
   3429              {
   3430                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zclParseInReportCmd_4:
   \   00004E   E5..         MOV     A,?V8
   \   000050   75F005       MOV     B,#0x5
   \   000053   12....       LCALL   ??Subroutine194_0 & 0xFFFF
   3431          
   3432                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3433                pBuf += 2;
   \                     ??CrossCallReturnLabel_424:
   \   000056   5001         JNC     ??zclParseInReportCmd_5
   \   000058   0F           INC     R7
   3434                reportRec->dataType = *pBuf++;
   \                     ??zclParseInReportCmd_5:
   \   000059   12....       LCALL   ?Subroutine24 & 0xFFFF
   3435          
   3436                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_21:
   \   00005C   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00005F   8A..         MOV     ?V0,R2
   \   000061   8B..         MOV     ?V1,R3
   3437                zcl_memcpy( dataPtr, pBuf, attrDataLen );
   \   000063                ; Setup parameters for call to function osal_memcpy
   \   000063   8E..         MOV     ?V4,R6
   \   000065   8F..         MOV     ?V5,R7
   \   000067   75..00       MOV     ?V6,#0x0
   \   00006A   78..         MOV     R0,#?V4
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006F   AC..         MOV     R4,?V0
   \   000071   AD..         MOV     R5,?V1
   \   000073   AA..         MOV     R2,?V2
   \   000075   AB..         MOV     R3,?V3
   \   000077   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00007A   7403         MOV     A,#0x3
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   3438                reportRec->attrData = dataPtr;
   \   00007F   12....       LCALL   ?Subroutine18 & 0xFFFF
   3439          
   3440                pBuf += attrDataLen; // move pass attribute data
   3441          
   3442                // advance attribute data pointer
   3443                if ( PADDING_NEEDED( attrDataLen ) )
   \                     ??CrossCallReturnLabel_367:
   \   000082   5007         JNC     ??zclParseInReportCmd_6
   3444                {
   3445                  attrDataLen++;
   \   000084   05..         INC     ?V0
   \   000086   04           INC     A
   \   000087   7002         JNZ     ??zclParseInReportCmd_6
   \   000089   05..         INC     ?V1
   3446                }
   3447          
   3448                dataPtr += attrDataLen;
   \                     ??zclParseInReportCmd_6:
   \   00008B   12....       LCALL   ?Subroutine113 & 0xFFFF
   3449              }
   \                     ??CrossCallReturnLabel_192:
   \   00008E   E5..         MOV     A,?V8
   \   000090   C3           CLR     C
   \   000091   95..         SUBB    A,?V7
   \   000093   40B9         JC      ??zclParseInReportCmd_4
   3450            }
   3451          
   3452            return ( (void *)reportCmd );
   \                     ??zclParseInReportCmd_3:
   \   000095   02....       LJMP    ?Subroutine8 & 0xFFFF
   3453          }
   3454          #endif // ZCL_REPORT
   3455          
   3456          /*********************************************************************
   3457           * @fn      zclParseInDefaultRspCmd
   3458           *
   3459           * @brief   Parse the "Profile" Default Response Command
   3460           *
   3461           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3462           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3463           *
   3464           * @param   pCmd - pointer to incoming data to parse
   3465           *
   3466           * @return  pointer to the parsed command structure
   3467           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3468          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3469          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3470            zclDefaultRspCmd_t *defaultRspCmd;
   3471            uint8 *pBuf = pCmd->pData;
   \   000005   12....       LCALL   ?Subroutine124 & 0xFFFF
   3472          
   3473            defaultRspCmd = (zclDefaultRspCmd_t *)zcl_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \                     ??CrossCallReturnLabel_419:
   \   000008                ; Setup parameters for call to function osal_mem_alloc
   \   000008   7A02         MOV     R2,#0x2
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   3474            if ( defaultRspCmd != NULL )
   \   00000F   EA           MOV     A,R2
   \   000010   4B           ORL     A,R3
   \   000011   600B         JZ      ??zclParseInDefaultRspCmd_0
   3475            {
   3476              defaultRspCmd->commandID = *pBuf++;
   \   000013   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_445:
   \   000016   12....       LCALL   ??Subroutine175_0 & 0xFFFF
   3477              defaultRspCmd->statusCode = *pBuf;
   \                     ??CrossCallReturnLabel_324:
   \   000019   12....       LCALL   ??Subroutine197_0 & 0xFFFF
   3478            }
   \                     ??CrossCallReturnLabel_443:
   \   00001C   A3           INC     DPTR
   \   00001D   F0           MOVX    @DPTR,A
   3479          
   3480            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   00001E   02....       LJMP    ?Subroutine2 & 0xFFFF
   3481          }
   3482          
   3483          #ifdef ZCL_DISCOVER
   3484          /*********************************************************************
   3485           * @fn      zclParseInDiscAttrsCmd
   3486           *
   3487           * @brief   Parse the "Profile" Discovery Attributes and Attributes Extended Commands
   3488           *
   3489           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3490           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3491           *
   3492           * @param   pCmd - pointer to incoming data to parse
   3493           *
   3494           * @return  pointer to the parsed command structure
   3495           */
   3496          void *zclParseInDiscAttrsCmd( zclParseCmd_t *pCmd )
   3497          {
   3498            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3499            uint8 *pBuf = pCmd->pData;
   3500          
   3501            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsCmd_t ) );
   3502            if ( pDiscoverCmd != NULL )
   3503            {
   3504              pDiscoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3505              pBuf += 2;
   3506              pDiscoverCmd->maxAttrIDs = *pBuf;
   3507            }
   3508          
   3509            return ( (void *)pDiscoverCmd );
   3510          }
   3511          
   3512          /*********************************************************************
   3513           * @fn      zclParseInDiscAttrsRspCmd
   3514           *
   3515           * @brief   Parse the "Profile" Discovery Response Commands
   3516           *
   3517           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3518           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3519           *
   3520           * @param   pCmd - pointer to incoming data to parse
   3521           *
   3522           * @return  pointer to the parsed command structure
   3523           */
   3524          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3525          static void *zclParseInDiscAttrsRspCmd( zclParseCmd_t *pCmd )
   3526          {
   3527            zclDiscoverAttrsRspCmd_t *pDiscoverRspCmd;
   3528            uint8 *pBuf = pCmd->pData;
   3529            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3530          
   3531            pDiscoverRspCmd = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsRspCmd_t ) +
   3532                              ( numAttr * sizeof(zclDiscoverAttrInfo_t) ) );
   3533          
   3534            if ( pDiscoverRspCmd != NULL )
   3535            {
   3536              uint8 i;
   3537          
   3538              pDiscoverRspCmd->discComplete = *pBuf++;
   3539              pDiscoverRspCmd->numAttr = numAttr;
   3540          
   3541              for ( i = 0; i < numAttr; i++ )
   3542              {
   3543                pDiscoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3544                pBuf += 2;
   3545                pDiscoverRspCmd->attrList[i].dataType = *pBuf++;
   3546              }
   3547            }
   3548          
   3549            return ( (void *)pDiscoverRspCmd );
   3550          }
   3551          
   3552          /*********************************************************************
   3553           * @fn      zclParseInDiscCmdsCmd
   3554           *
   3555           * @brief   Parse the "Profile" Discovery Commands
   3556           *
   3557           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3558           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3559           *
   3560           * @param   pCmd - pointer to incoming data to parse
   3561           *
   3562           * @return  pointer to the parsed command structure
   3563           */
   3564          void *zclParseInDiscCmdsCmd( zclParseCmd_t *pCmd )
   3565          {
   3566            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   3567            uint8 *pBuf = pCmd->pData;
   3568          
   3569            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmd_t ) );
   3570            if ( pDiscoverCmd != NULL )
   3571            {
   3572              pDiscoverCmd->startCmdID = *pBuf++;
   3573              pDiscoverCmd->maxCmdID = *pBuf++;
   3574            }
   3575          
   3576            return ( (void *)pDiscoverCmd );
   3577          }
   3578          
   3579          /*********************************************************************
   3580           * @fn      zclParseInDiscCmdsRspCmd
   3581           *
   3582           * @brief   Parse the Discover Commands Response Command
   3583           *
   3584           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3585           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3586           *
   3587           * @param   pCmd - pointer to incoming data to parse
   3588           *
   3589           * @return  pointer to the parsed command structure
   3590           */
   3591          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3592          static void *zclParseInDiscCmdsRspCmd( zclParseCmd_t *pCmd )
   3593          {
   3594            zclDiscoverCmdsCmdRsp_t *pDiscoverRspCmd;
   3595            uint8 *pBuf = pCmd->pData;
   3596            uint8 numCmds = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen);  // length of command ID variable array
   3597          
   3598              // allocate memory for size of structure plus variable array
   3599            pDiscoverRspCmd = (zclDiscoverCmdsCmdRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverCmdsCmdRsp_t ) +
   3600                              ( numCmds * sizeof(uint8) ) );
   3601            if ( pDiscoverRspCmd != NULL )
   3602            {
   3603              uint8 i;
   3604              pDiscoverRspCmd->discComplete = *pBuf++;
   3605              pDiscoverRspCmd->numCmd = numCmds;
   3606          
   3607              for ( i = 0; i < numCmds; i++ )
   3608              {
   3609                pDiscoverRspCmd->pCmdID[i] = *pBuf++;
   3610              }
   3611            }
   3612          
   3613            return ( (void *)pDiscoverRspCmd );
   3614          }
   3615          
   3616          /*********************************************************************
   3617           * @fn      zclParseInDiscAttrsExtRspCmd
   3618           *
   3619           * @brief   Parse the "Profile" Discovery Extended Attributes Response Commands
   3620           *
   3621           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3622           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3623           *
   3624           * @param   pCmd - pointer to incoming data to parse
   3625           *
   3626           * @return  pointer to the parsed command structure
   3627           */
   3628          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3629          static void *zclParseInDiscAttrsExtRspCmd( zclParseCmd_t *pCmd )
   3630          {
   3631            zclDiscoverAttrsExtRsp_t *pDiscoverRspCmd;
   3632            uint8 i;
   3633            uint8 *pBuf = pCmd->pData;
   3634            uint8 numAttrs = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 + 1 ); // Attr ID + Data Type + Access Control
   3635          
   3636            pDiscoverRspCmd = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof ( zclDiscoverAttrsExtRsp_t ) +
   3637                              ( numAttrs * sizeof(zclExtAttrInfo_t) ) );
   3638          
   3639            if ( pDiscoverRspCmd != NULL )
   3640            {
   3641              pDiscoverRspCmd->discComplete = *pBuf++;
   3642              pDiscoverRspCmd->numAttr = numAttrs;
   3643          
   3644              for ( i = 0; i < numAttrs; i++ )
   3645              {
   3646                pDiscoverRspCmd->aExtAttrInfo[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3647                pBuf += 2;
   3648                pDiscoverRspCmd->aExtAttrInfo[i].attrDataType = *pBuf++;
   3649                pDiscoverRspCmd->aExtAttrInfo[i].attrAccessControl = *pBuf++;
   3650              }
   3651            }
   3652          
   3653            return ( (void *)pDiscoverRspCmd );
   3654          }
   3655          #endif // ZCL_DISCOVER
   3656          
   3657          #ifdef ZCL_READ
   3658          /*********************************************************************
   3659           * @fn      zclProcessInReadCmd
   3660           *
   3661           * @brief   Process the "Profile" Read Command
   3662           *
   3663           * @param   pInMsg - incoming message to process
   3664           *
   3665           * @return  TRUE if command processed. FALSE, otherwise.
   3666           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine171_0
   \   000006                ; // Fall through to label ??Subroutine171_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine172_0
   \   000001                ; // Fall through to label ??Subroutine172_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine172_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine173_0
   \   000001                ; // Fall through to label ??Subroutine173_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine173_0:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine174_0
   \   000001                ; // Fall through to label ??Subroutine174_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3667          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg ){
   \                     zclProcessInReadCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   3668          	zclReadCmd_t *readCmd;
   3669          	zclReadRspCmd_t *readRspCmd;
   3670          	zclAttrRec_t attribute;
   3671          	uint16 len;
   3672          	uint8 i;
   3673          
   3674          	readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   00000E   EA           MOV     A,R2
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   35..         ADDC    A,?V1
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F5..         MOV     ?V6,A
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F5..         MOV     ?V7,A
   3675          
   3676          	// calculate the length of the response status record
   3677          	len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   3678          
   3679          	readRspCmd = zcl_mem_alloc( len );
   \   00001F                ; Setup parameters for call to function osal_mem_alloc
   \   00001F   85..82       MOV     DPL,?V6
   \   000022   F583         MOV     DPH,A
   \   000024   E0           MOVX    A,@DPTR
   \   000025   75F006       MOV     B,#0x6
   \   000028   12....       LCALL   ??Subroutine199_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_464:
   \   00002B   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00002E   8A..         MOV     ?V10,R2
   \   000030   8B..         MOV     ?V11,R3
   3680          	if ( readRspCmd == NULL )  {
   \   000032   EA           MOV     A,R2
   \   000033   45..         ORL     A,?V11
   \   000035   7005         JNZ     ??zclProcessInReadCmd_0
   3681              	return FALSE; // EMBEDDED RETURN
   \   000037   7900         MOV     R1,#0x0
   \   000039   02....       LJMP    ??zclProcessInReadCmd_1 & 0xFFFF
   3682          	}
   3683          
   3684          	readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_0:
   \   00003C   85..82       MOV     DPL,?V6
   \   00003F   85..83       MOV     DPH,?V7
   \   000042   12....       LCALL   ?Subroutine96 & 0xFFFF
   3685          	
   3686          	for ( i = 0; i < readCmd->numAttr; i++ )  {
   \                     ??CrossCallReturnLabel_159:
   \   000045   75..00       MOV     ?V8,#0x0
   \   000048   8076         SJMP    ??zclProcessInReadCmd_2
   3687              	zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclProcessInReadCmd_3:
   \   00004A   85..82       MOV     DPL,?V8
   \   00004D   A882         MOV     R0,DPL
   \   00004F   E8           MOV     A,R0
   \   000050   75F006       MOV     B,#0x6
   \   000053   A4           MUL     AB
   \   000054   FA           MOV     R2,A
   \   000055   ABF0         MOV     R3,B
   \   000057   E5..         MOV     A,?V10
   \   000059   2A           ADD     A,R2
   \   00005A   F582         MOV     DPL,A
   \   00005C   E5..         MOV     A,?V11
   \   00005E   3B           ADDC    A,R3
   \   00005F   F583         MOV     DPH,A
   \   000061   A3           INC     DPTR
   \   000062   8582..       MOV     ?V2,DPL
   \   000065   8583..       MOV     ?V3,DPH
   3688              	statusRec->attrID = readCmd->attrID[i];
   \   000068   E8           MOV     A,R0
   \   000069   28           ADD     A,R0
   \   00006A   F8           MOV     R0,A
   \   00006B   E4           CLR     A
   \   00006C   33           RLC     A
   \   00006D   F9           MOV     R1,A
   \   00006E   E5..         MOV     A,?V6
   \   000070   28           ADD     A,R0
   \   000071   F582         MOV     DPL,A
   \   000073   E5..         MOV     A,?V7
   \   000075   12....       LCALL   ??Subroutine196_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_436:
   \   000078   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   00007B   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   3689          		ReadAttributeFn callback = findReadAttributeFn(pInMsg->msg->endPoint, pInMsg->msg->clusterId);
   3690          		callback(&attribute);
   \                     ??CrossCallReturnLabel_314:
   \   00007E   85..82       MOV     DPL,?V0
   \   000081   85..83       MOV     DPH,?V1
   \   000084   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   000087   A3           INC     DPTR
   \   000088   A3           INC     DPTR
   \   000089   A3           INC     DPTR
   \   00008A   A3           INC     DPTR
   \   00008B   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_449:
   \   00008E   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   000091   12....       LCALL   ??findReadAttributeFn?relay; Banked call to: findReadAttributeFn
   \   000094   8A82         MOV     DPL,R2
   \   000096   8B83         MOV     DPH,R3
   \   000098   AA..         MOV     R2,?XSP + 0
   \   00009A   AB..         MOV     R3,?XSP + 1
   \   00009C   12....       LCALL   ?CALL_IND
   3691          		statusRec->data = attribute.attr.dataPtr;
   \   00009F   7406         MOV     A,#0x6
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   0000A7   A3           INC     DPTR
   \   0000A8   12....       LCALL   ?Subroutine39 & 0xFFFF
   3692          		statusRec->dataType = attribute.attr.dataType;
   \                     ??CrossCallReturnLabel_321:
   \   0000AB   7404         MOV     A,#0x4
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   0000B3   A3           INC     DPTR
   \   0000B4   F0           MOVX    @DPTR,A
   3693          		statusRec->status = attribute.attr.status;
   \   0000B5   740A         MOV     A,#0xa
   \   0000B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BA   12....       LCALL   ?Subroutine99 & 0xFFFF
   3694          	}
   \                     ??CrossCallReturnLabel_163:
   \   0000BD   F0           MOVX    @DPTR,A
   \   0000BE   05..         INC     ?V8
   \                     ??zclProcessInReadCmd_2:
   \   0000C0   85..82       MOV     DPL,?V6
   \   0000C3   85..83       MOV     DPH,?V7
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F8           MOV     R0,A
   \   0000C8   E5..         MOV     A,?V8
   \   0000CA   C3           CLR     C
   \   0000CB   98           SUBB    A,R0
   \   0000CC   5003         JNC     $+5
   \   0000CE   02....       LJMP    ??zclProcessInReadCmd_3 & 0xFFFF
   3695          
   3696          	// Build and send Read Response command
   3697          	zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId, readRspCmd, !pInMsg->hdr.fc.direction, true, pInMsg->hdr.transSeqNum );
   \   0000D1   85..82       MOV     DPL,?V0
   \   0000D4   85..83       MOV     DPH,?V1
   \   0000D7   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   0000DA                ; Setup parameters for call to function zcl_SendReadRsp
   \   0000DA   85..82       MOV     DPL,?V0
   \   0000DD   85..83       MOV     DPH,?V1
   \   0000E0   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   0000E3   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000E6   75..01       MOV     ?V2,#0x1
   \   0000E9   78..         MOV     R0,#?V2
   \   0000EB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000EE   85..82       MOV     DPL,?V0
   \   0000F1   85..83       MOV     DPH,?V1
   \   0000F4   A3           INC     DPTR
   \   0000F5   A3           INC     DPTR
   \   0000F6   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   0000F9   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000FC   78..         MOV     R0,#?V10
   \   0000FE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000101   85..82       MOV     DPL,?V4
   \   000104   85..83       MOV     DPH,?V5
   \   000107   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_287:
   \   00010A   E5..         MOV     A,?V4
   \   00010C   2406         ADD     A,#0x6
   \   00010E   FA           MOV     R2,A
   \   00010F   E4           CLR     A
   \   000110   35..         ADDC    A,?V5
   \   000112   FB           MOV     R3,A
   \   000113   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000116   12....       LCALL   ??zcl_SendReadRsp?relay; Banked call to: zcl_SendReadRsp
   \   000119   7405         MOV     A,#0x5
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   3698          	zcl_mem_free( readRspCmd );
   \   00011E                ; Setup parameters for call to function osal_mem_free
   \   00011E   AA..         MOV     R2,?V10
   \   000120   AB..         MOV     R3,?V11
   \   000122   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3699          
   3700          	return TRUE;
   \   000125   7901         MOV     R1,#0x1
   \                     ??zclProcessInReadCmd_1:
   \   000127   740B         MOV     A,#0xb
   \   000129   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012C   02....       LJMP    ??Subroutine160_0 & 0xFFFF
   3701          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   E5..         MOV     A,?V4
   \   000002   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_237:
   \   000005   35..         ADDC    A,?V5
   \   000007   F583         MOV     DPH,A
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F9           MOV     R1,A
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V2
   \   000004   85..83       MOV     DPH,?V3
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   12....       LCALL   ?Subroutine131 & 0xFFFF
   \                     ??CrossCallReturnLabel_369:
   \   000003   22           RET
   3702          #endif // ZCL_READ
   3703          
   3704          #ifdef ZCL_WRITE
   3705          /*********************************************************************
   3706           * @fn      processInWriteCmd
   3707           *
   3708           * @brief   Process the "Profile" Write and Write No Response Commands
   3709           *
   3710           * @param   pInMsg - incoming message to process
   3711           *
   3712           * @return  TRUE if command processed. FALSE, otherwise.
   3713           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3714          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg ){
   \                     zclProcessInWriteCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   3715          	 zclWriteCmd_t *writeCmd;
   3716           	zclWriteRspCmd_t *writeRspCmd;
   3717           	uint8 sendRsp = FALSE;
   \   00000E   75..00       MOV     ?V10,#0x0
   3718           	uint8 i;
   3719          
   3720           	writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000011   EA           MOV     A,R2
   \   000012   240C         ADD     A,#0xc
   \   000014   F582         MOV     DPL,A
   \   000016   E4           CLR     A
   \   000017   35..         ADDC    A,?V3
   \   000019   F583         MOV     DPH,A
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V12,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V13,A
   3721           	if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE ) {
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6402         XRL     A,#0x2
   \   000030   701E         JNZ     ??zclProcessInWriteCmd_0
   3722          		// We need to send a response back - allocate space for it
   3723          		writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t ) + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000032                ; Setup parameters for call to function osal_mem_alloc
   \   000032   85..82       MOV     DPL,?V12
   \   000035   85..83       MOV     DPH,?V13
   \   000038   E0           MOVX    A,@DPTR
   \   000039   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_466:
   \   00003C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00003F   8A..         MOV     ?V0,R2
   \   000041   8B..         MOV     ?V1,R3
   3724              	if ( writeRspCmd == NULL ) {
   \   000043   EA           MOV     A,R2
   \   000044   45..         ORL     A,?V1
   \   000046   7005         JNZ     ??zclProcessInWriteCmd_1
   3725          			return FALSE; // EMBEDDED RETURN
   \   000048   7900         MOV     R1,#0x0
   \   00004A   02....       LJMP    ??zclProcessInWriteCmd_2 & 0xFFFF
   3726          		}
   3727          		sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_1:
   \   00004D   75..01       MOV     ?V10,#0x1
   3728          	}
   3729          	
   3730          	uint8 endpoint = pInMsg->msg->endPoint;
   \                     ??zclProcessInWriteCmd_0:
   \   000050   85..82       MOV     DPL,?V2
   \   000053   85..83       MOV     DPH,?V3
   \   000056   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000059   F5..         MOV     ?V11,A
   3731          	uint16 clusterId = pInMsg->msg->clusterId;
   \   00005B   8882         MOV     DPL,R0
   \   00005D   8983         MOV     DPH,R1
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_365:
   \   000063   7407         MOV     A,#0x7
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   3732          	WriteAttributeFn writeAttributeFn;
   3733          	ZclWriteAttribute_t writeAttribute;
   3734          	zclWriteRec_t *statusRec = &(writeCmd->attrList[0]);
   \                     ??CrossCallReturnLabel_315:
   \   00006B   85..82       MOV     DPL,?V12
   \   00006E   85..83       MOV     DPH,?V13
   \   000071   A3           INC     DPTR
   \   000072   8582..       MOV     ?V4,DPL
   \   000075   8583..       MOV     ?V5,DPH
   3735          	zclWriteRspStatus_t  * rspStatus =  &writeRspCmd->attrList[0];
   \   000078   85..82       MOV     DPL,?V0
   \   00007B   85..83       MOV     DPH,?V1
   \   00007E   A3           INC     DPTR
   \   00007F   8582..       MOV     ?V14,DPL
   \   000082   8583..       MOV     ?V15,DPH
   \   000085   85....       MOV     ?V6,?V14
   \   000088   85....       MOV     ?V7,?V15
   3736          	uint8 errorCount=0;
   \   00008B   75..00       MOV     ?V8,#0x0
   3737          
   3738          	for ( i = 0; i < writeCmd->numAttr; i++ ){
   \   00008E   75..00       MOV     ?V9,#0x0
   \   000091   02....       LJMP    ??zclProcessInWriteCmd_3 & 0xFFFF
   3739          		writeAttribute.attrId = statusRec->attrID;
   \                     ??zclProcessInWriteCmd_4:
   \   000094   85..82       MOV     DPL,?V4
   \   000097   85..83       MOV     DPH,?V5
   \   00009A   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   00009D   12....       LCALL   ?Subroutine29 & 0xFFFF
   3740          		writeAttribute.dataPtr =statusRec->attrData;
   \                     ??CrossCallReturnLabel_29:
   \   0000A0   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_362:
   \   0000A3   7403         MOV     A,#0x3
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   12....       LCALL   ?Subroutine29 & 0xFFFF
   3741          		writeAttribute.dataType = statusRec->dataType;
   \                     ??CrossCallReturnLabel_30:
   \   0000AB   E0           MOVX    A,@DPTR
   \   0000AC   F9           MOV     R1,A
   \   0000AD   7402         MOV     A,#0x2
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   E9           MOV     A,R1
   \   0000B3   F0           MOVX    @DPTR,A
   3742          		writeAttribute.len = zclGetAttrDataLength(writeAttribute.dataType, writeAttribute.dataPtr );
   \   0000B4                ; Setup parameters for call to function zclGetAttrDataLength
   \   0000B4   7403         MOV     A,#0x3
   \   0000B6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B9   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_450:
   \   0000BC   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   0000BF   7405         MOV     A,#0x5
   \   0000C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C4   EA           MOV     A,R2
   \   0000C5   F0           MOVX    @DPTR,A
   3743                  
   3744          		writeAttributeFn = findWriteAttributeFn(endpoint, clusterId);
   3745          		writeAttributeFn(&writeAttribute);
   \   0000C6                ; Setup parameters for indirect call
   \   0000C6                ; Setup parameters for call to function findWriteAttributeFn
   \   0000C6   7407         MOV     A,#0x7
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_451:
   \   0000CE   A9..         MOV     R1,?V11
   \   0000D0   12....       LCALL   ??findWriteAttributeFn?relay; Banked call to: findWriteAttributeFn
   \   0000D3   8A82         MOV     DPL,R2
   \   0000D5   8B83         MOV     DPH,R3
   \   0000D7   AA..         MOV     R2,?XSP + 0
   \   0000D9   AB..         MOV     R3,?XSP + 1
   \   0000DB   12....       LCALL   ?CALL_IND
   3746          		rspStatus->status = writeAttribute.status;
   \   0000DE   7406         MOV     A,#0x6
   \   0000E0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E3   12....       LCALL   ?Subroutine148 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   0000E6   12....       LCALL   ?Subroutine27 & 0xFFFF
   3747                  rspStatus->attrID = writeAttribute.attrId;
   \                     ??CrossCallReturnLabel_25:
   \   0000E9   F8           MOV     R0,A
   \   0000EA   A3           INC     DPTR
   \   0000EB   E0           MOVX    A,@DPTR
   \   0000EC   F9           MOV     R1,A
   \   0000ED   85..82       MOV     DPL,?V6
   \   0000F0   85..83       MOV     DPH,?V7
   \   0000F3   12....       LCALL   ??Subroutine173_0 & 0xFFFF
   3748          		if (writeAttribute.status != ZCL_STATUS_SUCCESS){
   \                     ??CrossCallReturnLabel_319:
   \   0000F6   7406         MOV     A,#0x6
   \   0000F8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   6002         JZ      ??zclProcessInWriteCmd_5
   3749          			errorCount++;
   \   0000FE   05..         INC     ?V8
   3750          		}
   3751          
   3752          		statusRec++;
   \                     ??zclProcessInWriteCmd_5:
   \   000100   E5..         MOV     A,?V4
   \   000102   2406         ADD     A,#0x6
   \   000104   F5..         MOV     ?V4,A
   \   000106   5002         JNC     ??zclProcessInWriteCmd_6
   \   000108   05..         INC     ?V5
   3753          		rspStatus++;
   \                     ??zclProcessInWriteCmd_6:
   \   00010A   E5..         MOV     A,?V6
   \   00010C   2403         ADD     A,#0x3
   \   00010E   F5..         MOV     ?V6,A
   \   000110   5002         JNC     ??zclProcessInWriteCmd_7
   \   000112   05..         INC     ?V7
   3754          		
   3755           	} // for loop
   \                     ??zclProcessInWriteCmd_7:
   \   000114   05..         INC     ?V9
   \                     ??zclProcessInWriteCmd_3:
   \   000116   85..82       MOV     DPL,?V12
   \   000119   85..83       MOV     DPH,?V13
   \   00011C   E0           MOVX    A,@DPTR
   \   00011D   F8           MOV     R0,A
   \   00011E   E5..         MOV     A,?V9
   \   000120   C3           CLR     C
   \   000121   98           SUBB    A,R0
   \   000122   5003         JNC     $+5
   \   000124   02....       LJMP    ??zclProcessInWriteCmd_4 & 0xFFFF
   3756          
   3757            	if ( sendRsp ){
   \   000127   E5..         MOV     A,?V10
   \   000129   A2E0         MOV     C,0xE0 /* A   */.0
   \   00012B   5055         JNC     ??zclProcessInWriteCmd_8
   3758              	if (errorCount == 0 ) {
   \   00012D   E5..         MOV     A,?V8
   \   00012F   7009         JNZ     ??CrossCallReturnLabel_47
   3759                		// Since all records were written successful, include a single status record/ in the resonse command with the status field set to SUCCESS and the attribute ID field omitted.
   3760                		writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000131   85..82       MOV     DPL,?V14
   \   000134   85..83       MOV     DPH,?V15
   \   000137   12....       LCALL   ?Subroutine43 & 0xFFFF
   3761                		writeRspCmd->numAttr = 1;
   3762              	}
   3763          
   3764              	zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),  pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction, true, pInMsg->hdr.transSeqNum );
   \                     ??CrossCallReturnLabel_47:
   \   00013A   85..82       MOV     DPL,?V2
   \   00013D   85..83       MOV     DPH,?V3
   \   000140   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_413:
   \   000143                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000143   85..82       MOV     DPL,?V2
   \   000146   85..83       MOV     DPH,?V3
   \   000149   A3           INC     DPTR
   \   00014A   A3           INC     DPTR
   \   00014B   A3           INC     DPTR
   \   00014C   A3           INC     DPTR
   \   00014D   A3           INC     DPTR
   \   00014E   A3           INC     DPTR
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   F5..         MOV     ?V4,A
   \   000152   78..         MOV     R0,#?V4
   \   000154   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000157   75..01       MOV     ?V4,#0x1
   \   00015A   78..         MOV     R0,#?V4
   \   00015C   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00015F   85..82       MOV     DPL,?V2
   \   000162   85..83       MOV     DPH,?V3
   \   000165   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_469:
   \   000168   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   00016B   78..         MOV     R0,#?V0
   \   00016D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000170   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000173   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   000176   7405         MOV     A,#0x5
   \   000178   12....       LCALL   ?DEALLOC_XSTACK8
   3765              	zcl_mem_free( writeRspCmd );
   \   00017B                ; Setup parameters for call to function osal_mem_free
   \   00017B   AA..         MOV     R2,?V0
   \   00017D   AB..         MOV     R3,?V1
   \   00017F   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3766            	}
   3767          
   3768            	return TRUE;
   \                     ??zclProcessInWriteCmd_8:
   \   000182   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteCmd_2:
   \   000184   7409         MOV     A,#0x9
   \   000186   02....       LJMP    ?Subroutine4 & 0xFFFF
   3769          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine200_0
   \   000002                ; // Fall through to label ??Subroutine200_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?V4
   \   000008   85..83       MOV     DPH,?V5
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_387:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_385:
   \   000003   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine143:
   \   000000   E8           MOV     A,R0
   \   000001   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_239:
   \   000004   39           ADDC    A,R1
   \   000005   F583         MOV     DPH,A
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   12....       LCALL   ?Subroutine139 & 0xFFFF
   \                     ??CrossCallReturnLabel_348:
   \   000007   FD           MOV     R5,A
   \   000008   EE           MOV     A,R6
   \   000009   2406         ADD     A,#0x6
   \   00000B   FA           MOV     R2,A
   \   00000C   E4           CLR     A
   \   00000D   3F           ADDC    A,R7
   \   00000E   FB           MOV     R3,A
   \   00000F   EE           MOV     A,R6
   \   000010   12....       LCALL   ?Subroutine153 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000013   3F           ADDC    A,R7
   \   000014   F583         MOV     DPH,A
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   85..82       MOV     DPL,?V0
   \   000005   85..83       MOV     DPH,?V1
   \   000008   04           INC     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   22           RET
   3770          
   3771          /*********************************************************************
   3772           * @fn      zclRevertWriteUndividedCmd
   3773           *
   3774           * @brief   Revert the "Profile" Write Undevided Command
   3775           *
   3776           * @param   pInMsg - incoming message to process
   3777           * @param   curWriteRec - old data
   3778           * @param   numAttr - number of attributes to be reverted
   3779           *
   3780           * @return  none
   3781           */
   3782          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,  zclWriteRec_t *curWriteRec, uint16 numAttr ){
   3783          	uint8 i;
   3784          	WriteAttributeFn writeAttributeFn;
   3785          	ZclWriteAttribute_t writeAttribute;
   3786          	uint8 endpoint = pInMsg->msg->endPoint;
   3787          	uint16 clusterId =pInMsg->msg->clusterId;
   3788          	
   3789          	for ( i = 0; i < numAttr; i++ ){
   3790          		writeAttributeFn = findWriteAttributeFn(endpoint, clusterId);
   3791          		
   3792          		writeAttribute.attrId = curWriteRec->attrID;
   3793          		writeAttribute.dataPtr = curWriteRec->attrData;
   3794          		writeAttribute.dataType = curWriteRec->dataType;
   3795          		writeAttribute.len = zclGetAttrDataLength( curWriteRec->dataType, curWriteRec->attrData );
   3796          		writeAttributeFn(&writeAttribute);
   3797          		curWriteRec++;
   3798            }
   3799          }
   3800          
   3801          /*********************************************************************
   3802           * @fn      zclProcessInWriteUndividedCmd
   3803           *
   3804           * @brief   Process the "Profile" Write Undivided Command
   3805           *
   3806           * @param   pInMsg - incoming message to process
   3807           *
   3808           * @return  TRUE if command processed. FALSE, otherwise.
   3809           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3810          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg ){
   \                     zclProcessInWriteUndividedCmd:
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 31
   \   000005   74E1         MOV     A,#-0x1f
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V12,R2
   \   00000C   8B..         MOV     ?V13,R3
   3811            zclWriteCmd_t *writeCmd;
   3812            zclWriteRspCmd_t *writeRspCmd;
   3813            zclAttrRec_t attrRec;
   3814            ZclWriteAttribute_t writeAttribute;
   3815            ReadAttributeFn readAttributeFn;
   3816            WriteAttributeFn writeAttributeFn;
   3817            uint16 dataLen;
   3818            uint16 curLen = 0;
   \   00000E   75..00       MOV     ?V6,#0x0
   \   000011   75..00       MOV     ?V7,#0x0
   3819            uint8 j = 0;
   \   000014   75..00       MOV     ?V2,#0x0
   3820            uint8 i;
   3821          
   3822            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   000017   EA           MOV     A,R2
   \   000018   240C         ADD     A,#0xc
   \   00001A   F582         MOV     DPL,A
   \   00001C   E4           CLR     A
   \   00001D   35..         ADDC    A,?V13
   \   00001F   F583         MOV     DPH,A
   \   000021   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000024   E8           MOV     A,R0
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   E9           MOV     A,R1
   \   000028   12....       LCALL   ?Subroutine22 & 0xFFFF
   3823          
   3824            // Allocate space for Write Response Command
   3825            writeRspCmd = (zclWriteRspCmd_t *)zcl_mem_alloc( sizeof( zclWriteRspCmd_t )
   3826                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \                     ??CrossCallReturnLabel_16:
   \   00002B   12....       LCALL   ?Subroutine111 & 0xFFFF
   \                     ??CrossCallReturnLabel_467:
   \   00002E   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   000031   8A..         MOV     ?V0,R2
   \   000033   8B..         MOV     ?V1,R3
   3827            if ( writeRspCmd == NULL )
   \   000035   EA           MOV     A,R2
   \   000036   45..         ORL     A,?V1
   \   000038   7003         JNZ     $+5
   \   00003A   02....       LJMP    ??zclProcessInWriteUndividedCmd_0 & 0xFFFF
   3828            {
   3829              return FALSE; // EMBEDDED RETURN
   3830            }
   3831          
   3832            // If any attribute cannot be written, no attribute values are changed. Hence, make sure all the attributes are supported and writable
   3833          	for ( i = 0; i < writeCmd->numAttr; i++ ) {
   \   00003D   75..00       MOV     ?V3,#0x0
   \   000040   8029         SJMP    ??zclProcessInWriteUndividedCmd_1
   3834              	zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3835          
   3836          		attrRec.attr.attrId = statusRec->attrID;
   3837          		readAttributeFn = findReadAttributeFn(pInMsg->msg->endPoint, pInMsg->msg->clusterId);
   3838          		readAttributeFn( &attrRec );
   3839          		if (attrRec.attr.status == ZCL_STATUS_UNSUPPORTED_ATTRIBUTE){
   3840          			 // Attribute is not supported - stop here
   3841          			writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3842          			writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3843          			break;
   3844          		}
   3845          
   3846          		if ( statusRec->dataType != attrRec.attr.dataType ) {
   3847          			// Attribute data type is incorrect - stope here
   3848          			writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3849          			writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3850          			break;
   3851          		}
   3852          
   3853          		if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) ) {
   3854          			writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   3855          			writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3856          			break;
   3857          		}
   3858          
   3859          		if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) ) {
   3860          			writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   3861          			writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3862          			break;
   3863          		}
   3864          
   3865          		dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   \                     ??zclProcessInWriteUndividedCmd_2:
   \   000042                ; Setup parameters for call to function zclGetAttrDataLength
   \   000042   740C         MOV     A,#0xc
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_452:
   \   00004A   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00004D   8A..         MOV     ?V4,R2
   \   00004F   8B..         MOV     ?V5,R3
   3866          
   3867          		// add padding if needed
   3868          		if ( PADDING_NEEDED( dataLen ) ) {
   \   000051   EA           MOV     A,R2
   \   000052   A2E0         MOV     C,0xE0 /* A   */.0
   \   000054   5007         JNC     ??zclProcessInWriteUndividedCmd_3
   3869          		  dataLen++;
   \   000056   05..         INC     ?V4
   \   000058   04           INC     A
   \   000059   7002         JNZ     ??zclProcessInWriteUndividedCmd_3
   \   00005B   05..         INC     ?V5
   3870          		}
   3871          
   3872          		curLen += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   00005D   E5..         MOV     A,?V6
   \   00005F   25..         ADD     A,?V4
   \   000061   F5..         MOV     ?V6,A
   \   000063   E5..         MOV     A,?V7
   \   000065   35..         ADDC    A,?V5
   \   000067   F5..         MOV     ?V7,A
   \   000069   05..         INC     ?V3
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00006B   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   00006E   4003         JC      $+5
   \   000070   02....       LJMP    ??zclProcessInWriteUndividedCmd_4 & 0xFFFF
   \   000073   E5..         MOV     A,?V3
   \   000075   75F006       MOV     B,#0x6
   \   000078   A4           MUL     AB
   \   000079   F8           MOV     R0,A
   \   00007A   A9F0         MOV     R1,B
   \   00007C   85..82       MOV     DPL,?XSP + 0
   \   00007F   85..83       MOV     DPH,?XSP + 1
   \   000082   E0           MOVX    A,@DPTR
   \   000083   28           ADD     A,R0
   \   000084   FA           MOV     R2,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   39           ADDC    A,R1
   \   000088   8A82         MOV     DPL,R2
   \   00008A   F583         MOV     DPH,A
   \   00008C   A3           INC     DPTR
   \   00008D   8582..       MOV     ?V4,DPL
   \   000090   8583..       MOV     ?V5,DPH
   \   000093   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_357:
   \   000096   7408         MOV     A,#0x8
   \   000098   12....       LCALL   ?XSTACK_DISP0_8
   \   00009B   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00009E   12....       LCALL   ?XSTACK_DISP101_8
   \   0000A1   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   0000A4   12....       LCALL   ??findReadAttributeFn?relay; Banked call to: findReadAttributeFn
   \   0000A7   8A82         MOV     DPL,R2
   \   0000A9   8B83         MOV     DPH,R3
   \   0000AB   EE           MOV     A,R6
   \   0000AC   FA           MOV     R2,A
   \   0000AD   EF           MOV     A,R7
   \   0000AE   FB           MOV     R3,A
   \   0000AF   12....       LCALL   ?CALL_IND
   \   0000B2   7410         MOV     A,#0x10
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   6486         XRL     A,#0x86
   \   0000BA   700B         JNZ     ??zclProcessInWriteUndividedCmd_5
   \   0000BC   85..82       MOV     DPL,?V0
   \   0000BF   85..83       MOV     DPH,?V1
   \   0000C2   A3           INC     DPTR
   \   0000C3   7486         MOV     A,#-0x7a
   \   0000C5   8043         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_5:
   \   0000C7   740A         MOV     A,#0xa
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   F9           MOV     R1,A
   \   0000CE   85..82       MOV     DPL,?V4
   \   0000D1   85..83       MOV     DPH,?V5
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   69           XRL     A,R1
   \   0000D8   600B         JZ      ??zclProcessInWriteUndividedCmd_7
   \   0000DA   85..82       MOV     DPL,?V0
   \   0000DD   85..83       MOV     DPH,?V1
   \   0000E0   A3           INC     DPTR
   \   0000E1   748D         MOV     A,#-0x73
   \   0000E3   8025         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   0000E5   740B         MOV     A,#0xb
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   E0           MOVX    A,@DPTR
   \   0000EB   A2E1         MOV     C,0xE0 /* A   */.1
   \   0000ED   400B         JC      ??zclProcessInWriteUndividedCmd_8
   \   0000EF   85..82       MOV     DPL,?V0
   \   0000F2   85..83       MOV     DPH,?V1
   \   0000F5   A3           INC     DPTR
   \   0000F6   7488         MOV     A,#-0x78
   \   0000F8   8010         SJMP    ??zclProcessInWriteUndividedCmd_6
   \                     ??zclProcessInWriteUndividedCmd_8:
   \   0000FA   A2E5         MOV     C,0xE0 /* A   */.5
   \   0000FC   4003         JC      $+5
   \   0000FE   02....       LJMP    ??zclProcessInWriteUndividedCmd_2 & 0xFFFF
   \   000101   85..82       MOV     DPL,?V0
   \   000104   85..83       MOV     DPH,?V1
   \   000107   A3           INC     DPTR
   \   000108   747E         MOV     A,#0x7e
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00010A   F0           MOVX    @DPTR,A
   \   00010B   85..82       MOV     DPL,?V4
   \   00010E   85..83       MOV     DPH,?V5
   \   000111   12....       LCALL   ??Subroutine188_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_380:
   \   000114   12....       LCALL   ??Subroutine172_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000117   75..01       MOV     ?V2,#0x1
   3873          	} // for loop
   3874          
   3875          	writeRspCmd->numAttr = i;
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   00011A   85..82       MOV     DPL,?V0
   \   00011D   85..83       MOV     DPH,?V1
   \   000120   E5..         MOV     A,?V3
   \   000122   12....       LCALL   ?Subroutine22 & 0xFFFF
   3876          	if ( writeRspCmd->numAttr == writeCmd->numAttr ) {// All attributes can be written
   \                     ??CrossCallReturnLabel_17:
   \   000125   F8           MOV     R0,A
   \   000126   85..82       MOV     DPL,?V0
   \   000129   85..83       MOV     DPH,?V1
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   68           XRL     A,R0
   \   00012E   6003         JZ      $+5
   \   000130   02....       LJMP    ??zclProcessInWriteUndividedCmd_9 & 0xFFFF
   3877            
   3878              	uint8 *curDataPtr;
   3879              	zclWriteRec_t *curWriteRec; // containg data and meta-data of written attributes
   3880          
   3881              	uint8 hdrLen =sizeof( zclWriteRec_t )*  writeCmd->numAttr;
   \   000133   75F006       MOV     B,#0x6
   \   000136   E8           MOV     A,R0
   \   000137   A4           MUL     AB
   \   000138   FE           MOV     R6,A
   3882          
   3883              	curWriteRec = (zclWriteRec_t *) zcl_mem_alloc(  hdrLen+ curLen );
   \   000139                ; Setup parameters for call to function osal_mem_alloc
   \   000139   12....       LCALL   ??Subroutine181_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_354:
   \   00013C   12....       LCALL   ??osal_mem_alloc?relay; Banked call to: osal_mem_alloc
   \   00013F   7402         MOV     A,#0x2
   \   000141   12....       LCALL   ?XSTACK_DISP0_8
   \   000144   EA           MOV     A,R2
   \   000145   F0           MOVX    @DPTR,A
   \   000146   A3           INC     DPTR
   \   000147   EB           MOV     A,R3
   \   000148   F0           MOVX    @DPTR,A
   3884              	if ( curWriteRec == NULL ){
   \   000149   7402         MOV     A,#0x2
   \   00014B   12....       LCALL   ?XSTACK_DISP0_8
   \   00014E   12....       LCALL   ??Subroutine178_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_340:
   \   000151   700C         JNZ     ??zclProcessInWriteUndividedCmd_10
   3885          			zcl_mem_free(writeRspCmd );
   \   000153                ; Setup parameters for call to function osal_mem_free
   \   000153   AA..         MOV     R2,?V0
   \   000155   AB..         MOV     R3,?V1
   \   000157   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3886          			return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   00015A   7900         MOV     R1,#0x0
   \   00015C   02....       LJMP    ??zclProcessInWriteUndividedCmd_11 & 0xFFFF
   3887          		}
   3888          
   3889          		curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00015F   7402         MOV     A,#0x2
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   E0           MOVX    A,@DPTR
   \   000165   2E           ADD     A,R6
   \   000166   F8           MOV     R0,A
   \   000167   A3           INC     DPTR
   \   000168   E0           MOVX    A,@DPTR
   \   000169   3400         ADDC    A,#0x0
   \   00016B   F9           MOV     R1,A
   \   00016C   7404         MOV     A,#0x4
   \   00016E   12....       LCALL   ?XSTACK_DISP0_8
   \   000171   E8           MOV     A,R0
   \   000172   F0           MOVX    @DPTR,A
   \   000173   A3           INC     DPTR
   \   000174   E9           MOV     A,R1
   \   000175   12....       LCALL   ?Subroutine27 & 0xFFFF
   3890          
   3891          		// Write the new data over
   3892          		zclWriteRec_t *statusRec = &(writeCmd->attrList[0]);
   \                     ??CrossCallReturnLabel_26:
   \   000178   2401         ADD     A,#0x1
   \   00017A   F5..         MOV     ?V6,A
   \   00017C   A3           INC     DPTR
   \   00017D   E0           MOVX    A,@DPTR
   \   00017E   3400         ADDC    A,#0x0
   \   000180   F5..         MOV     ?V7,A
   3893          		zclWriteRec_t *curStatusRec = curWriteRec;
   \   000182   7402         MOV     A,#0x2
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   E0           MOVX    A,@DPTR
   \   000188   F5..         MOV     ?V14,A
   \   00018A   A3           INC     DPTR
   \   00018B   E0           MOVX    A,@DPTR
   \   00018C   F5..         MOV     ?V15,A
   3894          		for ( i = 0; i < writeCmd->numAttr; i++ ) {
   \   00018E   75..00       MOV     ?V3,#0x0
   \   000191   8039         SJMP    ??zclProcessInWriteUndividedCmd_12
   3895          			attrRec.attr.attrId = statusRec->attrID;
   3896          			readAttributeFn = findReadAttributeFn(pInMsg->msg->endPoint,pInMsg->msg->clusterId );
   3897          			readAttributeFn(&attrRec);	
   3898          												 
   3899          	
   3900          			dataLen = zclGetAttrDataLength( attrRec.attr.dataType, (uint8*)(attrRec.attr.dataPtr) );
   3901          			// Keep a copy of the current data before before writing the new data over
   3902          			curStatusRec->dataLen = dataLen;
   3903          			curStatusRec->attrID = statusRec->attrID;
   3904          			curStatusRec->attrData = curDataPtr;
   3905          			curStatusRec->dataType = attrRec.attr.dataType;
   3906            			zcl_memcpy(curDataPtr, attrRec.attr.dataPtr, dataLen );
   3907          			
   3908          			writeAttribute.attrId = statusRec->attrID;
   3909          			writeAttribute.dataPtr = statusRec->attrData;
   3910          			writeAttribute.dataType = statusRec->dataType;
   3911          			writeAttribute.len = dataLen;
   3912          			
   3913          			writeAttributeFn = findWriteAttributeFn(pInMsg->msg->endPoint,pInMsg->msg->clusterId);
   3914          			writeAttributeFn(&writeAttribute);			  
   3915          
   3916          			// If successful, a write attribute status record shall NOT be generated
   3917          			if ( writeAttribute.status != ZCL_STATUS_SUCCESS ) {
   3918          				writeRspCmd->attrList[j].status = writeAttribute.status;
   3919          				writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3920          
   3921          				// Since this write failed, we need to revert all the pervious writes
   3922          				zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   3923          				break;
   3924          			}
   3925          
   3926          			// add padding if needed
   3927          			if ( PADDING_NEEDED( dataLen ) ) {
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   000193   E5..         MOV     A,?V4
   \   000195   A2E0         MOV     C,0xE0 /* A   */.0
   \   000197   5007         JNC     ??zclProcessInWriteUndividedCmd_14
   3928          				dataLen++;
   \   000199   05..         INC     ?V4
   \   00019B   04           INC     A
   \   00019C   7002         JNZ     ??zclProcessInWriteUndividedCmd_14
   \   00019E   05..         INC     ?V5
   3929          			}
   3930          
   3931          			curDataPtr += dataLen;
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   0001A0   7404         MOV     A,#0x4
   \   0001A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001A5   E0           MOVX    A,@DPTR
   \   0001A6   25..         ADD     A,?V4
   \   0001A8   F8           MOV     R0,A
   \   0001A9   A3           INC     DPTR
   \   0001AA   E0           MOVX    A,@DPTR
   \   0001AB   35..         ADDC    A,?V5
   \   0001AD   F9           MOV     R1,A
   \   0001AE   7404         MOV     A,#0x4
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   3932          			statusRec++;
   \                     ??CrossCallReturnLabel_316:
   \   0001B6   E5..         MOV     A,?V6
   \   0001B8   2406         ADD     A,#0x6
   \   0001BA   F5..         MOV     ?V6,A
   \   0001BC   5002         JNC     ??zclProcessInWriteUndividedCmd_15
   \   0001BE   05..         INC     ?V7
   3933          			curStatusRec++;
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0001C0   E5..         MOV     A,?V14
   \   0001C2   2406         ADD     A,#0x6
   \   0001C4   F5..         MOV     ?V14,A
   \   0001C6   5002         JNC     ??zclProcessInWriteUndividedCmd_16
   \   0001C8   05..         INC     ?V15
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0001CA   05..         INC     ?V3
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0001CC   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   0001CF   4003         JC      $+5
   \   0001D1   02....       LJMP    ??zclProcessInWriteUndividedCmd_17 & 0xFFFF
   \   0001D4   85..82       MOV     DPL,?V6
   \   0001D7   85..83       MOV     DPH,?V7
   \   0001DA   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_358:
   \   0001DD   7408         MOV     A,#0x8
   \   0001DF   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E2   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   0001E5   12....       LCALL   ?XSTACK_DISP101_8
   \   0001E8   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0001EB   12....       LCALL   ??findReadAttributeFn?relay; Banked call to: findReadAttributeFn
   \   0001EE   8A82         MOV     DPL,R2
   \   0001F0   8B83         MOV     DPH,R3
   \   0001F2   EE           MOV     A,R6
   \   0001F3   FA           MOV     R2,A
   \   0001F4   EF           MOV     A,R7
   \   0001F5   FB           MOV     R3,A
   \   0001F6   12....       LCALL   ?CALL_IND
   \   0001F9                ; Setup parameters for call to function zclGetAttrDataLength
   \   0001F9   740C         MOV     A,#0xc
   \   0001FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FE   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_453:
   \   000201   740A         MOV     A,#0xa
   \   000203   12....       LCALL   ?XSTACK_DISP0_8
   \   000206   E0           MOVX    A,@DPTR
   \   000207   F9           MOV     R1,A
   \   000208   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   00020B   8A..         MOV     ?V4,R2
   \   00020D   8B..         MOV     ?V5,R3
   \   00020F   85..82       MOV     DPL,?V14
   \   000212   85..83       MOV     DPH,?V15
   \   000215   A3           INC     DPTR
   \   000216   A3           INC     DPTR
   \   000217   A3           INC     DPTR
   \   000218   A3           INC     DPTR
   \   000219   A3           INC     DPTR
   \   00021A   EA           MOV     A,R2
   \   00021B   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   00021E   F8           MOV     R0,A
   \   00021F   A3           INC     DPTR
   \   000220   E0           MOVX    A,@DPTR
   \   000221   F9           MOV     R1,A
   \   000222   85..82       MOV     DPL,?V14
   \   000225   85..83       MOV     DPH,?V15
   \   000228   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   00022B   7404         MOV     A,#0x4
   \   00022D   12....       LCALL   ?XSTACK_DISP0_8
   \   000230   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_359:
   \   000233   85..82       MOV     DPL,?V14
   \   000236   85..83       MOV     DPH,?V15
   \   000239   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   00023C   740A         MOV     A,#0xa
   \   00023E   12....       LCALL   ?XSTACK_DISP0_8
   \   000241   E0           MOVX    A,@DPTR
   \   000242   85..82       MOV     DPL,?V14
   \   000245   85..83       MOV     DPH,?V15
   \   000248   A3           INC     DPTR
   \   000249   A3           INC     DPTR
   \   00024A   F0           MOVX    @DPTR,A
   \   00024B                ; Setup parameters for call to function osal_memcpy
   \   00024B   740C         MOV     A,#0xc
   \   00024D   12....       LCALL   ?XSTACK_DISP0_8
   \   000250   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000253   75..00       MOV     ?V10,#0x0
   \   000256   78..         MOV     R0,#?V8
   \   000258   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00025B   AC..         MOV     R4,?V4
   \   00025D   AD..         MOV     R5,?V5
   \   00025F   7407         MOV     A,#0x7
   \   000261   12....       LCALL   ?XSTACK_DISP0_8
   \   000264   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_454:
   \   000267   12....       LCALL   ??osal_memcpy?relay  ; Banked call to: osal_memcpy
   \   00026A   7403         MOV     A,#0x3
   \   00026C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00026F   85..82       MOV     DPL,?V6
   \   000272   85..83       MOV     DPH,?V7
   \   000275   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000278   12....       LCALL   ?XSTACK_DISP0_8
   \   00027B   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00027E   12....       LCALL   ??Subroutine182_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_363:
   \   000281   7414         MOV     A,#0x14
   \   000283   12....       LCALL   ?XSTACK_DISP0_8
   \   000286   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   C0E0         PUSH    A
   \   00028C   7413         MOV     A,#0x13
   \   00028E   12....       LCALL   ?XSTACK_DISP0_8
   \   000291   D0E0         POP     A
   \   000293   F0           MOVX    @DPTR,A
   \   000294   7416         MOV     A,#0x16
   \   000296   12....       LCALL   ?XSTACK_DISP0_8
   \   000299   E5..         MOV     A,?V4
   \   00029B   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   00029E   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   0002A1   12....       LCALL   ?XSTACK_DISP101_8
   \   0002A4   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   0002A7   12....       LCALL   ??findWriteAttributeFn?relay; Banked call to: findWriteAttributeFn
   \   0002AA   8A82         MOV     DPL,R2
   \   0002AC   8B83         MOV     DPH,R3
   \   0002AE   EE           MOV     A,R6
   \   0002AF   FA           MOV     R2,A
   \   0002B0   EF           MOV     A,R7
   \   0002B1   FB           MOV     R3,A
   \   0002B2   12....       LCALL   ?CALL_IND
   \   0002B5   7417         MOV     A,#0x17
   \   0002B7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BA   E0           MOVX    A,@DPTR
   \   0002BB   FB           MOV     R3,A
   \   0002BC   7003         JNZ     $+5
   \   0002BE   02....       LJMP    ??zclProcessInWriteUndividedCmd_13 & 0xFFFF
   \   0002C1   E5..         MOV     A,?V2
   \   0002C3   75F003       MOV     B,#0x3
   \   0002C6   A4           MUL     AB
   \   0002C7   F8           MOV     R0,A
   \   0002C8   A9F0         MOV     R1,B
   \   0002CA   E5..         MOV     A,?V0
   \   0002CC   28           ADD     A,R0
   \   0002CD   F8           MOV     R0,A
   \   0002CE   E5..         MOV     A,?V1
   \   0002D0   39           ADDC    A,R1
   \   0002D1   F9           MOV     R1,A
   \   0002D2   EB           MOV     A,R3
   \   0002D3   8882         MOV     DPL,R0
   \   0002D5   8983         MOV     DPH,R1
   \   0002D7   A3           INC     DPTR
   \   0002D8   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   0002DB   12....       LCALL   ??Subroutine158_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   0002DE   EA           MOV     A,R2
   \   0002DF   F0           MOVX    @DPTR,A
   \   0002E0   A3           INC     DPTR
   \   0002E1   EB           MOV     A,R3
   \   0002E2   F0           MOVX    @DPTR,A
   \   0002E3   05..         INC     ?V2
   \   0002E5   85..82       MOV     DPL,?V3
   \   0002E8   8582..       MOV     ?V4,DPL
   \   0002EB   7402         MOV     A,#0x2
   \   0002ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0002F0   12....       LCALL   ?Subroutine88 & 0xFFFF
   3934          		} // for loop
   \                     ??CrossCallReturnLabel_142:
   \   0002F3   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   0002F6   F5..         MOV     ?V3,A
   \   0002F8   8882         MOV     DPL,R0
   \   0002FA   8983         MOV     DPH,R1
   \   0002FC   A3           INC     DPTR
   \   0002FD   A3           INC     DPTR
   \   0002FE   A3           INC     DPTR
   \   0002FF   A3           INC     DPTR
   \   000300   E0           MOVX    A,@DPTR
   \   000301   F5..         MOV     ?V10,A
   \   000303   A3           INC     DPTR
   \   000304   E0           MOVX    A,@DPTR
   \   000305   F5..         MOV     ?V11,A
   \   000307   75..00       MOV     ?V6,#0x0
   \   00030A   807A         SJMP    ??zclProcessInWriteUndividedCmd_18
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   00030C                ; Setup parameters for call to function findWriteAttributeFn
   \   00030C   AA..         MOV     R2,?V10
   \   00030E   AB..         MOV     R3,?V11
   \   000310   A9..         MOV     R1,?V3
   \   000312   12....       LCALL   ??findWriteAttributeFn?relay; Banked call to: findWriteAttributeFn
   \   000315   8A..         MOV     ?V14,R2
   \   000317   8B..         MOV     ?V15,R3
   \   000319   8E82         MOV     DPL,R6
   \   00031B   8F83         MOV     DPH,R7
   \   00031D   12....       LCALL   ??Subroutine183_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_360:
   \   000320   7418         MOV     A,#0x18
   \   000322   12....       LCALL   ?XSTACK_DISP0_8
   \   000325   12....       LCALL   ??Subroutine174_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   000328   EE           MOV     A,R6
   \   000329   2403         ADD     A,#0x3
   \   00032B   F8           MOV     R0,A
   \   00032C   E4           CLR     A
   \   00032D   3F           ADDC    A,R7
   \   00032E   F9           MOV     R1,A
   \   00032F   8882         MOV     DPL,R0
   \   000331   8983         MOV     DPH,R1
   \   000333   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_455:
   \   000336   741B         MOV     A,#0x1b
   \   000338   12....       LCALL   ?XSTACK_DISP0_8
   \   00033B   EA           MOV     A,R2
   \   00033C   F0           MOVX    @DPTR,A
   \   00033D   A3           INC     DPTR
   \   00033E   EB           MOV     A,R3
   \   00033F   F0           MOVX    @DPTR,A
   \   000340   EE           MOV     A,R6
   \   000341   2402         ADD     A,#0x2
   \   000343   FA           MOV     R2,A
   \   000344   E4           CLR     A
   \   000345   3F           ADDC    A,R7
   \   000346   FB           MOV     R3,A
   \   000347   EA           MOV     A,R2
   \   000348   FC           MOV     R4,A
   \   000349   EB           MOV     A,R3
   \   00034A   FD           MOV     R5,A
   \   00034B   8C82         MOV     DPL,R4
   \   00034D   8D83         MOV     DPH,R5
   \   00034F   E0           MOVX    A,@DPTR
   \   000350   C0E0         PUSH    A
   \   000352   741A         MOV     A,#0x1a
   \   000354   12....       LCALL   ?XSTACK_DISP0_8
   \   000357   D0E0         POP     A
   \   000359   12....       LCALL   ??Subroutine202_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_476:
   \   00035C   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_456:
   \   00035F   8C82         MOV     DPL,R4
   \   000361   8D83         MOV     DPH,R5
   \   000363   E0           MOVX    A,@DPTR
   \   000364   F9           MOV     R1,A
   \   000365   12....       LCALL   ??zclGetAttrDataLength?relay; Banked call to: zclGetAttrDataLength
   \   000368   741D         MOV     A,#0x1d
   \   00036A   12....       LCALL   ?XSTACK_DISP0_8
   \   00036D   EA           MOV     A,R2
   \   00036E   F0           MOVX    @DPTR,A
   \   00036F                ; Setup parameters for indirect call
   \   00036F   7418         MOV     A,#0x18
   \   000371   12....       LCALL   ?XSTACK_DISP101_8
   \   000374   85..82       MOV     DPL,?V14
   \   000377   85..83       MOV     DPH,?V15
   \   00037A   12....       LCALL   ?CALL_IND
   \   00037D   EE           MOV     A,R6
   \   00037E   2406         ADD     A,#0x6
   \   000380   FE           MOV     R6,A
   \   000381   5001         JNC     ??zclProcessInWriteUndividedCmd_20
   \   000383   0F           INC     R7
   \                     ??zclProcessInWriteUndividedCmd_20:
   \   000384   05..         INC     ?V6
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   000386   A8..         MOV     R0,?V4
   \   000388   E5..         MOV     A,?V6
   \   00038A   C3           CLR     C
   \   00038B   98           SUBB    A,R0
   \   00038C   5003         JNC     $+5
   \   00038E   02....       LJMP    ??zclProcessInWriteUndividedCmd_19 & 0xFFFF
   3935          
   3936              	writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000391   85..82       MOV     DPL,?V0
   \   000394   85..83       MOV     DPH,?V1
   \   000397   E5..         MOV     A,?V2
   \   000399   F0           MOVX    @DPTR,A
   3937              	if ( writeRspCmd->numAttr  == 0 )  {
   \   00039A   7004         JNZ     ??CrossCallReturnLabel_48
   3938                		// Since all records were written successful, include a single status record in the resonse command with the status field set to SUCCESS and the attribute ID field omitted.
   3939                		writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   00039C   A3           INC     DPTR
   \   00039D   12....       LCALL   ?Subroutine43 & 0xFFFF
   3940                		writeRspCmd->numAttr = 1;
   3941              	}
   3942          
   3943              	zcl_mem_free( curWriteRec );
   \                     ??CrossCallReturnLabel_48:
   \   0003A0                ; Setup parameters for call to function osal_mem_free
   \   0003A0   7402         MOV     A,#0x2
   \   0003A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A5   12....       LCALL   ??Subroutine198_0 & 0xFFFF
   3944            	}
   \                     ??CrossCallReturnLabel_457:
   \   0003A8   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3945          
   3946            	zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId, writeRspCmd, !pInMsg->hdr.fc.direction, true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   0003AB   85..82       MOV     DPL,?V12
   \   0003AE   85..83       MOV     DPH,?V13
   \   0003B1   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   0003B4   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_305:
   \   0003B7   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003BA   75..01       MOV     ?V2,#0x1
   \   0003BD   78..         MOV     R0,#?V2
   \   0003BF   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003C2   85..82       MOV     DPL,?V12
   \   0003C5   85..83       MOV     DPH,?V13
   \   0003C8   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_470:
   \   0003CB   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0003CE   78..         MOV     R0,#?V0
   \   0003D0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0003D3   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   0003D6   12....       LCALL   ??zcl_SendWriteRsp?relay; Banked call to: zcl_SendWriteRsp
   \   0003D9   7405         MOV     A,#0x5
   \   0003DB   12....       LCALL   ?DEALLOC_XSTACK8
   3947            	zcl_mem_free( writeRspCmd );
   \   0003DE                ; Setup parameters for call to function osal_mem_free
   \   0003DE   AA..         MOV     R2,?V0
   \   0003E0   AB..         MOV     R3,?V1
   \   0003E2   12....       LCALL   ??osal_mem_free?relay; Banked call to: osal_mem_free
   3948          
   3949            	return TRUE;
   \   0003E5   7901         MOV     R1,#0x1
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   0003E7   741F         MOV     A,#0x1f
   \   0003E9                REQUIRE ?Subroutine4
   \   0003E9                ; // Fall through to label ?Subroutine4
   3950          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   12....       LCALL   ??Subroutine193_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_417:
   \   000003                ; Setup parameters for call to function zcl_SendWriteRsp
   \   000003   85..82       MOV     DPL,?V12
   \   000006   85..83       MOV     DPH,?V13
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine127 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   F8           MOV     R0,A
   \   00000B   E5..         MOV     A,?V3
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   EA           MOV     A,R2
   \   000001   FE           MOV     R6,A
   \   000002   EB           MOV     A,R3
   \   000003   FF           MOV     R7,A
   \   000004                ; Setup parameters for call to function findReadAttributeFn
   \   000004                ; Setup parameters for call to function findReadAttributeFn
   \   000004                ; Setup parameters for call to function findWriteAttributeFn
   \   000004   8882         MOV     DPL,R0
   \   000006   8983         MOV     DPH,R1
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ?Subroutine140 & 0xFFFF
   \                     ??CrossCallReturnLabel_460:
   \   00000F   12....       LCALL   ?Subroutine143 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000012   F9           MOV     R1,A
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V6
   \   000004   85..83       MOV     DPH,?V7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   85..82       MOV     DPL,?V6
   \   000008   85..83       MOV     DPH,?V7
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine123 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   F8           MOV     R0,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   F583         MOV     DPH,A
   \   000008   8882         MOV     DPL,R0
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine119 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000007   12....       LCALL   ?Subroutine138 & 0xFFFF
   \                     ??CrossCallReturnLabel_384:
   \   00000A                ; Setup parameters for indirect call
   \   00000A                ; Setup parameters for indirect call
   \   00000A   7406         MOV     A,#0x6
   \   00000C   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DB 255

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_event_loop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerForMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerForMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_HandleExternal?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_HandleExternal

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getRawAFMsg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getRawAFMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_getParsedTransSeqNum?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_getParsedTransSeqNum

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerPlugin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerPlugin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerClusterOptionList?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerClusterOptionList

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_registerValidateAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_registerValidateAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_DeviceOperational?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_DeviceOperational

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendCommand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendCommand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRequest?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRequest

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendWriteRsp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendWriteRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_SendDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_SendDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_ProcessMessageMSG?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_ProcessMessageMSG

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclBuildHdr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclBuildHdr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclFindClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclFindClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetClusterOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetClusterOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSetSecurityOption?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSetSecurityOption

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclSerializeData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclSerializeData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclAnalogDataType?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclAnalogDataType

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zcl_BuildAnalogData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zcl_BuildAnalogData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetDataTypeLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetDataTypeLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclGetAttrDataLength?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclGetAttrDataLength

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclReadAttrData?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclReadAttrData

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInWriteRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInWriteRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInConfigReportRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInConfigReportRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReadReportCfgRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReadReportCfgRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInReportCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInReportCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclParseInDefaultRspCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclParseInDefaultRspCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInReadCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInReadCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteCmd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??zclProcessInWriteUndividedCmd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zclProcessInWriteUndividedCmd
   3951          #endif // ZCL_WRITE
   3952          
   3953          #ifdef ZCL_DISCOVER
   3954          /*********************************************************************
   3955           * @fn      zclProcessInDiscAttrs
   3956           *
   3957           * @brief   Process the "Profile" Discover Attributes Commands
   3958           *
   3959           * @param   pInMsg - incoming message to process
   3960           *
   3961           * @return  TRUE if command processed. FALSE, otherwise.
   3962           */
   3963          static uint8 zclProcessInDiscAttrs( zclIncoming_t *pInMsg )
   3964          {
   3965            zclDiscoverAttrsCmd_t *pDiscoverCmd;
   3966            zclAttrRec_t attrRec;
   3967            uint16 attrID;
   3968            uint8 numAttrs;
   3969            uint8 i;
   3970          
   3971            pDiscoverCmd = (zclDiscoverAttrsCmd_t *)pInMsg->attrCmd;
   3972          
   3973            // Find out the number of attributes supported within the specified range
   3974            for ( i = 0, attrID = pDiscoverCmd->startAttr; i < pDiscoverCmd->maxAttrIDs; i++, attrID++ )
   3975            {
   3976              // finds the next attribute on this endpoint/cluster after the range.
   3977              // attributes must be in numerical order in the list.
   3978              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   3979              {
   3980                break;
   3981              }
   3982            }
   3983          
   3984            numAttrs = i;  // store range of attributes in buffer
   3985          
   3986              // Process message for either attributes or extended attributes
   3987            if( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS )
   3988            {
   3989              zclProcessInDiscAttrsCmd( pInMsg, pDiscoverCmd, numAttrs );
   3990            }
   3991            else if ( pInMsg->hdr.commandID == ZCL_CMD_DISCOVER_ATTRS_EXT )
   3992            {
   3993              zclProcessInDiscAttrsExtCmd( pInMsg, pDiscoverCmd, numAttrs );
   3994            }
   3995          
   3996            return TRUE;
   3997          }
   3998          
   3999          /*********************************************************************
   4000           * @fn      zclProcessInDiscAttrsCmd
   4001           *
   4002           * @brief   Process the Discover Attributes Command
   4003           *
   4004           * @param   pInMsg - incoming message to process
   4005           *
   4006           * @param   pDiscoverCmd - structure from requesting command
   4007           *
   4008           * @param   attrLenBuf - describes the amount of attributes to be processed
   4009           *
   4010           * @return  none
   4011           */
   4012          static void zclProcessInDiscAttrsCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4013          {
   4014            zclDiscoverAttrsRspCmd_t *pDiscoverRsp;
   4015            uint8 discComplete = TRUE;
   4016            zclAttrRec_t attrRec;
   4017            uint16 attrID;
   4018            uint8 i;
   4019          
   4020            // Allocate space for the response command
   4021            pDiscoverRsp = (zclDiscoverAttrsRspCmd_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsRspCmd_t)
   4022                                                                    + sizeof ( zclDiscoverAttrInfo_t ) * numAttrs );
   4023            if ( pDiscoverRsp == NULL )
   4024            {
   4025              return; // EMBEDDED RETURN
   4026            }
   4027          
   4028            if ( numAttrs != 0 )
   4029            {
   4030              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4031              {
   4032                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4033                {
   4034                  break; // should not happen, as numAttrs already calculated
   4035                }
   4036          
   4037                pDiscoverRsp->attrList[i].attrID = attrRec.attr.attrId;
   4038                pDiscoverRsp->attrList[i].dataType = attrRec.attr.dataType;
   4039              }
   4040          
   4041              // Are there more attributes to be discovered?
   4042              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4043              {
   4044                discComplete = FALSE;
   4045              }
   4046            }
   4047          
   4048            pDiscoverRsp->discComplete = discComplete;
   4049            pDiscoverRsp->numAttr = numAttrs;
   4050          
   4051            zcl_SendDiscoverAttrsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4052                                         pInMsg->msg->clusterId, pDiscoverRsp, !(pInMsg->hdr.fc.direction),
   4053                                         true, pInMsg->hdr.transSeqNum );
   4054            zcl_mem_free( pDiscoverRsp );
   4055          
   4056            return;
   4057          }
   4058          
   4059          /*********************************************************************
   4060           * @fn      zclProcessInDiscAttrsExtCmd
   4061           *
   4062           * @brief   Process the Discover Attributes Extended Command
   4063           *
   4064           * @param   pInMsg - incoming message to process
   4065           *
   4066           * @param   pDiscoverCmd - structure from requesting command
   4067           *
   4068           * @param   attrLenBuf - describes the amount of attributes to be processed
   4069           *
   4070           * @return  none
   4071           */
   4072          static void zclProcessInDiscAttrsExtCmd( zclIncoming_t *pInMsg, zclDiscoverAttrsCmd_t *pDiscoverCmd, uint8 numAttrs )
   4073          {
   4074            zclDiscoverAttrsExtRsp_t *pDiscoverExtRsp;
   4075            uint8 discComplete = TRUE;
   4076            zclAttrRec_t attrRec;
   4077            uint16 attrID;
   4078            uint8 i;
   4079          
   4080              // Allocate space for the response command
   4081            pDiscoverExtRsp = (zclDiscoverAttrsExtRsp_t *)zcl_mem_alloc( sizeof (zclDiscoverAttrsExtRsp_t)
   4082                                                                   + sizeof ( zclExtAttrInfo_t ) * numAttrs );
   4083            if ( pDiscoverExtRsp == NULL )
   4084            {
   4085              return; // EMBEDDED RETURN
   4086            }
   4087          
   4088          
   4089            if ( numAttrs != 0 )
   4090            {
   4091              for ( i = 0, attrID = pDiscoverCmd->startAttr; i < numAttrs; i++, attrID++ )
   4092              {
   4093                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4094                {
   4095                  break; // Should not happen, as numAttrs already calculated
   4096                }
   4097          
   4098                pDiscoverExtRsp->aExtAttrInfo[i].attrID = attrRec.attr.attrId;
   4099                pDiscoverExtRsp->aExtAttrInfo[i].attrDataType = attrRec.attr.dataType;
   4100                pDiscoverExtRsp->aExtAttrInfo[i].attrAccessControl = attrRec.attr.accessControl & ACCESS_CONTROLEXT_MASK;
   4101              }
   4102          
   4103              // Are there more attributes to be discovered?
   4104              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.fc.direction, &attrID, &attrRec ) )
   4105              {
   4106                discComplete = FALSE;
   4107              }
   4108            }
   4109          
   4110            pDiscoverExtRsp->discComplete = discComplete;
   4111            pDiscoverExtRsp->numAttr = numAttrs;
   4112          
   4113            zcl_SendDiscoverAttrsExtRsp( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4114                                         pInMsg->msg->clusterId, pDiscoverExtRsp, !(pInMsg->hdr.fc.direction),
   4115                                         true, pInMsg->hdr.transSeqNum );
   4116          
   4117            zcl_mem_free( pDiscoverExtRsp );
   4118          
   4119            return;
   4120          }
   4121          
   4122          /*********************************************************************
   4123           * @fn      zclProcessInDiscCmd
   4124           *
   4125           * @brief   Process the "Profile" Discover Command
   4126           *
   4127           * @param   pInMsg - incoming message to process
   4128           *
   4129           * @return  TRUE if command processed. FALSE, otherwise.
   4130           */
   4131          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   4132          {
   4133            zclDiscoverCmdsCmd_t *pDiscoverCmd;
   4134            zclDiscoverCmdsCmdRsp_t cmdRsp;
   4135            ZStatus_t status;
   4136            zclCommandRec_t cmdRec;
   4137            uint8 cmdID;
   4138            uint8 i;
   4139            uint8 j;
   4140          
   4141            pDiscoverCmd = (zclDiscoverCmdsCmd_t *)pInMsg->attrCmd;
   4142          
   4143            // Find out the number of commands supported within the specified range
   4144            for ( i = 0, cmdID = pDiscoverCmd->startCmdID; i < pDiscoverCmd->maxCmdID; i++, cmdID++ )
   4145            {
   4146              if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4147              {
   4148                break;  // Command not supported
   4149              }
   4150            }
   4151          
   4152            // Allocate space for the response command
   4153            cmdRsp.pCmdID = zcl_mem_alloc( i ); // size of number of commands returned
   4154          
   4155            if ( cmdRsp.pCmdID == NULL )
   4156            {
   4157              return FALSE; // EMBEDDED RETURN
   4158            }
   4159          
   4160            if ( i != 0 )
   4161            {
   4162              for ( j = 0, cmdID = pDiscoverCmd->startCmdID; j < i; j++, cmdID++ )
   4163              {
   4164                if ( !zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4165                {
   4166                  break; // Attribute not supported
   4167                }
   4168          
   4169                cmdRsp.pCmdID[j] = cmdRec.cmdID;
   4170              }
   4171            }
   4172          
   4173            // Are there more commands to be discovered?
   4174            if ( zclFindNextCmdRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, pInMsg->hdr.commandID, pInMsg->hdr.fc.direction, &cmdID, &cmdRec ) )
   4175            {
   4176              cmdRsp.discComplete = FALSE;
   4177            }
   4178            else
   4179            {
   4180              cmdRsp.discComplete = TRUE;
   4181            }
   4182          
   4183            // pass the command requested
   4184            cmdRsp.cmdType = pInMsg->hdr.commandID;
   4185          
   4186            // store number of commands returned
   4187            cmdRsp.numCmd = j;
   4188          
   4189            status = zcl_SendDiscoverCmdsRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   4190                                                pInMsg->msg->clusterId, &cmdRsp, !(pInMsg->hdr.fc.direction),
   4191                                                true, pInMsg->hdr.transSeqNum );
   4192          
   4193            zcl_mem_free( cmdRsp.pCmdID );
   4194          
   4195            if ( status == ZSuccess )
   4196            {
   4197              return TRUE;
   4198            }
   4199            else
   4200            {
   4201              return FALSE;
   4202            }
   4203          }
   4204          
   4205          #endif // ZCL_DISCOVER
   4206          
   4207          /*********************************************************************
   4208          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     24   zclAnalogDataType
      1     42   zclBuildHdr
      0     19   zclFindClusterOption
      0     64   zclGetAttrDataLength
        0      9   -> zclGetDataTypeLength
      0     47   zclGetClusterOption
        0     10   -> zclFindClusterOption
      0     24   zclGetDataTypeLength
      1     49   zclParseHdr
        0     12   -> osal_memset
      1     20   zclParseInConfigReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_memset
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     11   zclParseInConfigReportRspCmd
        0     11   -> osal_mem_alloc
      1     10   zclParseInDefaultRspCmd
        0     10   -> osal_mem_alloc
      1     12   zclParseInReadCmd
        0     12   -> osal_mem_alloc
      1     12   zclParseInReadReportCfgCmd
        0     12   -> osal_mem_alloc
      1     20   zclParseInReadReportCfgRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> zclAnalogDataType
        0     20   -> zclGetDataTypeLength
        0     20   -> zcl_BuildAnalogData
      1     25   zclParseInReadRspCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInReportCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     25   zclParseInWriteCmd
        0     22   -> osal_mem_alloc
        0     25   -> osal_memcpy
        0     22   -> zclGetAttrDataLength
      1     16   zclParseInWriteRspCmd
        0     16   -> osal_mem_alloc
      1     36   zclProcessInReadCmd
        0     31   -> findReadAttributeFn
        0     31   -> osal_mem_alloc
        0     31   -> osal_mem_free
        0     36   -> zcl_SendReadRsp
      1     38   zclProcessInWriteCmd
        0     33   -> findWriteAttributeFn
        0     33   -> osal_mem_alloc
        0     33   -> osal_mem_free
        0     33   -> zclGetAttrDataLength
        0     38   -> zcl_SendWriteRsp
      1     60   zclProcessInWriteUndividedCmd
        0     55   -> findReadAttributeFn
        0     55   -> findWriteAttributeFn
        0     55   -> osal_mem_alloc
        0     55   -> osal_mem_free
        0     58   -> osal_memcpy
        0     55   -> zclGetAttrDataLength
        0     60   -> zcl_SendWriteRsp
      0     46   zclReadAttrData
        0     18   -> osal_memcpy
        0     15   -> zclGetAttrDataLength
      1     42   zclSerializeData
        0     18   -> osal_buffer_uint32
        0     17   -> osal_memcpy
      0     47   zclSetSecurityOption
        0     10   -> zclFindClusterOption
      1     36   zcl_BuildAnalogData
        0     16   -> zclGetAttrDataLength
      0     67   zcl_DeviceOperational
        0     26   -> findReadAttributeFn
        0     28   -> zclReadAttrData
      1     10   zcl_HandleExternal
        0     10   -> osal_msg_allocate
        0     10   -> osal_msg_send
      2      0   zcl_Init
      1     56   zcl_ProcessMessageMSG
        0     37   -> afFindEndPointDesc
        0     37   -> osal_mem_free
        0     37   -> zclGetClusterOption
        0     37   -> zclParseHdr
        0     37   -> zclSetSecurityOption
        0     39   -> zcl_DeviceOperational
        0     44   -> zcl_SendDefaultRspCmd
      1     74   zcl_SendCommand
        0     39   -> AF_DataRequest
        0     30   -> afFindEndPointDesc
        0     30   -> osal_mem_alloc
        0     30   -> osal_mem_free
        0     33   -> osal_memcpy
        0     30   -> osal_memset
        0     33   -> zclBuildHdr
        0     30   -> zclGetClusterOption
        0     32   -> zcl_DeviceOperational
      1     40   zcl_SendConfigReportCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     36   zcl_SendConfigReportRspCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     67   zcl_SendDefaultRspCmd
        0     23   -> zcl_SendCommand
      1     36   zcl_SendRead
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReadReportCfgCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      1     40   zcl_SendReadReportCfgRspCmd
        0     24   -> osal_mem_alloc
        0     24   -> osal_mem_free
        0     24   -> zclAnalogDataType
        0     24   -> zclGetDataTypeLength
        0     24   -> zclSerializeData
        0     35   -> zcl_SendCommand
      1     67   zcl_SendReadRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     36   zcl_SendReportCmd
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     37   zcl_SendWriteRequest
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     20   -> zclGetAttrDataLength
        0     20   -> zclSerializeData
        0     31   -> zcl_SendCommand
      1     91   zcl_SendWriteRsp
        0     20   -> osal_mem_alloc
        0     20   -> osal_mem_free
        0     31   -> zcl_SendCommand
      0     12   zcl_event_loop
        0     12   -> osal_msg_deallocate
        0     12   -> osal_msg_receive
        0     12   -> osal_msg_send
        0     12   -> zcl_ProcessMessageMSG
      2      0   zcl_getParsedTransSeqNum
      2      0   zcl_getRawAFMsg
      1     12   zcl_registerClusterOptionList
        0     12   -> osal_mem_alloc
      2      0   zcl_registerForMsg
      0     14   zcl_registerPlugin
        0     12   -> osal_mem_alloc
      2      0   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       6  ??Subroutine155_0
       5  ??Subroutine156_0
       9  ??Subroutine157_0
      11  ??Subroutine158_0
       7  ??Subroutine159_0
       5  ??Subroutine160_0
       7  ??Subroutine161_0
       1  ??Subroutine162_0
       4  ??Subroutine163_0
       6  ??Subroutine164_0
       4  ??Subroutine165_0
      12  ??Subroutine166_0
       9  ??Subroutine167_0
       9  ??Subroutine168_0
       5  ??Subroutine169_0
       8  ??Subroutine170_0
       6  ??Subroutine171_0
       1  ??Subroutine172_0
       1  ??Subroutine173_0
       6  ??Subroutine174_0
       5  ??Subroutine175_0
       7  ??Subroutine176_0
       2  ??Subroutine177_0
       6  ??Subroutine178_0
       5  ??Subroutine179_0
       4  ??Subroutine180_0
       8  ??Subroutine181_0
       1  ??Subroutine182_0
       4  ??Subroutine183_0
      14  ??Subroutine184_0
       3  ??Subroutine185_0
      13  ??Subroutine186_0
       7  ??Subroutine187_0
      10  ??Subroutine188_0
       9  ??Subroutine189_0
       8  ??Subroutine190_0
       1  ??Subroutine191_0
       5  ??Subroutine192_0
       6  ??Subroutine193_0
      36  ??Subroutine194_0
       9  ??Subroutine195_0
       5  ??Subroutine196_0
       6  ??Subroutine197_0
       4  ??Subroutine198_0
      10  ??Subroutine199_0
       8  ??Subroutine200_0
       5  ??Subroutine201_0
       6  ??Subroutine202_0
       6  ??zclAnalogDataType?relay
       6  ??zclBuildHdr?relay
       6  ??zclFindClusterOption?relay
       6  ??zclGetAttrDataLength?relay
       6  ??zclGetClusterOption?relay
       6  ??zclGetDataTypeLength?relay
       6  ??zclParseHdr?relay
       6  ??zclParseInConfigReportCmd?relay
       6  ??zclParseInConfigReportRspCmd?relay
       6  ??zclParseInDefaultRspCmd?relay
       6  ??zclParseInReadCmd?relay
       6  ??zclParseInReadReportCfgCmd?relay
       6  ??zclParseInReadReportCfgRspCmd?relay
       6  ??zclParseInReadRspCmd?relay
       6  ??zclParseInReportCmd?relay
       6  ??zclParseInWriteCmd?relay
       6  ??zclParseInWriteRspCmd?relay
       6  ??zclProcessInReadCmd?relay
       6  ??zclProcessInWriteCmd?relay
       6  ??zclProcessInWriteUndividedCmd?relay
       6  ??zclReadAttrData?relay
       6  ??zclSerializeData?relay
       6  ??zclSetSecurityOption?relay
       6  ??zcl_BuildAnalogData?relay
       6  ??zcl_DeviceOperational?relay
       6  ??zcl_HandleExternal?relay
       6  ??zcl_Init?relay
       6  ??zcl_ProcessMessageMSG?relay
       6  ??zcl_SendCommand?relay
       6  ??zcl_SendConfigReportCmd?relay
       6  ??zcl_SendConfigReportRspCmd?relay
       6  ??zcl_SendDefaultRspCmd?relay
       6  ??zcl_SendRead?relay
       6  ??zcl_SendReadReportCfgCmd?relay
       6  ??zcl_SendReadReportCfgRspCmd?relay
       6  ??zcl_SendReadRsp?relay
       6  ??zcl_SendReportCmd?relay
       6  ??zcl_SendWriteRequest?relay
       6  ??zcl_SendWriteRsp?relay
       6  ??zcl_event_loop?relay
       6  ??zcl_getParsedTransSeqNum?relay
       6  ??zcl_getRawAFMsg?relay
       6  ??zcl_registerClusterOptionList?relay
       6  ??zcl_registerForMsg?relay
       6  ??zcl_registerPlugin?relay
       6  ??zcl_registerValidateAttrData?relay
       7  ?Subroutine0
       5  ?Subroutine1
       5  ?Subroutine10
       8  ?Subroutine100
      13  ?Subroutine101
       9  ?Subroutine102
      12  ?Subroutine103
      12  ?Subroutine104
      13  ?Subroutine105
      12  ?Subroutine106
      15  ?Subroutine107
      21  ?Subroutine108
       5  ?Subroutine109
      43  ?Subroutine11
      11  ?Subroutine110
       3  ?Subroutine111
      12  ?Subroutine112
      15  ?Subroutine113
      13  ?Subroutine114
       2  ?Subroutine115
       9  ?Subroutine116
      11  ?Subroutine117
       3  ?Subroutine118
       8  ?Subroutine119
       3  ?Subroutine12
      11  ?Subroutine120
       8  ?Subroutine121
       6  ?Subroutine122
       9  ?Subroutine123
       7  ?Subroutine124
       5  ?Subroutine125
      12  ?Subroutine126
       8  ?Subroutine127
      14  ?Subroutine128
       1  ?Subroutine129
      12  ?Subroutine13
      13  ?Subroutine130
      11  ?Subroutine131
      11  ?Subroutine132
      10  ?Subroutine133
       4  ?Subroutine134
       4  ?Subroutine135
      11  ?Subroutine136
       9  ?Subroutine137
       5  ?Subroutine138
       4  ?Subroutine139
      12  ?Subroutine14
       6  ?Subroutine140
       9  ?Subroutine141
       5  ?Subroutine142
       9  ?Subroutine143
      11  ?Subroutine144
      11  ?Subroutine145
      12  ?Subroutine146
       7  ?Subroutine147
       8  ?Subroutine148
      13  ?Subroutine149
       6  ?Subroutine15
       7  ?Subroutine150
       6  ?Subroutine151
       5  ?Subroutine152
       6  ?Subroutine153
       8  ?Subroutine154
       4  ?Subroutine16
      22  ?Subroutine17
      15  ?Subroutine18
      12  ?Subroutine19
       5  ?Subroutine2
      24  ?Subroutine20
      13  ?Subroutine21
      12  ?Subroutine22
      20  ?Subroutine23
      17  ?Subroutine24
      18  ?Subroutine25
       2  ?Subroutine26
       4  ?Subroutine27
      18  ?Subroutine28
      14  ?Subroutine29
       3  ?Subroutine3
      14  ?Subroutine30
      10  ?Subroutine31
       1  ?Subroutine32
      12  ?Subroutine33
       4  ?Subroutine34
      10  ?Subroutine35
       3  ?Subroutine36
      29  ?Subroutine37
      14  ?Subroutine38
       1  ?Subroutine39
       3  ?Subroutine4
      15  ?Subroutine40
       4  ?Subroutine41
       7  ?Subroutine42
      11  ?Subroutine43
      10  ?Subroutine44
       9  ?Subroutine45
       7  ?Subroutine46
       3  ?Subroutine47
      20  ?Subroutine48
      32  ?Subroutine49
       4  ?Subroutine5
       6  ?Subroutine50
      18  ?Subroutine51
       6  ?Subroutine52
       2  ?Subroutine53
       6  ?Subroutine54
       3  ?Subroutine55
      25  ?Subroutine56
      18  ?Subroutine57
       6  ?Subroutine58
       1  ?Subroutine59
       5  ?Subroutine6
      10  ?Subroutine60
       5  ?Subroutine61
      23  ?Subroutine62
       6  ?Subroutine63
       4  ?Subroutine64
      11  ?Subroutine65
       4  ?Subroutine66
       8  ?Subroutine67
       7  ?Subroutine68
       6  ?Subroutine69
       5  ?Subroutine7
      14  ?Subroutine70
      16  ?Subroutine71
      15  ?Subroutine72
      32  ?Subroutine73
      22  ?Subroutine74
       8  ?Subroutine75
      12  ?Subroutine76
       4  ?Subroutine77
       6  ?Subroutine78
       5  ?Subroutine79
       9  ?Subroutine8
       5  ?Subroutine80
       6  ?Subroutine81
       5  ?Subroutine82
      16  ?Subroutine83
       6  ?Subroutine84
       4  ?Subroutine85
      10  ?Subroutine86
      10  ?Subroutine87
      10  ?Subroutine88
       8  ?Subroutine89
       4  ?Subroutine9
      12  ?Subroutine90
      11  ?Subroutine91
       8  ?Subroutine92
       4  ?Subroutine93
       2  ?Subroutine94
       4  ?Subroutine95
       7  ?Subroutine96
       4  ?Subroutine97
      21  ?Subroutine98
      10  ?Subroutine99
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
       1  savedZCLTransSeqNum
      33  zclAnalogDataType
      75  zclBuildHdr
      92  zclCmdTable
     103  zclFindClusterOption
      63  zclGetAttrDataLength
      28  zclGetClusterOption
     166  zclGetDataTypeLength
     196  zclParseHdr
     342  zclParseInConfigReportCmd
     120  zclParseInConfigReportRspCmd
      33  zclParseInDefaultRspCmd
     102  zclParseInReadCmd
      72  zclParseInReadReportCfgCmd
     342  zclParseInReadReportCfgRspCmd
     276  zclParseInReadRspCmd
     152  zclParseInReportCmd
     149  zclParseInWriteCmd
     107  zclParseInWriteRspCmd
     303  zclProcessInReadCmd
     393  zclProcessInWriteCmd
    1001  zclProcessInWriteUndividedCmd
     114  zclReadAttrData
     343  zclSerializeData
      45  zclSetSecurityOption
     126  zcl_BuildAnalogData
     108  zcl_DeviceOperational
     161  zcl_HandleExternal
      12  zcl_Init
    1085  zcl_ProcessMessageMSG
       1  zcl_RegisteredMsgTaskID
     435  zcl_SendCommand
     339  zcl_SendConfigReportCmd
     254  zcl_SendConfigReportRspCmd
     137  zcl_SendDefaultRspCmd
     204  zcl_SendRead
     171  zcl_SendReadReportCfgCmd
     378  zcl_SendReadReportCfgRspCmd
     311  zcl_SendReadRsp
     211  zcl_SendReportCmd
     214  zcl_SendWriteRequest
     183  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       2  zcl_ValidateAttrDataCB
      93  zcl_event_loop
       9  zcl_getParsedTransSeqNum
      12  zcl_getRawAFMsg
      84  zcl_registerClusterOptionList
      24  zcl_registerForMsg
      94  zcl_registerPlugin
      17  zcl_registerValidateAttrData

 
 11 056 bytes in segment BANKED_CODE
    276 bytes in segment BANK_RELAYS
     92 bytes in segment CODE_C
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     12 bytes in segment XDATA_Z
 
 11 425 bytes of CODE  memory
     13 bytes of XDATA memory

Errors: none
Warnings: 1
