///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.30.1.41636 for 8051            04/Nov/2015  16:51:12 /
// Copyright 2004-2013 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//                                                                            /
//    Source file        =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\Components\stack\zcl\zcl_ezmode.c             /
//    Command line       =  -f C:\Users\paolo\Documents\GitHub\zpowermeter\fi /
//                          rmware\CC2530DB\..\Tools\f8wRouter.cfg            /
//                          (-DCPU32MHZ -DROOT=__near_func                    /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                  /
//                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                          -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f                  /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Tools\f8wConfig.cfg (-DZIGBEEPRO  /
//                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      /
//                          -DDEFAULT_CHANLIST=0x00000800                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=5000       /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100   /
//                          -DREJOIN_POLL_RATE=440) -f                        /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Tools\f8wZCL.cfg                  /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\Components\stack\zcl\zcl_ezmode.c -D          /
//                          SECURE=0 -D OSC32K_CRYSTAL_INSTALLED=FALSE -D     /
//                          HAL_KEY=FALSE -D HAL_BOARD_CC2530EB_REV17 -D      /
//                          TC_LINKKEY_JOIN -D NV_INIT -D xNV_RESTORE -D      /
//                          MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_WRITE  /
//                          -D ZCL_REPORT -D FEATURE_SYSTEM_STATS -lC         /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\RouterEB\List\ -lA                   /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\RouterEB\List\ --diag_suppress       /
//                          Pe001,Pa010 -o C:\Users\paolo\Documents\GitHub\zp /
//                          owermeter\firmware\CC2530DB\RouterEB\Obj\ -e      /
//                          --debug --core=plain --dptr=16,1                  /
//                          --data_model=large --code_model=banked            /
//                          --calling_convention=xdata_reentrant              /
//                          --place_constants=data_rom --nr_virtual_regs 16   /
//                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fi /
//                          rmware\CC2530DB\ -I C:\Users\paolo\Documents\GitH /
//                          ub\zpowermeter\firmware\CC2530DB\..\Source\ -I    /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Source\ha\ -I                     /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Source\zmain\ -I                  /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\hal\include\ -I        /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\hal\target\CC2530EB\   /
//                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fi /
//                          rmware\CC2530DB\..\Components\mac\include\ -I     /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\mac\high_level\ -I     /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\mac\low_level\srf04\   /
//                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fi /
//                          rmware\CC2530DB\..\Components\mac\low_level\srf04 /
//                          \single_chip\ -I C:\Users\paolo\Documents\GitHub\ /
//                          zpowermeter\firmware\CC2530DB\..\Components\mt\   /
//                          -I C:\Users\paolo\Documents\GitHub\zpowermeter\fi /
//                          rmware\CC2530DB\..\Components\osal\include\ -I    /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\services\saddr\ -I     /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\services\sdata\ -I     /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\af\ -I           /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\nwk\ -I          /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\sapi\ -I         /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\sec\ -I          /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\sys\ -I          /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\zcl\ -I          /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\stack\zdo\ -I          /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\zmac\ -I               /
//                          C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\..\Components\zmac\f8w\ -Ohz         /
//                          --require_prototypes                              /
//    List file          =  C:\Users\paolo\Documents\GitHub\zpowermeter\firmw /
//                          are\CC2530DB\RouterEB\List\zcl_ezmode.s51         /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zcl_ezmode

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Users\paolo\Documents\GitHub\zpowermeter\firmware\Components\stack\zcl\zcl_ezmode.c
//    1 /**************************************************************************************************
//    2   Filename:       zcl_ezmode.c
//    3   Revised:        $Date: 2014-06-10 10:56:57 -0700 (Tue, 10 Jun 2014) $
//    4   Revision:       $Revision: 38928 $
//    5 
//    6   Description:    Zigbee Cluster Library - EZ Mode
//    7 
//    8 
//    9   Copyright 2013-2014 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "ZComDef.h"
//   44 #include "OSAL.h"
//   45 #include "zcl.h"
//   46 #include "zcl_general.h"
//   47 #include "zcl_ha.h"
//   48 #include "zcl_ezmode.h"
//   49 
//   50 #if defined ( INTER_PAN )
//   51   #include "stub_aps.h"
//   52 #endif
//   53 
//   54 #ifdef ZCL_EZMODE
//   55 
//   56 /*********************************************************************
//   57  * MACROS
//   58  */
//   59 
//   60 /*********************************************************************
//   61  * CONSTANTS
//   62  */
//   63 
//   64 /*********************************************************************
//   65  * TYPEDEFS
//   66  */
//   67 
//   68 /*********************************************************************
//   69  * LOCAL PROTOTYPES
//   70  */
//   71 static void zcl_SetEZModeError( uint8 errorCode );
//   72 static void zcl_SetEZModeState( zlcEZMode_State_t newState );
//   73 static void zcl_ProcessEZMode( void );
//   74 
//   75 
//   76 /*********************************************************************
//   77  * GLOBAL VARIABLES
//   78  */
//   79 
//   80 // internal EZ-Mode state machine
//   81 uint8  zclEZModeRegistered;
//   82 uint8  zclEZModeErr;
//   83 uint8  zclEZModeState;
//   84 uint8  zclEZModeOpener;
//   85 uint8  zclEZModeMatched;              // we were matched by a remote node
//   86 uint16 zclEZModeQueryRspNwkAddr;      // short address (on QueryRsp)
//   87 uint8  zclEZModeQueryRspEP;           // endpoint (on QueryRsp)
//   88 zclEZMode_RegisterData_t zclEZModeRegisterData;   // registered once on init
//   89 zclEZMode_InvokeData_t   zclEZModeInvokeData;     // user's configuration parameters (what endpoint, initiator, etc...)
//   90 
//   91 
//   92 /*********************************************************************
//   93  * GLOBAL FUNCTIONS
//   94  */
//   95 
//   96 /*********************************************************************
//   97  * @fn      zcl_RegisterEZMode
//   98  *
//   99  * @brief   Called upon task initialation, to initialize EZ-Mode.
//  100  *
//  101  * @param   pData - task ID, App Callback routine, etc..
//  102  *
//  103  * @return  none
//  104  */
//  105 void zcl_RegisterEZMode( zclEZMode_RegisterData_t const *pData )
//  106 {
//  107   // make a copy of the data. Cannot fail.
//  108   osal_memcpy( &zclEZModeRegisterData, pData, sizeof(zclEZMode_RegisterData_t) );
//  109   zclEZModeRegistered = TRUE;
//  110 }
//  111 
//  112 /*********************************************************************
//  113  * @fn      zcl_InvokeEZMode
//  114  *
//  115  * @brief   Called to invoke EZ-Mode on an endpoint. This is a toggle
//  116  *          (will cancel if EZ-Mode currently enabled). Note: there is only 1
//  117  *          state machine. EZ-Mode can only be invoked on 1 endpoint at a time.
//  118  *
//  119  * @param   none
//  120  *
//  121  * @return  none
//  122  */
//  123 void zcl_InvokeEZMode( zclEZMode_InvokeData_t *pData )
//  124 {
//  125   // if not registered, do nothing
//  126   if(!zclEZModeRegistered)
//  127   {
//  128     return;
//  129   }
//  130 
//  131   // there is only 1 EZ-Mode state machine. If already in EZ-Mode, cancel it
//  132   if(zclEZModeState != EZMODE_STATE_READY)
//  133   {
//  134     zcl_SetEZModeError ( EZMODE_ERR_CANCELLED );
//  135     zcl_SetEZModeState ( EZMODE_STATE_FINISH );  // needed to shut down timers, turn off joining, etc...
//  136     return;
//  137   }
//  138 
//  139   // copy the data, so we remember which endpoint, etc...
//  140   osal_memcpy( &zclEZModeInvokeData, pData, sizeof(zclEZMode_InvokeData_t) );
//  141 
//  142   // start with no error, and no QueryResponses in our list
//  143   zcl_SetEZModeError ( EZMODE_ERR_SUCCESS );
//  144   zclEZModeOpener = zclEZModeMatched = 0;
//  145 
//  146   // if already on network, just go to identify state
//  147   if ( zclEZModeInvokeData.onNetwork )
//  148   {
//  149     zcl_SetEZModeState( EZMODE_STATE_OPENER );
//  150   }
//  151 
//  152   // not already on network, form/join a network
//  153   else
//  154   {
//  155     zcl_SetEZModeState( EZMODE_STATE_JOINER );
//  156   }
//  157 
//  158   // start a total timeout for EZ_Mode (will cancel if not finished in this time)
//  159   osal_start_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt, EZMODE_TIME );
//  160 }
//  161 
//  162 /*********************************************************************
//  163  * @fn      zcl_EZModeAction
//  164  *
//  165  * @brief   Called when the application needs to inform EZ-Mode of some action
//  166  *          (now on the network, identify mode query, etc...)
//  167  *
//  168  * @param   action - which action has taken place
//  169  *          pData  - the data unique to the action
//  170  *
//  171  * @return  none
//  172  */
//  173 void zcl_EZModeAction(zclEzMode_Action_t action, zclEZMode_ActionData_t *pData)
//  174 {
//  175   ZDO_MatchDescRsp_t *pMatchDescRsp;
//  176   zAddrType_t dstAddr;
//  177 
//  178   // not in the EZ-Mode state machine, so do nothing
//  179   if( zclEZModeState == EZMODE_STATE_READY )
//  180     return;
//  181 
//  182   switch ( action )
//  183   {
//  184     case EZMODE_ACTION_PROCESS:
//  185       zcl_ProcessEZMode();  // process next state
//  186     break;
//  187 
//  188     case EZMODE_ACTION_NETWORK_STARTED:
//  189       // once on the network, time to go on to the identify state
//  190       if( zclEZModeState == EZMODE_STATE_JOINER )
//  191       {
//  192         // set local permit joining on locally only for joiners (openers turn it on across the network)
//  193         NLME_PermitJoiningRequest( (byte)(EZMODE_TIME / 1000) ); // in seconds
//  194         zcl_SetEZModeState( EZMODE_STATE_IDENTIFYING );
//  195       }
//  196     break;
//  197 
//  198     // received identify query
//  199     case EZMODE_ACTION_IDENTIFY_QUERY:
//  200 
//  201       // targets just go to autoclose once they have been identified
//  202       if ( !zclEZModeInvokeData.initiator )
//  203       {
//  204         zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
//  205       }
//  206     break;
//  207 
//  208     // received identify query response
//  209     case EZMODE_ACTION_IDENTIFY_QUERY_RSP:
//  210 
//  211       // remember the node we found via identify query
//  212       zclEZModeQueryRspNwkAddr = pData->pIdentifyQueryRsp->srcAddr->addr.shortAddr;
//  213       zclEZModeQueryRspEP = pData->pIdentifyQueryRsp->srcAddr->endPoint;
//  214 
//  215       // initiate match descriptor request on the remote node
//  216       dstAddr.addrMode = Addr16Bit;
//  217       dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
//  218       ZDP_MatchDescReq( &dstAddr, zclEZModeQueryRspNwkAddr,
//  219                         ZCL_HA_PROFILE_ID,
//  220                         zclEZModeInvokeData.numActiveOutClusters, zclEZModeInvokeData.pActiveOutClusterIDs,
//  221                         zclEZModeInvokeData.numActiveInClusters, zclEZModeInvokeData.pActiveInClusterIDs,
//  222                         FALSE );
//  223       zcl_SetEZModeState( EZMODE_STATE_WAITING_MATCHDESCRSP );
//  224     break;
//  225 
//  226     // received match descriptor response, see if active clusters match
//  227     case EZMODE_ACTION_MATCH_DESC_RSP:
//  228 
//  229       pMatchDescRsp = pData->pMatchDescRsp;
//  230       if ( ( pMatchDescRsp && pMatchDescRsp->status == ZSuccess ) && ( pMatchDescRsp->cnt>0 ) )
//  231       {
//  232         zclEZModeMatched = TRUE;
//  233 
//  234         // BindingEntry_t *bindAddEntry( byte srcEpInt, zAddrType_t *dstAddr, byte dstEpInt, byte numClusterIds, uint16 *clusterIds )
//  235         dstAddr.addr.shortAddr = zclEZModeQueryRspNwkAddr;
//  236         dstAddr.addrMode = Addr16Bit;
//  237 
//  238         // bind each matching input cluster
//  239         if ( zclEZModeInvokeData.numActiveInClusters )
//  240         {
//  241           bindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
//  242                         zclEZModeInvokeData.numActiveInClusters, zclEZModeInvokeData.pActiveInClusterIDs );
//  243         }
//  244 
//  245         // bind each matching output cluster
//  246         if ( zclEZModeInvokeData.numActiveOutClusters )
//  247         {
//  248           bindAddEntry( zclEZModeInvokeData.endpoint, &dstAddr, zclEZModeQueryRspEP,
//  249                         zclEZModeInvokeData.numActiveOutClusters, zclEZModeInvokeData.pActiveOutClusterIDs );
//  250         }
//  251       }
//  252 
//  253       // time to close (wait a bit before finishing, to allow for multiple initiators)
//  254       zcl_SetEZModeState( EZMODE_STATE_AUTOCLOSE );
//  255     break;
//  256 
//  257     // timed out of EZ-Mode
//  258     case EZMODE_ACTION_TIMED_OUT:
//  259       // timed out
//  260       if(zclEZModeState != EZMODE_STATE_READY)
//  261       {
//  262         zcl_SetEZModeError( EZMODE_ERR_TIMEDOUT );
//  263         zcl_SetEZModeState( EZMODE_STATE_FINISH );
//  264       }
//  265     break;
//  266   }   // switch ( action )
//  267 
//  268 }
//  269 
//  270 /*********************************************************************
//  271  * LOCAL VARIABLES
//  272  */
//  273 
//  274 
//  275 /*********************************************************************
//  276  * LOCAL FUNCTIONS
//  277  */
//  278 
//  279 /*********************************************************************
//  280  * @fn      zcl_SetEZModeState
//  281  *
//  282  * @brief   Move on to new state after a short wait.
//  283  *
//  284  * @param   none
//  285  *
//  286  * @return  none
//  287  */
//  288 static void zcl_SetEZModeState( zlcEZMode_State_t newState )
//  289 {
//  290   zclEZModeState = newState;
//  291   osal_start_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, 5 );
//  292 }
//  293 
//  294 /*********************************************************************
//  295  * @fn      zclSampleSw_SetEZModeError
//  296  *
//  297  * @brief   Called to set error code that will be reported on finish. Starts as EZMODE_ERR_SUCCESS.
//  298  *
//  299  * @param   none
//  300  *
//  301  * @return  none
//  302  */
//  303 static void zcl_SetEZModeError( uint8 errorCode )
//  304 {
//  305   zclEZModeErr = errorCode;
//  306 }
//  307 
//  308 /*********************************************************************
//  309  * @fn      zcl_ProcessEZMode
//  310  *
//  311  * @brief   Called when EZ-Mode changes state. See EZMODE_STATE_xxxx in zcl_ezmode.h
//  312  *
//  313  * @param   none
//  314  *
//  315  * @return  status
//  316  */
//  317 static void zcl_ProcessEZMode( void )
//  318 {
//  319   zAddrType_t dstAddr;
//  320   afAddrType_t afDstAddr;
//  321   zclEZMode_CBData_t cbData;
//  322 
//  323   dstAddr.addr.shortAddr = 0xfffc;        // all routers (for PermitJoin) devices
//  324   dstAddr.addrMode = AddrBroadcast;
//  325 
//  326   afDstAddr.addr.shortAddr = 0xffff;      // all devices (for IdentifyQuery)
//  327   afDstAddr.addrMode = afAddrBroadcast;
//  328   afDstAddr.endPoint = 0xff;
//  329 
//  330   switch(zclEZModeState)
//  331   {
//  332     // openers will broadcast permit joining
//  333     case EZMODE_STATE_OPENER:
//  334       zclEZModeOpener = 1;
//  335 
//  336       // enable joining both locally and over-the-air
//  337       NLME_PermitJoiningRequest( (byte)(EZMODE_TIME / 1000)  );
//  338       ZDP_MgmtPermitJoinReq( &dstAddr, (byte)(EZMODE_TIME / 1000), TRUE, FALSE);
//  339 
//  340       // then go to identifying state
//  341       zcl_SetEZModeState(EZMODE_STATE_IDENTIFYING);
//  342     break;
//  343 
//  344     // joiners will try to join the network, and if success will go to identifying state
//  345     case EZMODE_STATE_JOINER:
//  346       zclEZModeOpener = 0;
//  347       ZDOInitDevice(0);   // see ZDO_STATE_CHANGE in zclSampleSw_event_loop()
//  348     break;
//  349 
//  350     // go into identify state
//  351     case EZMODE_STATE_IDENTIFYING:
//  352 
//  353       // tell app to go into identify mode
//  354       if ( zclEZModeRegisterData.pfnNotifyCB )
//  355       {
//  356         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, NULL );
//  357       }
//  358 
//  359       // initiators start looking for other nodes in identify mode
//  360       if ( zclEZModeInvokeData.initiator )
//  361       {
//  362         zcl_SetEZModeState ( EZMODE_STATE_WAITING_IDENTIFYQUERYRSP );
//  363       }
//  364     break;
//  365 
//  366     // timeout out with no query response, send another
//  367     case EZMODE_STATE_WAITING_IDENTIFYQUERYRSP:
//  368       // ZStatus_t zclGeneral_SendIdentifyQuery( uint8 srcEP, afAddrType_t *dstAddr, uint8 disableDefaultRsp, uint8 seqNum );
//  369       // NOTE: Ensure that Identify Cluster is enabled to use this function for EZ-Mode
//  370       zclGeneral_SendIdentifyQuery( zclEZModeInvokeData.endpoint, &afDstAddr, TRUE, (*zclEZModeRegisterData.pZclSeqNum)++ );
//  371 
//  372       // wait some time before sending out the next IdentifyQuery, will stop when we get a response
//  373       osal_start_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_IDQUERYTIME );
//  374       break;
//  375 
//  376     // waiting for simple descriptor response
//  377     case EZMODE_STATE_WAITING_MATCHDESCRSP:
//  378     break;
//  379 
//  380     // if waiting on autoclose, then we're done. Go to success.
//  381     case EZMODE_STATE_AUTOCLOSE:
//  382 
//  383       // special case: if 2 initators, we only fail if no match from either side
//  384       if( zclEZModeInvokeData.initiator && !zclEZModeMatched )
//  385       {
//  386         zcl_SetEZModeError ( EZMODE_ERR_NOMATCH );
//  387       }
//  388 
//  389       // if user specified callback, call on AutoClose
//  390       if ( zclEZModeRegisterData.pfnNotifyCB )
//  391       {
//  392         cbData.sAutoClose.err = zclEZModeErr;
//  393         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
//  394       }
//  395 
//  396       // no longer will timeout, since cannot fail
//  397       osal_stop_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
//  398 
//  399       // wait a little to turn off identify mode, to give time for the other side to discover
//  400       // in case of complex devices (both target/initiator)
//  401       osal_start_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.processEvt, EZMODE_AUTOCLOSETIME );
//  402 
//  403       // go to finish state after autoclose. Don't use zcl_SetEZModeState() because we don't want it to happen immediately
//  404       zclEZModeState = EZMODE_STATE_FINISH;
//  405     break;
//  406 
//  407     case EZMODE_STATE_FINISH:
//  408 
//  409       // no longer will timeout, since we're done
//  410       osal_stop_timerEx( *zclEZModeRegisterData.pTaskID, zclEZModeRegisterData.timeoutEvt );
//  411 
//  412       // if we opened the network, close it now (turn off joining)
//  413       if ( zclEZModeOpener )
//  414       {
//  415         ZDP_MgmtPermitJoinReq( &dstAddr, 0, TRUE, FALSE);
//  416       }
//  417 
//  418       // if user callback, inform them of the finish, which will also turn off identify
//  419       if ( zclEZModeRegisterData.pfnNotifyCB )
//  420       {
//  421         cbData.sFinish.err = zclEZModeErr;
//  422         cbData.sFinish.ep = zclEZModeQueryRspEP;
//  423         cbData.sFinish.nwkaddr = zclEZModeQueryRspNwkAddr;
//  424         (*zclEZModeRegisterData.pfnNotifyCB)( zclEZModeState, &cbData );
//  425       }
//  426 
//  427       // done, back to ready state
//  428       zclEZModeState = EZMODE_STATE_READY;
//  429     break;
//  430   }
//  431 
//  432 }
//  433 
//  434 #endif // ZCL_EZMODE
// 
//
// 
//
//
//Errors: none
//Warnings: none
